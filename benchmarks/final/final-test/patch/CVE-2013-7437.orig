   We choose to be as permissive as possible, since there are many
   programs out there which produce BMP. For instance, ppmtobmp can
   produce codings with anywhere from 1-8 or 24 bits per sample,
   although most specifications only allow 1,4,8,24,32. We can also
   read both the old and new OS/2 BMP formats in addition to the
   Windows BMP format. */
static int bm_readbody_bmp(FILE *f, double threshold, potrace_bitmap_t **bmp) {
  bmp_info_t bmpinfo;
  int *coltable;
  unsigned int b, c;
  unsigned int i;
  potrace_bitmap_t *bm;
  int mask;
  unsigned int x, y;
  int col[2];
  unsigned int bitbuf;
  unsigned int n;
  unsigned int redshift, greenshift, blueshift;
  int col1[2];

  bm_read_error = NULL;
  bm = NULL;
  coltable = NULL;

  bmp_pos = 2;  /* set file position */

  /* file header (minus magic number) */
  TRY(bmp_readint(f, 4, &bmpinfo.FileSize));
  TRY(bmp_readint(f, 4, &bmpinfo.reserved));
  TRY(bmp_readint(f, 4, &bmpinfo.DataOffset));

  /* info header */
  TRY(bmp_readint(f, 4, &bmpinfo.InfoSize));
  if (bmpinfo.InfoSize == 40 || bmpinfo.InfoSize == 64
      || bmpinfo.InfoSize == 108 || bmpinfo.InfoSize == 124) {
    /* Windows or new OS/2 format */
    bmpinfo.ctbits = 32; /* sample size in color table */
    TRY(bmp_readint(f, 4, &bmpinfo.w));
    TRY(bmp_readint(f, 4, &bmpinfo.h));
    TRY(bmp_readint(f, 2, &bmpinfo.Planes));
    TRY(bmp_readint(f, 2, &bmpinfo.bits));
    TRY(bmp_readint(f, 4, &bmpinfo.comp));
    TRY(bmp_readint(f, 4, &bmpinfo.ImageSize));
    TRY(bmp_readint(f, 4, &bmpinfo.XpixelsPerM));
    TRY(bmp_readint(f, 4, &bmpinfo.YpixelsPerM));
    TRY(bmp_readint(f, 4, &bmpinfo.ncolors));
    TRY(bmp_readint(f, 4, &bmpinfo.ColorsImportant));
    if (bmpinfo.InfoSize >= 108) { /* V4 and V5 bitmaps */
      TRY(bmp_readint(f, 4, &bmpinfo.RedMask));
      TRY(bmp_readint(f, 4, &bmpinfo.GreenMask));
      TRY(bmp_readint(f, 4, &bmpinfo.BlueMask));
      TRY(bmp_readint(f, 4, &bmpinfo.AlphaMask));
    }
    if ((signed int)bmpinfo.h < 0) {
      bmpinfo.h = -bmpinfo.h;
      bmpinfo.topdown = 1;
    } else {
      bmpinfo.topdown = 0;
    }
  } else if (bmpinfo.InfoSize == 12) {
    /* old OS/2 format */
    bmpinfo.ctbits = 24; /* sample size in color table */
    TRY(bmp_readint(f, 2, &bmpinfo.w));
    TRY(bmp_readint(f, 2, &bmpinfo.h));
    TRY(bmp_readint(f, 2, &bmpinfo.Planes));
    TRY(bmp_readint(f, 2, &bmpinfo.bits));
    bmpinfo.comp = 0;
    bmpinfo.ncolors = 0;
    bmpinfo.topdown = 0;
  } else {
    goto format_error;
  }

  if (bmpinfo.comp == 3 && bmpinfo.InfoSize < 108) {
    /* bitfield feature is only understood with V4 and V5 format */
    goto format_error;
  }

  /* forward to color table (e.g., if bmpinfo.InfoSize == 64) */
  TRY(bmp_forward(f, 14+bmpinfo.InfoSize));

  if (bmpinfo.Planes != 1) {
    bm_read_error = "cannot handle bmp planes";
    goto format_error;  /* can't handle planes */
  }
  
  if (bmpinfo.ncolors == 0) {
    bmpinfo.ncolors = 1 << bmpinfo.bits;
  }

  /* color table, present only if bmpinfo.bits <= 8. */
  if (bmpinfo.bits <= 8) {
    coltable = (int *) malloc(bmpinfo.ncolors * sizeof(int));
    if (!coltable) {
      goto std_error;
    }
    /* NOTE: since we are reading a bitmap, we can immediately convert
       the color table entries to bits. */
    for (i=0; i<bmpinfo.ncolors; i++) {
      TRY(bmp_readint(f, bmpinfo.ctbits/8, &c));
      c = ((c>>16) & 0xff) + ((c>>8) & 0xff) + (c & 0xff);
      coltable[i] = (c > 3 * threshold * 255 ? 0 : 1);
      if (i<2) {
	col1[i] = c;
      }
    }
  }

  /* forward to data */
  if (bmpinfo.InfoSize != 12) { /* not old OS/2 format */
    TRY(bmp_forward(f, bmpinfo.DataOffset));
  }

  /* allocate bitmap */
  bm = bm_new(bmpinfo.w, bmpinfo.h);
  if (!bm) {
    goto std_error;
  }
  
  /* zero it out */
  bm_clear(bm, 0);

  switch (bmpinfo.bits + 0x100*bmpinfo.comp) {
    
  default:
    goto format_error;
    break;
    
  case 0x001:  /* monochrome palette */
    if (col1[0] < col1[1]) { /* make the darker color black */
      mask = 0xff;
    } else {
      mask = 0;
    }
    
    /* raster data */
    for (y=0; y<bmpinfo.h; y++) {
      bmp_pad_reset();
      for (i=0; 8*i<bmpinfo.w; i++) {
	TRY_EOF(bmp_readint(f, 1, &b));
	b ^= mask;
	*bm_index(bm, i*8, ycorr(y)) |= ((potrace_word)b) << (8*(BM_WORDSIZE-1-(i % BM_WORDSIZE)));
      }
      TRY(bmp_pad(f));
    }
    break;
   
  case 0x002:  /* 2-bit to 8-bit palettes */
  case 0x003: 
  case 0x004: 
  case 0x005: 
  case 0x006: 
  case 0x007: 
  case 0x008:
    for (y=0; y<bmpinfo.h; y++) {
      bmp_pad_reset();
      bitbuf = 0;  /* bit buffer: bits in buffer are high-aligned */
      n = 0;       /* number of bits currently in bitbuffer */
      for (x=0; x<bmpinfo.w; x++) {
	if (n < bmpinfo.bits) {
	  TRY_EOF(bmp_readint(f, 1, &b));
	  bitbuf |= b << (INTBITS - 8 - n);
	  n += 8;
	}
	b = bitbuf >> (INTBITS - bmpinfo.bits);
	bitbuf <<= bmpinfo.bits;
	n -= bmpinfo.bits;
	BM_UPUT(bm, x, ycorr(y), coltable[b]);
      }
      TRY(bmp_pad(f));
    }
    break;

  case 0x010:  /* 16-bit encoding */
    /* can't do this format because it is not well-documented and I
       don't have any samples */
    bm_read_error = "cannot handle bmp 16-bit coding";
    goto format_error;
    break;

  case 0x018:  /* 24-bit encoding */
  case 0x020:  /* 32-bit encoding */
    for (y=0; y<bmpinfo.h; y++) {
      bmp_pad_reset();
      for (x=0; x<bmpinfo.w; x++) {
        TRY_EOF(bmp_readint(f, bmpinfo.bits/8, &c));
	c = ((c>>16) & 0xff) + ((c>>8) & 0xff) + (c & 0xff);
        BM_UPUT(bm, x, ycorr(y), c > 3 * threshold * 255 ? 0 : 1);
      }
      TRY(bmp_pad(f));
    }
    break;

  case 0x320:  /* 32-bit encoding with bitfields */
    redshift = lobit(bmpinfo.RedMask);
    greenshift = lobit(bmpinfo.GreenMask);
    blueshift = lobit(bmpinfo.BlueMask);

    for (y=0; y<bmpinfo.h; y++) {
      bmp_pad_reset();
      for (x=0; x<bmpinfo.w; x++) {
        TRY_EOF(bmp_readint(f, bmpinfo.bits/8, &c));
	c = ((c & bmpinfo.RedMask) >> redshift) + ((c & bmpinfo.GreenMask) >> greenshift) + ((c & bmpinfo.BlueMask) >> blueshift);
        BM_UPUT(bm, x, ycorr(y), c > 3 * threshold * 255 ? 0 : 1);
      }
      TRY(bmp_pad(f));
    }
    break;

  case 0x204:  /* 4-bit runlength compressed encoding (RLE4) */
    x = 0;
    y = 0;
    while (1) {
      TRY_EOF(bmp_readint(f, 1, &b)); /* opcode */
      TRY_EOF(bmp_readint(f, 1, &c)); /* argument */
      if (b>0) {
	/* repeat count */
	col[0] = coltable[(c>>4) & 0xf];
	col[1] = coltable[c & 0xf];
	for (i=0; i<b && x<bmpinfo.w; i++) {
	  if (x>=bmpinfo.w) {
	    x=0;
	    y++;
	  }
	  if (y>=bmpinfo.h) {
	    break;
	  }
	  BM_UPUT(bm, x, ycorr(y), col[i&1]);
	  x++;
	}
      } else if (c == 0) {
	/* end of line */
	y++;
	x = 0;
      } else if (c == 1) {
	/* end of bitmap */
	break;
      } else if (c == 2) {
	/* "delta": skip pixels in x and y directions */
	TRY_EOF(bmp_readint(f, 1, &b)); /* x offset */
	TRY_EOF(bmp_readint(f, 1, &c)); /* y offset */
	x += b;
	y += c;
      } else {
	/* verbatim segment */
	for (i=0; i<c; i++) {
	  if ((i&1)==0) {
	    TRY_EOF(bmp_readint(f, 1, &b));
	  }
	  if (x>=bmpinfo.w) {
	    x=0;
	    y++;
	  }
	  if (y>=bmpinfo.h) {
	    break;
	  }
	  BM_PUT(bm, x, ycorr(y), coltable[(b>>(4-4*(i&1))) & 0xf]);
	  x++;
	}
	if ((c+1) & 2) {
	  /* pad to 16-bit boundary */
	  TRY_EOF(bmp_readint(f, 1, &b));
	}
      }
    }
    break;

  case 0x108:  /* 8-bit runlength compressed encoding (RLE8) */
    x = 0;
    y = 0;
    while (1) {
      TRY_EOF(bmp_readint(f, 1, &b)); /* opcode */
      TRY_EOF(bmp_readint(f, 1, &c)); /* argument */
      if (b>0) {
	/* repeat count */
	for (i=0; i<b; i++) {
	  if (x>=bmpinfo.w) {
	    x=0;
	    y++;
	  }
	  if (y>=bmpinfo.h) {
	    break;
	  }
	  BM_UPUT(bm, x, ycorr(y), coltable[c]);
	  x++;
	}
      } else if (c == 0) {
	/* end of line */
	y++;
	x = 0;
      } else if (c == 1) {
	/* end of bitmap */
	break;
      } else if (c == 2) {
	/* "delta": skip pixels in x and y directions */
	TRY_EOF(bmp_readint(f, 1, &b)); /* x offset */
	TRY_EOF(bmp_readint(f, 1, &c)); /* y offset */
	x += b;
	y += c;
      } else {
	/* verbatim segment */
	for (i=0; i<c; i++) {
	  TRY_EOF(bmp_readint(f, 1, &b));
          if (x>=bmpinfo.w) {
            x=0;
            y++;
          }
          if (y>=bmpinfo.h) {
            break;
          }
	  BM_PUT(bm, x, ycorr(y), coltable[b]);
	  x++;
	}
	if (c & 1) {
	  /* pad input to 16-bit boundary */
	  TRY_EOF(bmp_readint(f, 1, &b));
	}
      }
    }
    break;

  } /* switch */

  /* skip any potential junk after the data section, but don't
     complain in case EOF is encountered */
  bmp_forward(f, bmpinfo.FileSize);

  free(coltable);
  *bmp = bm;
  return 0;

 eof:
  free(coltable);
  *bmp = bm;
  return 1;

 format_error:
 try_error:
  free(coltable);
  free(bm);
  if (!bm_read_error) {
    bm_read_error = "invalid bmp file";
  }
  return -2;

 std_error:
  free(coltable);
  free(bm);
  return -1;
}

