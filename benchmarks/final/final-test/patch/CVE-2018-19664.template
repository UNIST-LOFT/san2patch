 482 | GLOBAL(djpeg_dest_ptr)
 483 | jinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,
 484 |                 boolean use_inversion_array)
 485 | {
 486 |   bmp_dest_ptr dest;
 487 |   JDIMENSION row_width;
 488 | 
 489 |   /* Create module interface object, fill in method pointers */
 490 |   dest = (bmp_dest_ptr)
 491 |     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
 492 |                                 sizeof(bmp_dest_struct));
 493 |   dest->pub.start_output = start_output_bmp;
 494 |   dest->pub.finish_output = finish_output_bmp;
 495 |   dest->pub.calc_buffer_dimensions = NULL;
 496 |   dest->is_os2 = is_os2;
 497 | 
 498 |   if (cinfo->out_color_space == JCS_GRAYSCALE) {
 499 |     dest->pub.put_pixel_rows = put_gray_rows;
 500 |   } else if (IsExtRGB(cinfo->out_color_space)) {
 501 |     if (cinfo->quantize_colors)
 502 |       dest->pub.put_pixel_rows = put_gray_rows;
 503 |     else
 504 |       dest->pub.put_pixel_rows = put_pixel_rows; // PATCH LOCATION
 505 |   } else if (cinfo->out_color_space == JCS_RGB565 ||
 506 |              cinfo->out_color_space == JCS_CMYK) {
 507 |     dest->pub.put_pixel_rows = put_pixel_rows;
 508 |   } else {
 509 |     ERREXIT(cinfo, JERR_BMP_COLORSPACE);
 510 |   }
 511 | 
 512 |   /* Calculate output image dimensions so we can allocate space */
 513 |   jpeg_calc_output_dimensions(cinfo);
 514 | 
 515 |   /* Determine width of rows in the BMP file (padded to 4-byte boundary). */
 516 |   if (cinfo->out_color_space == JCS_RGB565) {
 517 |     row_width = cinfo->output_width * 2;
 518 |     dest->row_width = dest->data_width = cinfo->output_width * 3;
 519 |     while ((row_width & 3) != 0) row_width++;
 520 |   } else if (!cinfo->quantize_colors &&
 521 |              (IsExtRGB(cinfo->out_color_space) ||
 522 |               cinfo->out_color_space == JCS_CMYK)) {
 523 |     row_width = cinfo->output_width * cinfo->output_components;
 524 |     dest->row_width = dest->data_width = cinfo->output_width * 3;
 525 |   } else {
 526 |     row_width = cinfo->output_width * cinfo->output_components;
 527 |     dest->row_width = dest->data_width = row_width;
 528 |   }
 529 |   while ((dest->row_width & 3) != 0) dest->row_width++;
 530 |   dest->pad_bytes = (int)(dest->row_width - dest->data_width);
 531 | 
 532 | 
 533 |   if (use_inversion_array) {
 534 |     /* Allocate space for inversion array, prepare for write pass */
 535 |     dest->whole_image = (*cinfo->mem->request_virt_sarray)
 536 |       ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,
 537 |        dest->row_width, cinfo->output_height, (JDIMENSION)1);
 538 |     dest->cur_output_row = 0;
 539 |     if (cinfo->progress != NULL) {
 540 |       cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;
 541 |       progress->total_extra_passes++; /* count file input as separate pass */
 542 |     }
 543 |   } else {
 544 |     dest->iobuffer = (JSAMPLE *)(*cinfo->mem->alloc_small)
 545 |       ((j_common_ptr)cinfo, JPOOL_IMAGE, dest->row_width);
 546 |   }
 547 |   dest->use_inversion_array = use_inversion_array;
 548 | 
 549 |   /* Create decompressor output buffer. */
 550 |   dest->pub.buffer = (*cinfo->mem->alloc_sarray)
 551 |     ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width, (JDIMENSION)1);
 552 |   dest->pub.buffer_height = 1;
 553 | 
 554 |   return (djpeg_dest_ptr)dest;
 555 | }
