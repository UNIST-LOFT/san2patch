 428 |    We choose to be as permissive as possible, since there are many
 429 |    programs out there which produce BMP. For instance, ppmtobmp can
 430 |    produce codings with anywhere from 1-8 or 24 bits per sample,
 431 |    although most specifications only allow 1,4,8,24,32. We can also
 432 |    read both the old and new OS/2 BMP formats in addition to the
 433 |    Windows BMP format. */
 434 | static int bm_readbody_bmp(FILE *f, double threshold, potrace_bitmap_t **bmp) {
 435 |   bmp_info_t bmpinfo;
 436 |   int *coltable;
 437 |   unsigned int b, c;
 438 |   unsigned int i;
 439 |   potrace_bitmap_t *bm;
 440 |   int mask;
 441 |   unsigned int x, y;
 442 |   int col[2];
 443 |   unsigned int bitbuf;
 444 |   unsigned int n;
 445 |   unsigned int redshift, greenshift, blueshift;
 446 |   int col1[2];
 447 | 
 448 |   bm_read_error = NULL;
 449 |   bm = NULL;
 450 |   coltable = NULL;
 451 | 
 452 |   bmp_pos = 2;  /* set file position */
 453 | 
 454 |   /* file header (minus magic number) */
 455 |   TRY(bmp_readint(f, 4, &bmpinfo.FileSize));
 456 |   TRY(bmp_readint(f, 4, &bmpinfo.reserved));
 457 |   TRY(bmp_readint(f, 4, &bmpinfo.DataOffset));
 458 | 
 459 |   /* info header */
 460 |   TRY(bmp_readint(f, 4, &bmpinfo.InfoSize));
 461 |   if (bmpinfo.InfoSize == 40 || bmpinfo.InfoSize == 64
 462 |       || bmpinfo.InfoSize == 108 || bmpinfo.InfoSize == 124) {
 463 |     /* Windows or new OS/2 format */
 464 |     bmpinfo.ctbits = 32; /* sample size in color table */
 465 |     TRY(bmp_readint(f, 4, &bmpinfo.w));
 466 |     TRY(bmp_readint(f, 4, &bmpinfo.h));
 467 |     TRY(bmp_readint(f, 2, &bmpinfo.Planes));
 468 |     TRY(bmp_readint(f, 2, &bmpinfo.bits));
 469 |     TRY(bmp_readint(f, 4, &bmpinfo.comp));
 470 |     TRY(bmp_readint(f, 4, &bmpinfo.ImageSize));
 471 |     TRY(bmp_readint(f, 4, &bmpinfo.XpixelsPerM));
 472 |     TRY(bmp_readint(f, 4, &bmpinfo.YpixelsPerM));
 473 |     TRY(bmp_readint(f, 4, &bmpinfo.ncolors));
 474 |     TRY(bmp_readint(f, 4, &bmpinfo.ColorsImportant));
 475 |     if (bmpinfo.InfoSize >= 108) { /* V4 and V5 bitmaps */
 476 |       TRY(bmp_readint(f, 4, &bmpinfo.RedMask));
 477 |       TRY(bmp_readint(f, 4, &bmpinfo.GreenMask));
 478 |       TRY(bmp_readint(f, 4, &bmpinfo.BlueMask));
 479 |       TRY(bmp_readint(f, 4, &bmpinfo.AlphaMask));
 480 |     }
 481 |     if ((signed int)bmpinfo.h < 0) { // PATCH LOCATION 482 |       bmpinfo.h = -bmpinfo.h;
 483 |       bmpinfo.topdown = 1;
 484 |     } else {
 485 |       bmpinfo.topdown = 0;
 486 |     }
 487 |   } else if (bmpinfo.InfoSize == 12) {
 488 |     /* old OS/2 format */
 489 |     bmpinfo.ctbits = 24; /* sample size in color table */
 490 |     TRY(bmp_readint(f, 2, &bmpinfo.w));
 491 |     TRY(bmp_readint(f, 2, &bmpinfo.h));
 492 |     TRY(bmp_readint(f, 2, &bmpinfo.Planes));
 493 |     TRY(bmp_readint(f, 2, &bmpinfo.bits));
 494 |     bmpinfo.comp = 0;
 495 |     bmpinfo.ncolors = 0;
 496 |     bmpinfo.topdown = 0;
 497 |   } else {
 498 |     goto format_error;
 499 |   }
 500 | 
 501 |   if (bmpinfo.comp == 3 && bmpinfo.InfoSize < 108) {
 502 |     /* bitfield feature is only understood with V4 and V5 format */
 503 |     goto format_error;
 504 |   }
 505 | 
 506 |   /* forward to color table (e.g., if bmpinfo.InfoSize == 64) */
 507 |   TRY(bmp_forward(f, 14+bmpinfo.InfoSize));
 508 | 
 509 |   if (bmpinfo.Planes != 1) {
 510 |     bm_read_error = "cannot handle bmp planes";
 511 |     goto format_error;  /* can't handle planes */
 512 |   }
 513 |   
 514 |   if (bmpinfo.ncolors == 0) {
 515 |     bmpinfo.ncolors = 1 << bmpinfo.bits;
 516 |   }
 517 | 
 518 |   /* color table, present only if bmpinfo.bits <= 8. */
 519 |   if (bmpinfo.bits <= 8) {
 520 |     coltable = (int *) malloc(bmpinfo.ncolors * sizeof(int));
 521 |     if (!coltable) {
 522 |       goto std_error;
 523 |     }
 524 |     /* NOTE: since we are reading a bitmap, we can immediately convert
 525 |        the color table entries to bits. */
 526 |     for (i=0; i<bmpinfo.ncolors; i++) {
 527 |       TRY(bmp_readint(f, bmpinfo.ctbits/8, &c));
 528 |       c = ((c>>16) & 0xff) + ((c>>8) & 0xff) + (c & 0xff);
 529 |       coltable[i] = (c > 3 * threshold * 255 ? 0 : 1);
 530 |       if (i<2) {
 531 | 	col1[i] = c;
 532 |       }
 533 |     }
 534 |   }
 535 | 
 536 |   /* forward to data */
 537 |   if (bmpinfo.InfoSize != 12) { /* not old OS/2 format */
 538 |     TRY(bmp_forward(f, bmpinfo.DataOffset));
 539 |   }
 540 | 
 541 |   /* allocate bitmap */
 542 |   bm = bm_new(bmpinfo.w, bmpinfo.h);
 543 |   if (!bm) {
 544 |     goto std_error;
 545 |   }
 546 |   
 547 |   /* zero it out */
 548 |   bm_clear(bm, 0);
 549 | 
 550 |   switch (bmpinfo.bits + 0x100*bmpinfo.comp) {
 551 |     
 552 |   default:
 553 |     goto format_error;
 554 |     break;
 555 |     
 556 |   case 0x001:  /* monochrome palette */
 557 |     if (col1[0] < col1[1]) { /* make the darker color black */
 558 |       mask = 0xff;
 559 |     } else {
 560 |       mask = 0;
 561 |     }
 562 |     
 563 |     /* raster data */
 564 |     for (y=0; y<bmpinfo.h; y++) {
 565 |       bmp_pad_reset();
 566 |       for (i=0; 8*i<bmpinfo.w; i++) {
 567 | 	TRY_EOF(bmp_readint(f, 1, &b));
 568 | 	b ^= mask;
 569 | 	*bm_index(bm, i*8, ycorr(y)) |= ((potrace_word)b) << (8*(BM_WORDSIZE-1-(i % BM_WORDSIZE)));
 570 |       }
 571 |       TRY(bmp_pad(f));
 572 |     }
 573 |     break;
 574 |    
 575 |   case 0x002:  /* 2-bit to 8-bit palettes */
 576 |   case 0x003: 
 577 |   case 0x004: 
 578 |   case 0x005: 
 579 |   case 0x006: 
 580 |   case 0x007: 
 581 |   case 0x008:
 582 |     for (y=0; y<bmpinfo.h; y++) {
 583 |       bmp_pad_reset();
 584 |       bitbuf = 0;  /* bit buffer: bits in buffer are high-aligned */
 585 |       n = 0;       /* number of bits currently in bitbuffer */
 586 |       for (x=0; x<bmpinfo.w; x++) {
 587 | 	if (n < bmpinfo.bits) {
 588 | 	  TRY_EOF(bmp_readint(f, 1, &b));
 589 | 	  bitbuf |= b << (INTBITS - 8 - n);
 590 | 	  n += 8;
 591 | 	}
 592 | 	b = bitbuf >> (INTBITS - bmpinfo.bits);
 593 | 	bitbuf <<= bmpinfo.bits;
 594 | 	n -= bmpinfo.bits;
 595 | 	BM_UPUT(bm, x, ycorr(y), coltable[b]);
 596 |       }
 597 |       TRY(bmp_pad(f));
 598 |     }
 599 |     break;
 600 | 
 601 |   case 0x010:  /* 16-bit encoding */
 602 |     /* can't do this format because it is not well-documented and I
 603 |        don't have any samples */
 604 |     bm_read_error = "cannot handle bmp 16-bit coding";
 605 |     goto format_error;
 606 |     break;
 607 | 
 608 |   case 0x018:  /* 24-bit encoding */
 609 |   case 0x020:  /* 32-bit encoding */
 610 |     for (y=0; y<bmpinfo.h; y++) {
 611 |       bmp_pad_reset();
 612 |       for (x=0; x<bmpinfo.w; x++) {
 613 |         TRY_EOF(bmp_readint(f, bmpinfo.bits/8, &c));
 614 | 	c = ((c>>16) & 0xff) + ((c>>8) & 0xff) + (c & 0xff);
 615 |         BM_UPUT(bm, x, ycorr(y), c > 3 * threshold * 255 ? 0 : 1);
 616 |       }
 617 |       TRY(bmp_pad(f));
 618 |     }
 619 |     break;
 620 | 
 621 |   case 0x320:  /* 32-bit encoding with bitfields */
 622 |     redshift = lobit(bmpinfo.RedMask);
 623 |     greenshift = lobit(bmpinfo.GreenMask);
 624 |     blueshift = lobit(bmpinfo.BlueMask);
 625 | 
 626 |     for (y=0; y<bmpinfo.h; y++) {
 627 |       bmp_pad_reset();
 628 |       for (x=0; x<bmpinfo.w; x++) {
 629 |         TRY_EOF(bmp_readint(f, bmpinfo.bits/8, &c));
 630 | 	c = ((c & bmpinfo.RedMask) >> redshift) + ((c & bmpinfo.GreenMask) >> greenshift) + ((c & bmpinfo.BlueMask) >> blueshift);
 631 |         BM_UPUT(bm, x, ycorr(y), c > 3 * threshold * 255 ? 0 : 1);
 632 |       }
 633 |       TRY(bmp_pad(f));
 634 |     }
 635 |     break;
 636 | 
 637 |   case 0x204:  /* 4-bit runlength compressed encoding (RLE4) */
 638 |     x = 0;
 639 |     y = 0;
 640 |     while (1) {
 641 |       TRY_EOF(bmp_readint(f, 1, &b)); /* opcode */
 642 |       TRY_EOF(bmp_readint(f, 1, &c)); /* argument */
 643 |       if (b>0) {
 644 | 	/* repeat count */
 645 | 	col[0] = coltable[(c>>4) & 0xf];
 646 | 	col[1] = coltable[c & 0xf];
 647 | 	for (i=0; i<b && x<bmpinfo.w; i++) {
 648 | 	  if (x>=bmpinfo.w) {
 649 | 	    x=0;
 650 | 	    y++;
 651 | 	  }
 652 | 	  if (y>=bmpinfo.h) {
 653 | 	    break;
 654 | 	  }
 655 | 	  BM_UPUT(bm, x, ycorr(y), col[i&1]);
 656 | 	  x++;
 657 | 	}
 658 |       } else if (c == 0) {
 659 | 	/* end of line */
 660 | 	y++;
 661 | 	x = 0;
 662 |       } else if (c == 1) {
 663 | 	/* end of bitmap */
 664 | 	break;
 665 |       } else if (c == 2) {
 666 | 	/* "delta": skip pixels in x and y directions */
 667 | 	TRY_EOF(bmp_readint(f, 1, &b)); /* x offset */
 668 | 	TRY_EOF(bmp_readint(f, 1, &c)); /* y offset */
 669 | 	x += b;
 670 | 	y += c;
 671 |       } else {
 672 | 	/* verbatim segment */
 673 | 	for (i=0; i<c; i++) {
 674 | 	  if ((i&1)==0) {
 675 | 	    TRY_EOF(bmp_readint(f, 1, &b));
 676 | 	  }
 677 | 	  if (x>=bmpinfo.w) {
 678 | 	    x=0;
 679 | 	    y++;
 680 | 	  }
 681 | 	  if (y>=bmpinfo.h) {
 682 | 	    break;
 683 | 	  }
 684 | 	  BM_PUT(bm, x, ycorr(y), coltable[(b>>(4-4*(i&1))) & 0xf]);
 685 | 	  x++;
 686 | 	}
 687 | 	if ((c+1) & 2) {
 688 | 	  /* pad to 16-bit boundary */
 689 | 	  TRY_EOF(bmp_readint(f, 1, &b));
 690 | 	}
 691 |       }
 692 |     }
 693 |     break;
 694 | 
 695 |   case 0x108:  /* 8-bit runlength compressed encoding (RLE8) */
 696 |     x = 0;
 697 |     y = 0;
 698 |     while (1) {
 699 |       TRY_EOF(bmp_readint(f, 1, &b)); /* opcode */
 700 |       TRY_EOF(bmp_readint(f, 1, &c)); /* argument */
 701 |       if (b>0) {
 702 | 	/* repeat count */
 703 | 	for (i=0; i<b; i++) {
 704 | 	  if (x>=bmpinfo.w) {
 705 | 	    x=0;
 706 | 	    y++;
 707 | 	  }
 708 | 	  if (y>=bmpinfo.h) {
 709 | 	    break;
 710 | 	  }
 711 | 	  BM_UPUT(bm, x, ycorr(y), coltable[c]);
 712 | 	  x++;
 713 | 	}
 714 |       } else if (c == 0) {
 715 | 	/* end of line */
 716 | 	y++;
 717 | 	x = 0;
 718 |       } else if (c == 1) {
 719 | 	/* end of bitmap */
 720 | 	break;
 721 |       } else if (c == 2) {
 722 | 	/* "delta": skip pixels in x and y directions */
 723 | 	TRY_EOF(bmp_readint(f, 1, &b)); /* x offset */
 724 | 	TRY_EOF(bmp_readint(f, 1, &c)); /* y offset */
 725 | 	x += b;
 726 | 	y += c;
 727 |       } else {
 728 | 	/* verbatim segment */
 729 | 	for (i=0; i<c; i++) {
 730 | 	  TRY_EOF(bmp_readint(f, 1, &b));
 731 |           if (x>=bmpinfo.w) {
 732 |             x=0;
 733 |             y++;
 734 |           }
 735 |           if (y>=bmpinfo.h) {
 736 |             break;
 737 |           }
 738 | 	  BM_PUT(bm, x, ycorr(y), coltable[b]);
 739 | 	  x++;
 740 | 	}
 741 | 	if (c & 1) {
 742 | 	  /* pad input to 16-bit boundary */
 743 | 	  TRY_EOF(bmp_readint(f, 1, &b));
 744 | 	}
 745 |       }
 746 |     }
 747 |     break;
 748 | 
 749 |   } /* switch */
 750 | 
 751 |   /* skip any potential junk after the data section, but don't
 752 |      complain in case EOF is encountered */
 753 |   bmp_forward(f, bmpinfo.FileSize);
 754 | 
 755 |   free(coltable);
 756 |   *bmp = bm;
 757 |   return 0;
 758 | 
 759 |  eof:
 760 |   free(coltable);
 761 |   *bmp = bm;
 762 |   return 1;
 763 | 
 764 |  format_error:
 765 |  try_error:
 766 |   free(coltable);
 767 |   free(bm);
 768 |   if (!bm_read_error) {
 769 |     bm_read_error = "invalid bmp file";
 770 |   }
 771 |   return -2;
 772 | 
 773 |  std_error:
 774 |   free(coltable);
 775 |   free(bm);
 776 |   return -1;
 777 | }
 778 | 
