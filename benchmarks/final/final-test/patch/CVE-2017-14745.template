6669 | static long
6670 | elf_x86_64_get_synthetic_symtab (bfd *abfd,
6671 | 				 long symcount ATTRIBUTE_UNUSED,
6672 | 				 asymbol **syms ATTRIBUTE_UNUSED,
6673 | 				 long dynsymcount,
6674 | 				 asymbol **dynsyms,
6675 | 				 asymbol **ret)
6676 | {
6677 |   long size, count, i, n;
6678 |   int j;
6679 |   unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size;
6680 |   asymbol *s;
6681 |   bfd_byte *plt_contents;
6682 |   long dynrelcount, relsize;
6683 |   arelent **dynrelbuf;
6684 |   const struct elf_x86_64_lazy_plt_layout *lazy_plt;
6685 |   const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
6686 |   const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt;
6687 |   const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt;
6688 |   const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt;
6689 |   const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt;
6690 |   asection *plt;
6691 |   char *names;
6692 |   enum elf_x86_64_plt_type plt_type;
6693 |   struct elf_x86_64_plt plts[] =
6694 |     {
6695 |       { ".plt", NULL, NULL, plt_unknown, 0, 0, 0, 0 },
6696 |       { ".plt.got", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 },
6697 |       { ".plt.sec", NULL, NULL, plt_second, 0, 0, 0, 0 },
6698 |       { ".plt.bnd", NULL, NULL, plt_second, 0, 0, 0, 0 },
6699 |       { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }
6700 |     };
6701 | 
6702 |   *ret = NULL;
6703 | 
6704 |   if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
6705 |     return 0;
6706 | 
6707 |   if (dynsymcount <= 0)
6708 |     return 0;
6709 | 
6710 |   relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
6711 |   if (relsize <= 0)
6712 |     return -1;
6713 | 
6714 |   dynrelbuf = (arelent **) bfd_malloc (relsize);
6715 |   if (dynrelbuf == NULL)
6716 |     return -1;
6717 | 
6718 |   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
6719 | 						dynsyms);
6720 | 
6721 |   /* Sort the relocs by address.  */ // PATCH LOCATION
6722 |   qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
6723 | 
6724 |   if (get_elf_x86_64_backend_data (abfd)->os == is_normal)
6725 |     {
6726 |       lazy_plt = &elf_x86_64_lazy_plt;
6727 |       non_lazy_plt = &elf_x86_64_non_lazy_plt;
6728 |       lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt;
6729 |       non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt;
6730 |       if (ABI_64_P (abfd))
6731 | 	{
6732 | 	  lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt;
6733 | 	  non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt;
6734 | 	}
6735 |       else
6736 | 	{
6737 | 	  lazy_ibt_plt = &elf_x32_lazy_ibt_plt;
6738 | 	  non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;
6739 | 	}
6740 |     }
6741 |   else
6742 |     {
6743 |       lazy_plt = &elf_x86_64_nacl_plt;
6744 |       non_lazy_plt = NULL;
6745 |       lazy_bnd_plt = NULL;
6746 |       non_lazy_bnd_plt = NULL;
6747 |       lazy_ibt_plt = NULL;
6748 |       non_lazy_ibt_plt = NULL;
6749 |     }
6750 | 
6751 |   count = 0;
6752 |   for (j = 0; plts[j].name != NULL; j++)
6753 |     {
6754 |       plt = bfd_get_section_by_name (abfd, plts[j].name);
6755 |       if (plt == NULL || plt->size == 0)
6756 | 	continue;
6757 | 
6758 |       /* Get the PLT section contents.  */
6759 |       plt_contents = (bfd_byte *) bfd_malloc (plt->size);
6760 |       if (plt_contents == NULL)
6761 | 	break;
6762 |       if (!bfd_get_section_contents (abfd, (asection *) plt,
6763 | 				     plt_contents, 0, plt->size))
6764 | 	{
6765 | 	  free (plt_contents);
6766 | 	  break;
6767 | 	}
6768 | 
6769 |       /* Check what kind of PLT it is.  */
6770 |       plt_type = plt_unknown;
6771 |       if (plts[j].type == plt_unknown
6772 | 	  && (plt->size >= (lazy_plt->plt_entry_size
6773 | 			    + lazy_plt->plt_entry_size)))
6774 | 	{
6775 | 	  /* Match lazy PLT first.  Need to check the first two
6776 | 	     instructions.   */
6777 | 	  if ((memcmp (plt_contents, lazy_plt->plt0_entry,
6778 | 		       lazy_plt->plt0_got1_offset) == 0)
6779 | 	      && (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6,
6780 | 			  2) == 0))
6781 | 	    plt_type = plt_lazy;
6782 | 	  else if (lazy_bnd_plt != NULL
6783 | 		   && (memcmp (plt_contents, lazy_bnd_plt->plt0_entry,
6784 | 			       lazy_bnd_plt->plt0_got1_offset) == 0)
6785 | 		   && (memcmp (plt_contents + 6,
6786 | 			       lazy_bnd_plt->plt0_entry + 6, 3) == 0))
6787 | 	    {
6788 | 	      plt_type = plt_lazy | plt_second;
6789 | 	      /* The fist entry in the lazy IBT PLT is the same as the
6790 | 		 lazy BND PLT.  */
6791 | 	      if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,
6792 | 			   lazy_ibt_plt->plt_entry,
6793 | 			   lazy_ibt_plt->plt_got_offset) == 0))
6794 | 		lazy_plt = lazy_ibt_plt;
6795 | 	      else
6796 | 		lazy_plt = lazy_bnd_plt;
6797 | 	    }
6798 | 	}
6799 | 
6800 |       if (non_lazy_plt != NULL
6801 | 	  && (plt_type == plt_unknown || plt_type == plt_non_lazy)
6802 | 	  && plt->size >= non_lazy_plt->plt_entry_size)
6803 | 	{
6804 | 	  /* Match non-lazy PLT.  */
6805 | 	  if (memcmp (plt_contents, non_lazy_plt->plt_entry,
6806 | 		      non_lazy_plt->plt_got_offset) == 0)
6807 | 	    plt_type = plt_non_lazy;
6808 | 	}
6809 | 
6810 |       if (plt_type == plt_unknown || plt_type == plt_second)
6811 | 	{
6812 | 	  if (non_lazy_bnd_plt != NULL
6813 | 	      && plt->size >= non_lazy_bnd_plt->plt_entry_size
6814 | 	      && (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry,
6815 | 			  non_lazy_bnd_plt->plt_got_offset) == 0))
6816 | 	    {
6817 | 	      /* Match BND PLT.  */
6818 | 	      plt_type = plt_second;
6819 | 	      non_lazy_plt = non_lazy_bnd_plt;
6820 | 	    }
6821 | 	  else if (non_lazy_ibt_plt != NULL
6822 | 		   && plt->size >= non_lazy_ibt_plt->plt_entry_size
6823 | 		   && (memcmp (plt_contents,
6824 | 			       non_lazy_ibt_plt->plt_entry,
6825 | 			       non_lazy_ibt_plt->plt_got_offset) == 0))
6826 | 	    {
6827 | 	      /* Match IBT PLT.  */
6828 | 	      plt_type = plt_second;
6829 | 	      non_lazy_plt = non_lazy_ibt_plt;
6830 | 	    }
6831 | 	}
6832 | 
6833 |       if (plt_type == plt_unknown)
6834 | 	continue;
6835 | 
6836 |       plts[j].sec = plt;
6837 |       plts[j].type = plt_type;
6838 | 
6839 |       if ((plt_type & plt_lazy))
6840 | 	{
6841 | 	  plts[j].plt_got_offset = lazy_plt->plt_got_offset;
6842 | 	  plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size;
6843 | 	  plts[j].plt_entry_size = lazy_plt->plt_entry_size;
6844 | 	  /* Skip PLT0 in lazy PLT.  */
6845 | 	  i = 1;
6846 | 	}
6847 |       else
6848 | 	{
6849 | 	  plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
6850 | 	  plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size;
6851 | 	  plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
6852 | 	  i = 0;
6853 | 	}
6854 | 
6855 |       /* Skip lazy PLT when the second PLT is used.  */
6856 |       if (plt_type == (plt_lazy | plt_second))
6857 | 	plts[j].count = 0;
6858 |       else
6859 | 	{
6860 | 	  n = plt->size / plts[j].plt_entry_size;
6861 | 	  plts[j].count = n;
6862 | 	  count += n - i;
6863 | 	}
6864 | 
6865 |       plts[j].contents = plt_contents;
6866 |     }
6867 | 
6868 |   if (count == 0)
6869 |     return -1;
6870 | 
6871 |   size = count * sizeof (asymbol);
6872 |   s = *ret = (asymbol *) bfd_zmalloc (size);
6873 |   if (s == NULL)
6874 |     {
6875 | bad_return:
6876 |       for (j = 0; plts[j].name != NULL; j++)
6877 | 	if (plts[j].contents != NULL)
6878 | 	  free (plts[j].contents);
6879 |       free (dynrelbuf);
6880 |       return -1;
6881 |     }
6882 | 
6883 |   /* Check for each PLT section.  */
6884 |   size = 0;
6885 |   n = 0;
6886 |   for (j = 0; plts[j].name != NULL; j++)
6887 |     if ((plt_contents = plts[j].contents) != NULL)
6888 |       {
6889 | 	long k;
6890 | 	bfd_vma offset;
6891 | 
6892 | 	plt_got_offset = plts[j].plt_got_offset;
6893 | 	plt_got_insn_size = plts[j].plt_got_insn_size;
6894 | 	plt_entry_size = plts[j].plt_entry_size;
6895 | 
6896 | 	plt = plts[j].sec;
6897 | 
6898 | 	if ((plts[j].type & plt_lazy))
6899 | 	  {
6900 | 	    /* Skip PLT0 in lazy PLT.  */
6901 | 	    k = 1;
6902 | 	    offset = plt_entry_size;
6903 | 	  }
6904 | 	else
6905 | 	  {
6906 | 	    k = 0;
6907 | 	    offset = 0;
6908 | 	  }
6909 | 
6910 | 	/* Check each PLT entry against dynamic relocations.  */
6911 | 	for (; k < plts[j].count; k++)
6912 | 	  {
6913 | 	    int off;
6914 | 	    bfd_vma got_vma;
6915 | 	    long min, max, mid;
6916 | 	    arelent *p;
6917 | 
6918 | 	    /* Get the PC-relative offset, a signed 32-bit integer.  */
6919 | 	    off = H_GET_32 (abfd, (plt_contents + offset
6920 | 				   + plt_got_offset));
6921 | 	    got_vma = plt->vma + offset + off + plt_got_insn_size;
6922 | 
6923 | 	    /* Binary search.  */
6924 | 	    p = dynrelbuf[0];
6925 | 	    min = 0;
6926 | 	    max = dynrelcount;
6927 | 	    while ((min + 1) < max)
6928 | 	      {
6929 | 		arelent *r;
6930 | 
6931 | 		mid = (min + max) / 2;
6932 | 		r = dynrelbuf[mid];
6933 | 		if (got_vma > r->address)
6934 | 		  min = mid;
6935 | 		else if (got_vma < r->address)
6936 | 		  max = mid;
6937 | 		else
6938 | 		  {
6939 | 		    p = r;
6940 | 		    break;
6941 | 		  }
6942 | 	      }
6943 | 
6944 | 	    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */
6945 | 	    if (got_vma == p->address
6946 | 		&& p->howto != NULL
6947 | 		&& (p->howto->type == R_X86_64_JUMP_SLOT
6948 | 		    || p->howto->type == R_X86_64_GLOB_DAT
6949 | 		    || p->howto->type == R_X86_64_IRELATIVE))
6950 | 	      {
6951 | 		*s = **p->sym_ptr_ptr;
6952 | 		/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL
6953 | 		   set.  Since we are defining a symbol, ensure one
6954 | 		   of them is set.  */
6955 | 		if ((s->flags & BSF_LOCAL) == 0)
6956 | 		  s->flags |= BSF_GLOBAL;
6957 | 		s->flags |= BSF_SYNTHETIC;
6958 | 		/* This is no longer a section symbol.  */
6959 | 		s->flags &= ~BSF_SECTION_SYM;
6960 | 		s->section = plt;
6961 | 		s->the_bfd = plt->owner;
6962 | 		s->value = offset;
6963 | 		/* Store relocation for later use.  */
6964 | 		s->udata.p = p;
6965 | 		/* Add @plt to function name later.  */
6966 | 		size += strlen (s->name) + sizeof ("@plt");
6967 | 		if (p->addend != 0)
6968 | 		  size += sizeof ("+0x") - 1 + 8 + 8 * ABI_64_P (abfd);
6969 | 		n++;
6970 | 		s++;
6971 | 	      }
6972 | 	    offset += plt_entry_size;
6973 | 	  }
6974 |       }
6975 | 
6976 |   /* PLT entries with R_X86_64_TLSDESC relocations are skipped.  */
6977 |   if (n == 0)
6978 |     goto bad_return;
6979 | 
6980 |   count = n;
6981 | 
6982 |   /* Allocate space for @plt suffixes.  */
6983 |   names = (char *) bfd_malloc (size);
6984 |   if (s == NULL)
6985 |     goto bad_return;
6986 | 
6987 |   s = *ret;
6988 |   for (i = 0; i < count; i++)
6989 |     {
6990 |       /* Add @plt to function name.  */
6991 |       arelent *p = (arelent *) s->udata.p;
6992 |       /* Clear it now.  */
6993 |       s->udata.p = NULL;
6994 |       size = strlen (s->name);
6995 |       memcpy (names, s->name, size);
6996 |       s->name = names;
6997 |       names += size;
6998 |       if (p->addend != 0)
6999 | 	{
7000 | 	  char buf[30], *a;
7001 | 
7002 | 	  memcpy (names, "+0x", sizeof ("+0x") - 1);
7003 | 	  names += sizeof ("+0x") - 1;
7004 | 	  bfd_sprintf_vma (abfd, buf, p->addend);
7005 | 	  for (a = buf; *a == '0'; ++a)
7006 | 	    ;
7007 | 	  size = strlen (a);
7008 | 	  memcpy (names, a, size);
7009 | 	  names += size;
7010 | 	}
7011 |       memcpy (names, "@plt", sizeof ("@plt"));
7012 |       names += sizeof ("@plt");
7013 |       s++;
7014 |     }
7015 | 
7016 |   for (j = 0; plts[j].name != NULL; j++)
7017 |     if (plts[j].contents != NULL)
7018 |       free (plts[j].contents);
7019 | 
7020 |   free (dynrelbuf);
7021 | 
7022 |   return count;
7023 | }
