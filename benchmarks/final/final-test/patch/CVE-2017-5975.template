 160 |  * creates a new item parsing the information out of the various places
 161 |  * in the zip archive. This is a good place to extend functionality if
 162 |  * you have a project with extra requirements as you can push more bits
 163 |  * right into the diskdir_entry for later usage in higher layers.
 164 |  * returns: new item, or null on error (setting errno =  ENOMEM|EBADMSG)
 165 |  */
 166 | zzip__new__ ZZIP_MEM_ENTRY *
 167 | zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
 168 | {
 169 |     if (! disk || ! entry)
 170 |         { errno=EINVAL; return 0; }
 171 |     ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
 172 |     if (! item)
 173 |         return 0;               /* errno=ENOMEM; */
 174 |     ___ struct zzip_file_header *header =
 175 |         zzip_disk_entry_to_file_header(disk, entry);
 176 |     /*  there is a number of duplicated information in the file header
 177 |      *  or the disk entry block. Theoretically some part may be missing
 178 |      *  that exists in the other, ... but we will prefer the disk entry.
 179 |      */
 180 |     item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry); // PATCH LOCATION
 181 |     item->zz_name = zzip_disk_entry_strdup_name(disk, entry); if (<PATCH>) return 0;
 182 |     item->zz_data = zzip_file_header_to_data(header);
 183 |     item->zz_flags = zzip_disk_entry_get_flags(entry);
 184 |     item->zz_compr = zzip_disk_entry_get_compr(entry);
 185 |     item->zz_mktime = zzip_disk_entry_get_mktime(entry);
 186 |     item->zz_crc32 = zzip_disk_entry_get_crc32(entry);
 187 |     item->zz_csize = zzip_disk_entry_get_csize(entry);
 188 |     item->zz_usize = zzip_disk_entry_get_usize(entry);
 189 |     item->zz_diskstart = zzip_disk_entry_get_diskstart(entry);
 190 |     item->zz_filetype = zzip_disk_entry_get_filetype(entry);
 191 | 
 192 |     {   /* copy the extra blocks to memory as well (maximum 64K each) */
 193 |         zzip_size_t /*    */ ext1_len = zzip_disk_entry_get_extras(entry);
 194 |         char *_zzip_restrict ext1_ptr = zzip_disk_entry_to_extras(entry);
 195 |         zzip_size_t /*    */ ext2_len = zzip_file_header_get_extras(header);
 196 |         char *_zzip_restrict ext2_ptr = zzip_file_header_to_extras(header);
 197 | 
 198 |         if (ext1_ptr + ext1_len >= disk->endbuf ||
 199 |             ext2_ptr + ext2_len >= disk->endbuf)
 200 |         {
 201 |             errno = EBADMSG; /* format error CVE-2017-5978 */
 202 |             goto error; /* zzip_mem_entry_free(item); return 0; */
 203 |         }
 204 | 
 205 |         if (ext1_len)
 206 |         {
 207 |             void *mem = malloc(ext1_len);
 208 |             if (! mem) goto error; /* errno = ENOMEM */
 209 |             item->zz_ext[1] = mem;
 210 |             item->zz_extlen[1] = ext1_len;
 211 |             memcpy(mem, ext1_ptr, ext1_len);
 212 |         }
 213 |         if (ext2_len)
 214 |         {
 215 |             void *mem = malloc(ext2_len);
 216 |             if (! mem) goto error; /* errno = ENOMEM */
 217 |             item->zz_ext[2] = mem;
 218 |             item->zz_extlen[2] = ext2_len;
 219 |             memcpy(mem, ext2_ptr, ext2_len);
 220 |         }
 221 |     }
 222 |     {
 223 |         /* override sizes/offsets with zip64 values for largefile support */
 224 |         zzip_extra_zip64 *block = (zzip_extra_zip64 *)
 225 |             zzip_mem_entry_extra_block(item, ZZIP_EXTRA_zip64);
 226 |         if (block)
 227 |         {
 228 |             item->zz_usize = ZZIP_GET64(block->z_usize);
 229 |             item->zz_csize = ZZIP_GET64(block->z_csize);
 230 |             item->zz_offset = ZZIP_GET64(block->z_offset);
 231 |             item->zz_diskstart = ZZIP_GET32(block->z_diskstart);
 232 |         }
 233 |     }
 234 |     /* NOTE:
 235 |      * All information from the central directory entry is now in memory.
 236 |      * Effectivly that allows us to modify it and write it back to disk.
 237 |      */
 238 |     return item;
 239 |     ____;
 240 | error:
 241 |     zzip_mem_entry_free(item);
 242 |     return 0;
 243 |     ____;
 244 | }
 245 | 
 246 | /* find an extra block for the given datatype code.
