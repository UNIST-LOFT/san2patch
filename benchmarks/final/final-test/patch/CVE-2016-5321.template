 951 | static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, 
 952 | 					 uint32 imagelength, uint32 imagewidth, 
 953 |                                          uint32 tw, uint32 tl,
 954 |                                          uint16 spp, uint16 bps)
 955 |   {
 956 |   int     i, status = 1, sample;
 957 |   int     shift_width, bytes_per_pixel;
 958 |   uint16  bytes_per_sample;
 959 |   uint32  row, col;     /* Current row and col of image */
 960 |   uint32  nrow, ncol;   /* Number of rows and cols in current tile */
 961 |   uint32  row_offset, col_offset; /* Output buffer offsets */
 962 |   tsize_t tbytes = 0, tilesize = TIFFTileSize(in);
 963 |   tsample_t s;
 964 |   uint8*  bufp = (uint8*)obuf;
 965 |   unsigned char *srcbuffs[MAX_SAMPLES];
 966 |   unsigned char *tbuff = NULL;
 967 | 
 968 |   bytes_per_sample = (bps + 7) / 8;
 969 | 
 970 |   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
 971 |     {
 972 |     srcbuffs[sample] = NULL;
 973 |     tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);
 974 |     if (!tbuff)
 975 |       {
 976 |       TIFFError ("readSeparateTilesIntoBuffer", 
 977 |                  "Unable to allocate tile read buffer for sample %d", sample);
 978 |       for (i = 0; i < sample; i++)
 979 |         _TIFFfree (srcbuffs[i]);
 980 |       return 0;
 981 |       }
 982 |     srcbuffs[sample] = tbuff;
 983 |     } 
 984 |   /* Each tile contains only the data for a single plane
 985 |    * arranged in scanlines of tw * bytes_per_sample bytes.
 986 |    */
 987 |   for (row = 0; row < imagelength; row += tl)
 988 |     {
 989 |     nrow = (row + tl > imagelength) ? imagelength - row : tl;
 990 |     for (col = 0; col < imagewidth; col += tw)
 991 |       { // PATCH LOCATION 992 |       for (s = 0; s < spp; s++)
 993 |         {  /* Read each plane of a tile set into srcbuffs[s] */
 994 | 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
 995 |         if (tbytes < 0  && !ignore)
 996 |           {
 997 | 	  TIFFError(TIFFFileName(in),
 998 |                  "Error, can't read tile for row %lu col %lu, "
 999 | 		 "sample %lu",
1000 | 		 (unsigned long) col, (unsigned long) row,
1001 | 		 (unsigned long) s);
1002 | 		 status = 0;
1003 |           for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
1004 |             {
1005 |             tbuff = srcbuffs[sample];
1006 |             if (tbuff != NULL)
1007 |               _TIFFfree(tbuff);
1008 |             }
1009 |           return status;
1010 | 	  }
1011 | 	}
1012 |      /* Tiles on the right edge may be padded out to tw 
1013 |       * which must be a multiple of 16.
1014 |       * Ncol represents the visible (non padding) portion.  
1015 |       */
1016 |       if (col + tw > imagewidth)
1017 |         ncol = imagewidth - col;
1018 |       else
1019 |         ncol = tw;
1020 | 
1021 |       row_offset = row * (((imagewidth * spp * bps) + 7) / 8);
1022 |       col_offset = ((col * spp * bps) + 7) / 8;
1023 |       bufp = obuf + row_offset + col_offset;
1024 | 
1025 |       if ((bps % 8) == 0)
1026 |         {
1027 |         if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,
1028 | 					    tw, spp, bps, NULL, 0, 0))
1029 | 	  {
1030 |           status = 0;
1031 |           break;
1032 |       	  }
1033 | 	}
1034 |       else
1035 |         {
1036 |         bytes_per_pixel  = ((bps * spp) + 7) / 8;
1037 |         if (bytes_per_pixel < (bytes_per_sample + 1))
1038 |           shift_width = bytes_per_pixel;
1039 |         else
1040 |           shift_width = bytes_per_sample + 1;
1041 | 
1042 |         switch (shift_width)
1043 |           {
1044 |           case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,
1045 |                                                        imagewidth, tw, spp, bps, 
1046 | 						       NULL, 0, 0))
1047 | 	            {
1048 |                     status = 0;
1049 |                     break;
1050 |       	            }
1051 | 	          break;
1052 |           case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,
1053 |                                                        imagewidth, tw, spp, bps, 
1054 | 						       NULL, 0, 0))
1055 | 	            {
1056 |                     status = 0;
1057 |                     break;
1058 | 		    }
1059 | 	          break;
1060 |           case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,
1061 |                                                        imagewidth, tw, spp, bps, 
1062 | 						       NULL, 0, 0))
1063 | 	            {
1064 |                     status = 0;
1065 |                     break;
1066 |        	            }
1067 |                   break;
1068 |           case 4: 
1069 |           case 5:
1070 |           case 6:
1071 |           case 7:
1072 |           case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,
1073 |                                                        imagewidth, tw, spp, bps, 
1074 | 						       NULL, 0, 0))
1075 | 	            {
1076 |                     status = 0;
1077 |                     break;
1078 | 		    }
1079 | 	          break;
1080 |           default: TIFFError ("readSeparateTilesIntoBuffer", "Unsupported bit depth: %d", bps);
1081 |                   status = 0;
1082 |                   break;
1083 |           }
1084 |         }
1085 |       }
1086 |     }
1087 | 
1088 |   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
1089 |     {
1090 |     tbuff = srcbuffs[sample];
1091 |     if (tbuff != NULL)
1092 |       _TIFFfree(tbuff);
1093 |     }
1094 |  
1095 |   return status;
1096 |   }
