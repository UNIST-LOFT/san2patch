3881 | /**
3882 |  * xmlParseAttValueComplex:
3883 |  * @ctxt:  an XML parser context
3884 |  * @len:   the resulting attribute len
3885 |  * @normalize:  wether to apply the inner normalization
3886 |  *
3887 |  * parse a value for an attribute, this is the fallback function
3888 |  * of xmlParseAttValue() when the attribute parsing requires handling
3889 |  * of non-ASCII characters, or normalization compaction.
3890 |  *
3891 |  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
3892 |  */
3893 | static xmlChar *
3894 | xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
3895 |     xmlChar limit = 0;
3896 |     xmlChar *buf = NULL;
3897 |     xmlChar *rep = NULL;
3898 |     size_t len = 0;
3899 |     size_t buf_size = 0;
3900 |     int c, l, in_space = 0;
3901 |     xmlChar *current = NULL;
3902 |     xmlEntityPtr ent;
3903 | 
3904 |     if (NXT(0) == '"') {
3905 | 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
3906 | 	limit = '"';
3907 |         NEXT;
3908 |     } else if (NXT(0) == '\'') {
3909 | 	limit = '\'';
3910 | 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
3911 |         NEXT;
3912 |     } else {
3913 | 	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
3914 | 	return(NULL);
3915 |     }
3916 | 
3917 |     /*
3918 |      * allocate a translation buffer.
3919 |      */
3920 |     buf_size = XML_PARSER_BUFFER_SIZE;
3921 |     buf = (xmlChar *) xmlMallocAtomic(buf_size);
3922 |     if (buf == NULL) goto mem_error;
3923 | 
3924 |     /*
3925 |      * OK loop until we reach one of the ending char or a size limit.
3926 |      */
3927 |     c = CUR_CHAR(l);
3928 |     while (((NXT(0) != limit) && /* checked */
3929 |             (IS_CHAR(c)) && (c != '<')) &&
3930 |             (ctxt->instate != XML_PARSER_EOF)) {
3931 |         /*
3932 |          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE
3933 |          * special option is given
3934 |          */
3935 |         if ((len > XML_MAX_TEXT_LENGTH) &&
3936 |             ((ctxt->options & XML_PARSE_HUGE) == 0)) {
3937 |             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
3938 |                            "AttValue lenght too long\n");
3939 |             goto mem_error;
3940 |         }
3941 | 	if (c == 0) break;
3942 | 	if (c == '&') {
3943 | 	    in_space = 0;
3944 | 	    if (NXT(1) == '#') {
3945 | 		int val = xmlParseCharRef(ctxt);
3946 | 
3947 | 		if (val == '&') {
3948 | 		    if (ctxt->replaceEntities) {
3949 | 			if (len + 10 > buf_size) {
3950 | 			    growBuffer(buf, 10);
3951 | 			}
3952 | 			buf[len++] = '&';
3953 | 		    } else {
3954 | 			/*
3955 | 			 * The reparsing will be done in xmlStringGetNodeList()
3956 | 			 * called by the attribute() function in SAX.c
3957 | 			 */
3958 | 			if (len + 10 > buf_size) {
3959 | 			    growBuffer(buf, 10);
3960 | 			}
3961 | 			buf[len++] = '&';
3962 | 			buf[len++] = '#';
3963 | 			buf[len++] = '3';
3964 | 			buf[len++] = '8';
3965 | 			buf[len++] = ';';
3966 | 		    }
3967 | 		} else if (val != 0) {
3968 | 		    if (len + 10 > buf_size) {
3969 | 			growBuffer(buf, 10);
3970 | 		    }
3971 | 		    len += xmlCopyChar(0, &buf[len], val);
3972 | 		}
3973 | 	    } else {
3974 | 		ent = xmlParseEntityRef(ctxt);
3975 | 		ctxt->nbentities++;
3976 | 		if (ent != NULL)
3977 | 		    ctxt->nbentities += ent->owner;
3978 | 		if ((ent != NULL) &&
3979 | 		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
3980 | 		    if (len + 10 > buf_size) {
3981 | 			growBuffer(buf, 10);
3982 | 		    }
3983 | 		    if ((ctxt->replaceEntities == 0) &&
3984 | 		        (ent->content[0] == '&')) {
3985 | 			buf[len++] = '&';
3986 | 			buf[len++] = '#';
3987 | 			buf[len++] = '3';
3988 | 			buf[len++] = '8';
3989 | 			buf[len++] = ';';
3990 | 		    } else {
3991 | 			buf[len++] = ent->content[0];
3992 | 		    }
3993 | 		} else if ((ent != NULL) &&
3994 | 		           (ctxt->replaceEntities != 0)) {
3995 | 		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
3996 | 			rep = xmlStringDecodeEntities(ctxt, ent->content,
3997 | 						      XML_SUBSTITUTE_REF,
3998 | 						      0, 0, 0);
3999 | 			if (rep != NULL) {
4000 | 			    current = rep;
4001 | 			    while (*current != 0) { /* non input consuming */
4002 |                                 if ((*current == 0xD) || (*current == 0xA) ||
4003 |                                     (*current == 0x9)) {
4004 |                                     buf[len++] = 0x20;
4005 |                                     current++;
4006 |                                 } else
4007 |                                     buf[len++] = *current++;
4008 | 				if (len + 10 > buf_size) {
4009 | 				    growBuffer(buf, 10);
4010 | 				}
4011 | 			    }
4012 | 			    xmlFree(rep);
4013 | 			    rep = NULL;
4014 | 			}
4015 | 		    } else {
4016 | 			if (len + 10 > buf_size) {
4017 | 			    growBuffer(buf, 10);
4018 | 			}
4019 | 			if (ent->content != NULL)
4020 | 			    buf[len++] = ent->content[0];
4021 | 		    }
4022 | 		} else if (ent != NULL) {
4023 | 		    int i = xmlStrlen(ent->name);
4024 | 		    const xmlChar *cur = ent->name;
4025 | 
4026 | 		    /*
4027 | 		     * This may look absurd but is needed to detect
4028 | 		     * entities problems
4029 | 		     */
4030 | 		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
4031 | 			(ent->content != NULL)) {
4032 | 			rep = xmlStringDecodeEntities(ctxt, ent->content,
4033 | 						  XML_SUBSTITUTE_REF, 0, 0, 0);
4034 | 			if (rep != NULL) {
4035 | 			    xmlFree(rep);
4036 | 			    rep = NULL;
4037 | 			}
4038 | 		    }
4039 | 
4040 | 		    /*
4041 | 		     * Just output the reference
4042 | 		     */
4043 | 		    buf[len++] = '&';
4044 | 		    while (len + i + 10 > buf_size) {
4045 | 			growBuffer(buf, i + 10);
4046 | 		    }
4047 | 		    for (;i > 0;i--)
4048 | 			buf[len++] = *cur++;
4049 | 		    buf[len++] = ';';
4050 | 		}
4051 | 	    }
4052 | 	} else {
4053 | 	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
4054 | 	        if ((len != 0) || (!normalize)) {
4055 | 		    if ((!normalize) || (!in_space)) {
4056 | 			COPY_BUF(l,buf,len,0x20);
4057 | 			while (len + 10 > buf_size) {
4058 | 			    growBuffer(buf, 10);
4059 | 			}
4060 | 		    }
4061 | 		    in_space = 1;
4062 | 		}
4063 | 	    } else {
4064 | 	        in_space = 0;
4065 | 		COPY_BUF(l,buf,len,c);
4066 | 		if (len + 10 > buf_size) {
4067 | 		    growBuffer(buf, 10);
4068 | 		}
4069 | 	    }
4070 | 	    NEXTL(l);
4071 | 	}
4072 | 	GROW;
4073 | 	c = CUR_CHAR(l);
4074 |     }
4075 |     if (ctxt->instate == XML_PARSER_EOF)
4076 |         goto error;
4077 | 
4078 |     if ((in_space) && (normalize)) { // PATCH LOCATION4079 |         while (buf[len - 1] == 0x20) len--;
4080 |     }
4081 |     buf[len] = 0;
4082 |     if (RAW == '<') {
4083 | 	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
4084 |     } else if (RAW != limit) {
4085 | 	if ((c != 0) && (!IS_CHAR(c))) {
4086 | 	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
4087 | 			   "invalid character in attribute value\n");
4088 | 	} else {
4089 | 	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
4090 | 			   "AttValue: ' expected\n");
4091 |         }
4092 |     } else
4093 | 	NEXT;
4094 | 
4095 |     /*
4096 |      * There we potentially risk an overflow, don't allow attribute value of
4097 |      * lenght more than INT_MAX it is a very reasonnable assumption !
4098 |      */
4099 |     if (len >= INT_MAX) {
4100 |         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
4101 |                        "AttValue lenght too long\n");
4102 |         goto mem_error;
4103 |     }
4104 | 
4105 |     if (attlen != NULL) *attlen = (int) len;
4106 |     return(buf);
4107 | 
4108 | mem_error:
4109 |     xmlErrMemory(ctxt, NULL);
4110 | error:
4111 |     if (buf != NULL)
4112 |         xmlFree(buf);
4113 |     if (rep != NULL)
4114 |         xmlFree(rep);
4115 |     return(NULL);
4116 | }
