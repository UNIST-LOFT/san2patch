1140 | /* Abandon plans to modify code so that plannar orientation separate images
1141 |  * do not have all samples for each channel written before all samples
1142 |  * for the next channel have been abandoned.
1143 |  * Libtiff internals seem to depend on all data for a given sample
1144 |  * being contiguous within a strip or tile when PLANAR_CONFIG is 
1145 |  * separate. All strips or tiles of a given plane are written
1146 |  * before any strips or tiles of a different plane are stored.
1147 |  */
1148 | static int 
1149 | writeBufferToSeparateStrips (TIFF* out, uint8* buf, 
1150 | 			     uint32 length, uint32 width, uint16 spp,
1151 | 			     struct dump_opts *dump)
1152 |   {
1153 |   uint8   *src;
1154 |   uint16   bps;
1155 |   uint32   row, nrows, rowsize, rowsperstrip;
1156 |   uint32   bytes_per_sample;
1157 |   tsample_t s;
1158 |   tstrip_t strip = 0;
1159 |   tsize_t  stripsize = TIFFStripSize(out);
1160 |   tsize_t  rowstripsize,  scanlinesize = TIFFScanlineSize(out);
1161 |   tsize_t  total_bytes = 0;
1162 |   tdata_t  obuf;
1163 | 
1164 |   (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
1165 |   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
1166 |   bytes_per_sample = (bps + 7) / 8;
1167 |   rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */ if (<PATCH>) return 1; // PATCH LOCATION
1168 |   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
1169 | 
1170 |   obuf = _TIFFmalloc (rowstripsize);
1171 |   if (obuf == NULL)
1172 |     return 1;
1173 |   
1174 |   for (s = 0; s < spp; s++)
1175 |     {
1176 |     for (row = 0; row < length; row += rowsperstrip)
1177 |       {
1178 |       nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;
1179 | 
1180 |       stripsize = TIFFVStripSize(out, nrows);
1181 |       src = buf + (row * rowsize);
1182 |       total_bytes += stripsize;
1183 |       memset (obuf, '\0', rowstripsize);
1184 |       if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))
1185 |         {
1186 |         _TIFFfree(obuf);
1187 |         return 1;
1188 | 	}
1189 |       if ((dump->outfile != NULL) && (dump->level == 1))
1190 |         {
1191 |         dump_info(dump->outfile, dump->format,"", 
1192 |                   "Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d", 
1193 |                   s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);
1194 |         dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);
1195 | 	}
1196 | 
1197 |       if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)
1198 |         {
1199 | 	TIFFError(TIFFFileName(out), "Error, can't write strip %u", strip - 1);
1200 | 	_TIFFfree(obuf);
1201 | 	return 1;
1202 | 	}
1203 |       }
1204 |     }      
1205 | 
1206 |   _TIFFfree(obuf);
1207 |   return 0;
1208 | }
