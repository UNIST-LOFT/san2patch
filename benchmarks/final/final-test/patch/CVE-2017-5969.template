1149 | #ifdef LIBXML_OUTPUT_ENABLED
1150 | /**
1151 |  * xmlDumpElementContent:
1152 |  * @buf:  An XML buffer
1153 |  * @content:  An element table
1154 |  * @glob: 1 if one must print the englobing parenthesis, 0 otherwise
1155 |  *
1156 |  * This will dump the content of the element table as an XML DTD definition
1157 |  */
1158 | static void
1159 | xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {
1160 |     if (content == NULL) return;
1161 | 
1162 |     if (glob) xmlBufferWriteChar(buf, "(");
1163 |     switch (content->type) {
1164 |         case XML_ELEMENT_CONTENT_PCDATA:
1165 |             xmlBufferWriteChar(buf, "#PCDATA");
1166 | 	    break;
1167 | 	case XML_ELEMENT_CONTENT_ELEMENT:
1168 | 	    if (content->prefix != NULL) {
1169 | 		xmlBufferWriteCHAR(buf, content->prefix);
1170 | 		xmlBufferWriteChar(buf, ":");
1171 | 	    }
1172 | 	    xmlBufferWriteCHAR(buf, content->name);
1173 | 	    break;
1174 | 	case XML_ELEMENT_CONTENT_SEQ:
1175 | 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
1176 | 	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
1177 | 		xmlDumpElementContent(buf, content->c1, 1);
1178 | 	    else
1179 | 		xmlDumpElementContent(buf, content->c1, 0); // PATCH LOCATION
1180 |             xmlBufferWriteChar(buf, " , ");
1181 | 	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
1182 | 	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
1183 | 		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
1184 | 		xmlDumpElementContent(buf, content->c2, 1);
1185 | 	    else
1186 | 		xmlDumpElementContent(buf, content->c2, 0);
1187 | 	    break;
1188 | 	case XML_ELEMENT_CONTENT_OR:
1189 | 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
1190 | 	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
1191 | 		xmlDumpElementContent(buf, content->c1, 1);
1192 | 	    else
1193 | 		xmlDumpElementContent(buf, content->c1, 0);
1194 |             xmlBufferWriteChar(buf, " | ");
1195 | 	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
1196 | 	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
1197 | 		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
1198 | 		xmlDumpElementContent(buf, content->c2, 1);
1199 | 	    else
1200 | 		xmlDumpElementContent(buf, content->c2, 0);
1201 | 	    break;
1202 | 	default:
1203 | 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
1204 | 		    "Internal: ELEMENT content corrupted invalid type\n",
1205 | 		    NULL);
1206 |     }
1207 |     if (glob)
1208 |         xmlBufferWriteChar(buf, ")");
1209 |     switch (content->ocur) {
1210 |         case XML_ELEMENT_CONTENT_ONCE:
1211 | 	    break;
1212 |         case XML_ELEMENT_CONTENT_OPT:
1213 | 	    xmlBufferWriteChar(buf, "?");
1214 | 	    break;
1215 |         case XML_ELEMENT_CONTENT_MULT:
1216 | 	    xmlBufferWriteChar(buf, "*");
1217 | 	    break;
1218 |         case XML_ELEMENT_CONTENT_PLUS:
1219 | 	    xmlBufferWriteChar(buf, "+");
1220 | 	    break;
1221 |     }
1222 | }
