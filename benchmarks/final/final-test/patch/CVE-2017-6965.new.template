static bfd_boolean
target_specific_reloc_handling (Elf_Internal_Rela * reloc,
				unsigned char *     start,
				Elf_Internal_Sym *  symtab)
{
  unsigned int reloc_type = get_reloc_type (reloc->r_info);

  switch (elf_header.e_machine)
    {
    case EM_MSP430:
    case EM_MSP430_OLD:
      {
	static Elf_Internal_Sym * saved_sym = NULL;

	switch (reloc_type)
	  {
	  case 10: /* R_MSP430_SYM_DIFF */
	    if (uses_msp430x_relocs ())
	      break;
	    /* Fall through.  */
	  case 21: /* R_MSP430X_SYM_DIFF */
	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
	    return TRUE;

	  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
	  case 3: /* R_MSP430_16 or R_MSP430_ABS8 */
	    goto handle_sym_diff;

	  case 5: /* R_MSP430_16_BYTE */
	  case 9: /* R_MSP430_8 */
	    if (uses_msp430x_relocs ())
	      break;
	    goto handle_sym_diff;

	  case 2: /* R_MSP430_ABS16 */
	  case 15: /* R_MSP430X_ABS16 */
	    if (! uses_msp430x_relocs ())
	      break;
	    goto handle_sym_diff;

	  handle_sym_diff:
	    if (saved_sym != NULL)
	      {
		bfd_vma value;

		value = reloc->r_addend
		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
		     - saved_sym->st_value);
 
		if (<PATCH>) error(_("MN10300 sym diff reloc writes past end of section")); byte_put (start + reloc->r_offset, value, reloc_type == 1 ? 4 : 2);

		saved_sym = NULL;
		return TRUE;
	      }
	    break;

	  default:
	    if (saved_sym != NULL)
	      error (_("Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"));
	    break;
	  }
	break;
      }

    case EM_MN10300:
    case EM_CYGNUS_MN10300:
      {
	static Elf_Internal_Sym * saved_sym = NULL;

	switch (reloc_type)
	  {
	  case 34: /* R_MN10300_ALIGN */
	    return TRUE;
	  case 33: /* R_MN10300_SYM_DIFF */
	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
	    return TRUE;
	  case 1: /* R_MN10300_32 */
	  case 2: /* R_MN10300_16 */
	    if (saved_sym != NULL)
	      {
		bfd_vma value;

		value = reloc->r_addend
		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
		     - saved_sym->st_value);

		byte_put (start + reloc->r_offset, value, reloc_type == 1 ? 4 : 2);

		saved_sym = NULL;
		return TRUE;
	      }
	    break;
	  default:
	    if (saved_sym != NULL)
	      error (_("Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"));
	    break;
	  }
	break;
      }

    case EM_RL78:
      {
	static bfd_vma saved_sym1 = 0;
	static bfd_vma saved_sym2 = 0;
	static bfd_vma value;

	switch (reloc_type)
	  {
	  case 0x80: /* R_RL78_SYM.  */
	    saved_sym1 = saved_sym2;
	    saved_sym2 = symtab[get_reloc_symindex (reloc->r_info)].st_value;
	    saved_sym2 += reloc->r_addend;
	    return TRUE;

	  case 0x83: /* R_RL78_OPsub.  */
	    value = saved_sym1 - saved_sym2;
	    saved_sym2 = saved_sym1 = 0;
	    return TRUE;
	    break;

	  case 0x41: /* R_RL78_ABS32.  */
	    byte_put (start + reloc->r_offset, value, 4);
	    value = 0;
	    return TRUE;

	  case 0x43: /* R_RL78_ABS16.  */
	    byte_put (start + reloc->r_offset, value, 2);
	    value = 0;
	    return TRUE;

	  default:
	    break;
	  }
	break;
      }
    }

  return FALSE;
}
