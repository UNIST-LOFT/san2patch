2033 | static struct line_info_table*
2034 | decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
2035 | {
2036 |   bfd *abfd = unit->abfd;
2037 |   struct line_info_table* table;
2038 |   bfd_byte *line_ptr;
2039 |   bfd_byte *line_end;
2040 |   struct line_head lh;
2041 |   unsigned int i, bytes_read, offset_size;
2042 |   char *cur_file, *cur_dir;
2043 |   unsigned char op_code, extended_op, adj_opcode;
2044 |   unsigned int exop_len;
2045 |   bfd_size_type amt;
2046 | 
2047 |   if (! read_section (abfd, &stash->debug_sections[debug_line],
2048 | 		      stash->syms, unit->line_offset,
2049 | 		      &stash->dwarf_line_buffer, &stash->dwarf_line_size))
2050 |     return NULL;
2051 | 
2052 |   amt = sizeof (struct line_info_table);
2053 |   table = (struct line_info_table *) bfd_alloc (abfd, amt);
2054 |   if (table == NULL)
2055 |     return NULL;
2056 |   table->abfd = abfd;
2057 |   table->comp_dir = unit->comp_dir;
2058 | 
2059 |   table->num_files = 0;
2060 |   table->files = NULL;
2061 | 
2062 |   table->num_dirs = 0;
2063 |   table->dirs = NULL;
2064 | 
2065 |   table->num_sequences = 0;
2066 |   table->sequences = NULL;
2067 | 
2068 |   table->lcl_head = NULL;
2069 | 
2070 |   if (stash->dwarf_line_size < 16)
2071 |     {
2072 |       _bfd_error_handler
2073 | 	(_("Dwarf Error: Line info section is too small (%Ld)"),
2074 | 	 stash->dwarf_line_size);
2075 |       bfd_set_error (bfd_error_bad_value);
2076 |       return NULL;
2077 |     }
2078 |   line_ptr = stash->dwarf_line_buffer + unit->line_offset;
2079 |   line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;
2080 | 
2081 |   /* Read in the prologue.  */
2082 |   lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
2083 |   line_ptr += 4;
2084 |   offset_size = 4;
2085 |   if (lh.total_length == 0xffffffff)
2086 |     {
2087 |       lh.total_length = read_8_bytes (abfd, line_ptr, line_end);
2088 |       line_ptr += 8;
2089 |       offset_size = 8;
2090 |     }
2091 |   else if (lh.total_length == 0 && unit->addr_size == 8)
2092 |     {
2093 |       /* Handle (non-standard) 64-bit DWARF2 formats.  */
2094 |       lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
2095 |       line_ptr += 4;
2096 |       offset_size = 8;
2097 |     }
2098 | 
2099 |   if (lh.total_length > (size_t) (line_end - line_ptr))
2100 |     {
2101 |       _bfd_error_handler
2102 | 	/* xgettext: c-format */
2103 | 	(_("Dwarf Error: Line info data is bigger (%#Lx)"
2104 | 	   " than the space remaining in the section (%#lx)"),
2105 | 	 lh.total_length, (unsigned long) (line_end - line_ptr));
2106 |       bfd_set_error (bfd_error_bad_value);
2107 |       return NULL;
2108 |     }
2109 | 
2110 |   line_end = line_ptr + lh.total_length;
2111 | 
2112 |   lh.version = read_2_bytes (abfd, line_ptr, line_end);
2113 |   if (lh.version < 2 || lh.version > 5)
2114 |     {
2115 |       _bfd_error_handler
2116 | 	(_("Dwarf Error: Unhandled .debug_line version %d."), lh.version);
2117 |       bfd_set_error (bfd_error_bad_value);
2118 |       return NULL;
2119 |     }
2120 |   line_ptr += 2;
2121 | 
2122 |   if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))
2123 |       >= line_end)
2124 |     {
2125 |       _bfd_error_handler
2126 | 	(_("Dwarf Error: Ran out of room reading prologue"));
2127 |       bfd_set_error (bfd_error_bad_value);
2128 |       return NULL;
2129 |     }
2130 | 
2131 |   if (lh.version >= 5)
2132 |     {
2133 |       unsigned int segment_selector_size;
2134 | 
2135 |       /* Skip address size.  */
2136 |       read_1_byte (abfd, line_ptr, line_end);
2137 |       line_ptr += 1;
2138 | 
2139 |       segment_selector_size = read_1_byte (abfd, line_ptr, line_end);
2140 |       line_ptr += 1;
2141 |       if (segment_selector_size != 0)
2142 | 	{
2143 | 	  _bfd_error_handler
2144 | 	    (_("Dwarf Error: Line info unsupported segment selector size %u."),
2145 | 	     segment_selector_size);
2146 | 	  bfd_set_error (bfd_error_bad_value);
2147 | 	  return NULL;
2148 | 	}
2149 |     }
2150 | 
2151 |   if (offset_size == 4)
2152 |     lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);
2153 |   else
2154 |     lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);
2155 |   line_ptr += offset_size;
2156 | 
2157 |   lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);
2158 |   line_ptr += 1;
2159 | 
2160 |   if (lh.version >= 4)
2161 |     {
2162 |       lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);
2163 |       line_ptr += 1;
2164 |     }
2165 |   else
2166 |     lh.maximum_ops_per_insn = 1;
2167 | 
2168 |   if (lh.maximum_ops_per_insn == 0)
2169 |     {
2170 |       _bfd_error_handler
2171 | 	(_("Dwarf Error: Invalid maximum operations per instruction."));
2172 |       bfd_set_error (bfd_error_bad_value);
2173 |       return NULL;
2174 |     }
2175 | 
2176 |   lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);
2177 |   line_ptr += 1;
2178 | 
2179 |   lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);
2180 |   line_ptr += 1;
2181 | 
2182 |   lh.line_range = read_1_byte (abfd, line_ptr, line_end);
2183 |   line_ptr += 1;
2184 | 
2185 |   lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);
2186 |   line_ptr += 1;
2187 | 
2188 |   if (line_ptr + (lh.opcode_base - 1) >= line_end)
2189 |     {
2190 |       _bfd_error_handler (_("Dwarf Error: Ran out of room reading opcodes"));
2191 |       bfd_set_error (bfd_error_bad_value);
2192 |       return NULL;
2193 |     }
2194 | 
2195 |   amt = lh.opcode_base * sizeof (unsigned char);
2196 |   lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);
2197 | 
2198 |   lh.standard_opcode_lengths[0] = 1;
2199 | 
2200 |   for (i = 1; i < lh.opcode_base; ++i)
2201 |     {
2202 |       lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);
2203 |       line_ptr += 1;
2204 |     }
2205 | 
2206 |   if (lh.version >= 5)
2207 |     {
2208 |       /* Read directory table.  */
2209 |       if (!read_formatted_entries (unit, &line_ptr, line_end, table,
2210 | 				   line_info_add_include_dir_stub))
2211 | 	goto fail;
2212 | 
2213 |       /* Read file name table.  */
2214 |       if (!read_formatted_entries (unit, &line_ptr, line_end, table,
2215 | 				   line_info_add_file_name))
2216 | 	goto fail;
2217 |     }
2218 |   else
2219 |     {
2220 |       /* Read directory table.  */
2221 |       while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
2222 | 	{
2223 | 	  line_ptr += bytes_read;
2224 | 
2225 | 	  if (!line_info_add_include_dir (table, cur_dir))
2226 | 	    goto fail;
2227 | 	}
2228 | 
2229 |       line_ptr += bytes_read;
2230 | 
2231 |       /* Read file name table.  */
2232 |       while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
2233 | 	{
2234 | 	  unsigned int dir, xtime, size;
2235 | 
2236 | 	  line_ptr += bytes_read;
2237 | 
2238 | 	  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
2239 | 	  line_ptr += bytes_read;
2240 | 	  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
2241 | 	  line_ptr += bytes_read;
2242 | 	  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
2243 | 	  line_ptr += bytes_read;
2244 | 
2245 | 	  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))
2246 | 	    goto fail;
2247 | 	}
2248 | 
2249 |       line_ptr += bytes_read;
2250 |     }
2251 | 
2252 |   /* Read the statement sequences until there's nothing left.  */
2253 |   while (line_ptr < line_end)
2254 |     {
2255 |       /* State machine registers.  */
2256 |       bfd_vma address = 0;
2257 |       unsigned char op_index = 0;
2258 |       char * filename = table->num_files ? concat_filename (table, 1) : NULL;
2259 |       unsigned int line = 1;
2260 |       unsigned int column = 0;
2261 |       unsigned int discriminator = 0;
2262 |       int is_stmt = lh.default_is_stmt;
2263 |       int end_sequence = 0;
2264 |       /* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some
2265 | 	 compilers generate address sequences that are wildly out of
2266 | 	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
2267 | 	 for ia64-Linux).  Thus, to determine the low and high
2268 | 	 address, we must compare on every DW_LNS_copy, etc.  */
2269 |       bfd_vma low_pc  = (bfd_vma) -1;
2270 |       bfd_vma high_pc = 0;
2271 | 
2272 |       /* Decode the table.  */
2273 |       while (! end_sequence)
2274 | 	{
2275 | 	  op_code = read_1_byte (abfd, line_ptr, line_end);
2276 | 	  line_ptr += 1;
2277 | 
2278 | 	  if (op_code >= lh.opcode_base)
2279 | 	    {
2280 | 	      /* Special operand.  */
2281 | 	      adj_opcode = op_code - lh.opcode_base;
2282 | 	      if (lh.line_range == 0)
2283 | 		goto line_fail;
2284 | 	      if (lh.maximum_ops_per_insn == 1)
2285 | 		address += (adj_opcode / lh.line_range
2286 | 			    * lh.minimum_instruction_length);
2287 | 	      else
2288 | 		{
2289 | 		  address += ((op_index + adj_opcode / lh.line_range)
2290 | 			      / lh.maximum_ops_per_insn
2291 | 			      * lh.minimum_instruction_length);
2292 | 		  op_index = ((op_index + adj_opcode / lh.line_range)
2293 | 			      % lh.maximum_ops_per_insn);
2294 | 		}
2295 | 	      line += lh.line_base + (adj_opcode % lh.line_range);
2296 | 	      /* Append row to matrix using current values.  */
2297 | 	      if (!add_line_info (table, address, op_index, filename,
2298 | 				  line, column, discriminator, 0))
2299 | 		goto line_fail;
2300 | 	      discriminator = 0;
2301 | 	      if (address < low_pc)
2302 | 		low_pc = address;
2303 | 	      if (address > high_pc)
2304 | 		high_pc = address;
2305 | 	    }
2306 | 	  else switch (op_code)
2307 | 	    {
2308 | 	    case DW_LNS_extended_op:
2309 | 	      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2310 | 						FALSE, line_end);
2311 | 	      line_ptr += bytes_read;
2312 | 	      extended_op = read_1_byte (abfd, line_ptr, line_end);
2313 | 	      line_ptr += 1;
2314 | 
2315 | 	      switch (extended_op)
2316 | 		{
2317 | 		case DW_LNE_end_sequence:
2318 | 		  end_sequence = 1;
2319 | 		  if (!add_line_info (table, address, op_index, filename, line,
2320 | 				      column, discriminator, end_sequence))
2321 | 		    goto line_fail;
2322 | 		  discriminator = 0;
2323 | 		  if (address < low_pc)
2324 | 		    low_pc = address;
2325 | 		  if (address > high_pc)
2326 | 		    high_pc = address;
2327 | 		  if (!arange_add (unit, &unit->arange, low_pc, high_pc))
2328 | 		    goto line_fail;
2329 | 		  break;
2330 | 		case DW_LNE_set_address:
2331 | 		  address = read_address (unit, line_ptr, line_end);
2332 | 		  op_index = 0;
2333 | 		  line_ptr += unit->addr_size;
2334 | 		  break;
2335 | 		case DW_LNE_define_file:
2336 | 		  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);
2337 | 		  line_ptr += bytes_read;
2338 | 		  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
2339 | 		    {
2340 | 		      struct fileinfo *tmp;
2341 | 
2342 | 		      amt = table->num_files + FILE_ALLOC_CHUNK;
2343 | 		      amt *= sizeof (struct fileinfo);
2344 | 		      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
2345 | 		      if (tmp == NULL)
2346 | 			goto line_fail;
2347 | 		      table->files = tmp;
2348 | 		    }
2349 | 		  table->files[table->num_files].name = cur_file;
2350 | 		  table->files[table->num_files].dir =
2351 | 		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2352 | 					   FALSE, line_end);
2353 | 		  line_ptr += bytes_read;
2354 | 		  table->files[table->num_files].time =
2355 | 		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2356 | 					   FALSE, line_end);
2357 | 		  line_ptr += bytes_read;
2358 | 		  table->files[table->num_files].size =
2359 | 		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2360 | 					   FALSE, line_end);
2361 | 		  line_ptr += bytes_read;
2362 | 		  table->num_files++;
2363 | 		  break;
2364 | 		case DW_LNE_set_discriminator:
2365 | 		  discriminator =
2366 | 		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2367 | 					   FALSE, line_end);
2368 | 		  line_ptr += bytes_read;
2369 | 		  break;
2370 | 		case DW_LNE_HP_source_file_correlation:
2371 | 		  line_ptr += exop_len - 1;
2372 | 		  break;
2373 | 		default:
2374 | 		  _bfd_error_handler
2375 | 		    (_("Dwarf Error: mangled line number section."));
2376 | 		  bfd_set_error (bfd_error_bad_value);
2377 | 		line_fail:
2378 | 		  if (filename != NULL)
2379 | 		    free (filename);
2380 | 		  goto fail;
2381 | 		}
2382 | 	      break;
2383 | 	    case DW_LNS_copy:
2384 | 	      if (!add_line_info (table, address, op_index,
2385 | 				  filename, line, column, discriminator, 0))
2386 | 		goto line_fail;
2387 | 	      discriminator = 0;
2388 | 	      if (address < low_pc)
2389 | 		low_pc = address;
2390 | 	      if (address > high_pc)
2391 | 		high_pc = address;
2392 | 	      break;
2393 | 	    case DW_LNS_advance_pc:
2394 | 	      if (lh.maximum_ops_per_insn == 1)
2395 | 		address += (lh.minimum_instruction_length
2396 | 			    * _bfd_safe_read_leb128 (abfd, line_ptr,
2397 | 						     &bytes_read,
2398 | 						     FALSE, line_end));
2399 | 	      else
2400 | 		{
2401 | 		  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,
2402 | 							  &bytes_read,
2403 | 							  FALSE, line_end);
2404 | 		  address = ((op_index + adjust) / lh.maximum_ops_per_insn
2405 | 			     * lh.minimum_instruction_length);
2406 | 		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
2407 | 		}
2408 | 	      line_ptr += bytes_read;
2409 | 	      break;
2410 | 	    case DW_LNS_advance_line:
2411 | 	      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2412 | 					     TRUE, line_end);
2413 | 	      line_ptr += bytes_read;
2414 | 	      break;
2415 | 	    case DW_LNS_set_file:
2416 | 	      {
2417 | 		unsigned int file;
2418 | 
2419 | 		/* The file and directory tables are 0
2420 | 		   based, the references are 1 based.  */
2421 | 		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2422 | 					      FALSE, line_end);
2423 | 		line_ptr += bytes_read;
2424 | 		if (filename)
2425 | 		  free (filename);
2426 | 		filename = concat_filename (table, file);
2427 | 		break;
2428 | 	      }
2429 | 	    case DW_LNS_set_column:
2430 | 	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2431 | 					      FALSE, line_end);
2432 | 	      line_ptr += bytes_read;
2433 | 	      break;
2434 | 	    case DW_LNS_negate_stmt:
2435 | 	      is_stmt = (!is_stmt);
2436 | 	      break;
2437 | 	    case DW_LNS_set_basic_block:
2438 | 	      break;
2439 | 	    case DW_LNS_const_add_pc: // PATCH LOCATION
2440 | 	      if (lh.maximum_ops_per_insn == 1)
2441 | 		address += (lh.minimum_instruction_length
2442 | 			    * ((255 - lh.opcode_base) / lh.line_range));
2443 | 	      else
2444 | 		{
2445 | 		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
2446 | 		  address += (lh.minimum_instruction_length
2447 | 			      * ((op_index + adjust)
2448 | 				 / lh.maximum_ops_per_insn));
2449 | 		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
2450 | 		}
2451 | 	      break;
2452 | 	    case DW_LNS_fixed_advance_pc:
2453 | 	      address += read_2_bytes (abfd, line_ptr, line_end);
2454 | 	      op_index = 0;
2455 | 	      line_ptr += 2;
2456 | 	      break;
2457 | 	    default:
2458 | 	      /* Unknown standard opcode, ignore it.  */
2459 | 	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
2460 | 		{
2461 | 		  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
2462 | 						FALSE, line_end);
2463 | 		  line_ptr += bytes_read;
2464 | 		}
2465 | 	      break;
2466 | 	    }
2467 | 	}
2468 | 
2469 |       if (filename)
2470 | 	free (filename);
2471 |     }
2472 | 
2473 |   if (sort_line_sequences (table))
2474 |     return table;
2475 | 
2476 |  fail:
2477 |   if (table->sequences != NULL)
2478 |     free (table->sequences);
2479 |   if (table->files != NULL)
2480 |     free (table->files);
2481 |   if (table->dirs != NULL)
2482 |     free (table->dirs);
2483 |   return NULL;
2484 | }
