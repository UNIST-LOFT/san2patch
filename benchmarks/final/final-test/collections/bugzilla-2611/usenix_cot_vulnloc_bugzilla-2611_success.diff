diff --git a/libtiff/tif_ojpeg.c b/libtiff/tif_ojpeg.c
index 1ccc3f9b..d14e8bb4 100644
--- a/libtiff/tif_ojpeg.c
+++ b/libtiff/tif_ojpeg.c
@@ -811,8 +811,38 @@ OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)
 	uint8* ocr;
 	uint8* p;
 	uint32 q;
-	uint8* r;
+// FIXME: Crash CWE-369: Divide By Zero
+ 	uint8* r;
 	uint8 sx,sy;
+	/*
+	 * Validate fields derived from the image header that are later
+	 * used as divisors/moduli or loop bounds. A zero value for
+	 * bytes_per_line would cause a divide/modulo-by-zero in the
+	 * cc%sp->bytes_per_line check below. Similarly, subsampling
+	 * dimensions or buffer lengths of zero are invalid for the
+	 * decoding logic used here and should be rejected.
+	 */
+	if (sp->bytes_per_line==0)
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"Invalid image header: bytes_per_line == 0");
+		return(0);
+	}
+	/* Sanity-check other values used as loop bounds or in pointer math. */
+	if (sp->subsampling_ver == 0 || sp->subsampling_hor == 0)
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"Invalid image header: subsampling_ver or subsampling_hor == 0");
+		return(0);
+	}
+	if (sp->subsampling_convert_ylinelen == 0 || sp->subsampling_convert_clinelen == 0 || sp->subsampling_convert_clinelenout == 0)
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"Invalid image header: subsampling convert line lengths == 0");
+		return(0);
+	}
+	if (sp->subsampling_convert_ybuf == NULL || sp->subsampling_convert_cbbuf == NULL || sp->subsampling_convert_crbuf == NULL)
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"Invalid image header: missing subsampling buffers");
+		return(0);
+	}
 	if (cc%sp->bytes_per_line!=0)
 	{
 		TIFFErrorExt(tif->tif_clientdata,module,"Fractional scanline not read");
@@ -844,6 +874,7 @@ OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)
 			oy+=sp->subsampling_hor;
 			*p++=*ocb++;
 			*p++=*ocr++;
+
 		}
 		sp->subsampling_convert_state++;
 		if (sp->subsampling_convert_state==sp->subsampling_convert_clines)
