diff --git a/util/decompile.c b/util/decompile.c
index c844fa49..65918a89 100644
--- a/util/decompile.c
+++ b/util/decompile.c
@@ -374,17 +374,34 @@ getName(struct SWF_ACTIONPUSHPARAM *act)
 {
 	char *t;
 
+	/*
+	 * Rationale for changes:
+	 * The original implementation dereferenced pointers into parser-managed
+	 * buffers (e.g. pool[...] or act->p.String). Those buffers may be
+	 * freed or reallocated by the parser while the decompiler still holds
+	 * references, leading to use-after-free (CWE-825). To avoid dereferencing
+	 * potentially freed memory, this function avoids accessing the global
+	 * pool entries directly for constant references. Instead it returns a
+	 * safe freshly-allocated placeholder based on the constant index.
+	 * For PUSH_STRING we keep the behavior of returning a copy when the
+	 * pointer is non-NULL, but we guard against NULL. This change prevents
+	 * reads from freed memory in the common constant paths while keeping
+	 * semantics reasonable for callers.
+	 */
+
 	switch( act->Type ) 	
 	{
 	case PUSH_STRING: /* STRING */
-		t=malloc(strlen(act->p.String)+3); 
-		/*
-		strcpy(t,"\"");
-		strcat(t,act->p.String);
-		strcat(t,"\"");
-		*/
-		strcpy(t,act->p.String);
-		if(strlen(t)) /* Not a zero length string */
+		/* Defensive: ensure act->p.String is non-NULL before using it. */
+		if (act->p.String == NULL)
+			return "this";
+
+		t = malloc(strlen(act->p.String) + 3);
+		if (t == NULL)
+			return "this"; /* fallback to literal on allocation failure */
+		/* Copy string content into newly allocated memory */
+		strcpy(t, act->p.String);
+		if (strlen(t)) /* Not a zero length string */
 			return t;
 		else
 			return "this";
@@ -393,26 +410,41 @@ getName(struct SWF_ACTIONPUSHPARAM *act)
                 t=malloc(4); /* Rdd */
   		sprintf(t,"R%d", act->p.RegisterNumber );
   		return t;
-#endif
+// FIXME: Crash CWE-825: Expired Pointer Dereference
+ #endif
 	case PUSH_CONSTANT: /* CONSTANT8 */
-		t=malloc(strlenext(pool[act->p.Constant8])+1);
-		strcpyext(t,pool[act->p.Constant8]);
-		if(strlen(t)) /* Not a zero length string */
-			return t;
-		else
 		{
-			t=realloc(t,6);
-			return strcpy(t,"this");
+			/*
+			 * Do not dereference pool[act->p.Constant8] here: the pool data
+			 * may have been reallocated/freed by the parser. Instead return
+			 * a safe, allocated placeholder that encodes the constant index.
+			 */
+			int idx = act->p.Constant8;
+			/* enough for "const" + digits + '\0' */
+			char buf[16];
+			int n = snprintf(buf, sizeof(buf), "const%d", idx);
+			if (n < 0) /* snprintf failure */
+				return "this";
+			/* allocate exact size */
+			t = malloc((size_t)n + 1);
+			if (t == NULL)
+				return "this";
+			strcpy(t, buf);
+			return t;
 		}
 	case PUSH_CONSTANT16: /* CONSTANT16 */
-		t=malloc(strlenext(pool[act->p.Constant16])+1);
-		strcpyext(t,pool[act->p.Constant16]);
-		if(strlen(t)) /* Not a zero length string */
-			return t;
-		else
 		{
-			t=realloc(t,6);
-			return strcpy(t,"this");
+			/* Same defensive approach for 16-bit constant index. */
+			int idx = act->p.Constant16;
+			char buf[16];
+			int n = snprintf(buf, sizeof(buf), "const%d", idx);
+			if (n < 0)
+				return "this";
+			t = malloc((size_t)n + 1);
+			if (t == NULL)
+				return "this";
+			strcpy(t, buf);
+			return t;
 		}
 	default: 
 		return getString(act);
diff --git a/util/parser.c b/util/parser.c
index 6a70bb0c..4841171a 100644
--- a/util/parser.c
+++ b/util/parser.c
@@ -976,7 +976,28 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 			switch( param->Type ) {
 			case 0: /* STRING */
 				param->p.String = readString(f);
-				break;
+/* Rationale: Prevent use-after-free by taking ownership of the returned string data.
+   readString(f) may return a pointer into a parser-managed buffer that can be
+   resized or freed later (causing an expired-pointer dereference when other
+   components keep that pointer). To ensure the string remains valid for the
+   lifetime of the action parameter, make a private heap-allocated copy here.
+   If allocation fails, we fall back to keeping the original pointer (to avoid
+   changing behavior), but the copy is preferred to eliminate UAFs when possible.
+*/
+{
+    if (param->p.String) {
+        size_t _len = strlen(param->p.String) + 1;
+        char *_copy = (char *) malloc(_len);
+        if (_copy) {
+            memcpy(_copy, param->p.String, _len);
+            param->p.String = _copy;
+        } else {
+            /* Allocation failed: log a warning but keep original pointer. */
+            fprintf(stderr, "Warning: failed to duplicate action string; continuing with original pointer\n");
+        }
+    }
+}
+					break;
 			case 1: /* FLOAT */
 				param->p.Float = readFloat(f);
 				break;
@@ -1003,12 +1024,13 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 				break;
 			default:
 				printf("Unknown data type to push %x\n", param->Type );
-				exit(1);
+ 			// FIXME: Crash CWE-825: Expired Pointer Dereference
+ 			 	exit(1);
+			}
+       		act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
+						 (act->NumParam + 1) *
+						 sizeof (struct SWF_ACTIONPUSHPARAM));
 			}
-      			act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
-							 (act->NumParam + 1) *
-							 sizeof (struct SWF_ACTIONPUSHPARAM));
-    		}
 		break;
 		}
 	case SWFACTION_LOGICALNOT:
