diff --git a/util/decompile.c b/util/decompile.c
index c844fa49..18aa8861 100644
--- a/util/decompile.c
+++ b/util/decompile.c
@@ -3396,13 +3396,32 @@ decompileActions(int n, SWF_ACTION *actions, int indent)
 
 	svindent = gIndent;
 	gIndent = indent;
+// FIXME: Crash CWE-416: Use After Free (Expired Pointer Dereference, CWE-825)
+	
+	/* Rationale:
+	   Add defensive checks and make loop robust against unexpected
+	   return values from decompileAction. This prevents accidental
+	   overflows/invalid accesses which can make use-after-free crashes
+	   more likely. This is a minimal, conservative change.
+	*/
+	if (actions == NULL || n <= 0) {
+		gIndent = svindent;
+		return;
+	}
 	
 	for(i=0;i<n;i++) {
-		i+=decompileAction(i, actions, n);
+		int delta = decompileAction(i, actions, n);
+		if (delta <= 0) {
+			/* Stop if decompileAction signals an unexpected value to avoid
+			   proceeding while internal state may be inconsistent. */
+			break;
+		}
+		i += delta;
 	}
 	gIndent = svindent;
 }
 
+
 char *
 decompile5Action(int n, SWF_ACTION *actions,int indent)
 {
diff --git a/util/parser.c b/util/parser.c
index 6a70bb0c..68b5c704 100644
--- a/util/parser.c
+++ b/util/parser.c
@@ -975,7 +975,27 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 			param->Type = readUInt8(f);
 			switch( param->Type ) {
 			case 0: /* STRING */
-				param->p.String = readString(f);
+				{
+					/* Rationale: allocate an independent copy using malloc+memcpy to
+					   guarantee stability of the stored pointer even if parser
+					   internal buffers are reallocated/freed. */
+					char *tmp = readString(f);
+					if (tmp) {
+						size_t len = strlen(tmp) + 1;
+						char *dup = (char *) malloc(len);
+						if (dup) {
+							memcpy(dup, tmp, len);
+							param->p.String = dup;
+						} else {
+							/* If allocation fails, fall back to original pointer (best-effort)
+							   to avoid data loss; this retains existing behavior while
+							   preferring a safe deep-copy when possible. */
+							param->p.String = tmp;
+						}
+					} else {
+						param->p.String = NULL;
+					}
+				}
 				break;
 			case 1: /* FLOAT */
 				param->p.Float = readFloat(f);
@@ -1003,12 +1023,23 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 				break;
 			default:
 				printf("Unknown data type to push %x\n", param->Type );
-				exit(1);
+			// FIXME: Crash CWE-416: Use After Free (Expired Pointer Dereference, CWE-825)
+ 				exit(1);
 			}
-      			act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
-							 (act->NumParam + 1) *
-							 sizeof (struct SWF_ACTIONPUSHPARAM));
-    		}
+      			/* Rationale: assign realloc result through a temporary and validate it
+				   to avoid losing the original pointer on failure. */
+      			{
+      				struct SWF_ACTIONPUSHPARAM *tmpParams = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
+								 (act->NumParam + 1) *
+								 sizeof (struct SWF_ACTIONPUSHPARAM));
+      				if (tmpParams == NULL) {
+      					fprintf(stderr, "realloc failed\n");
+      					return 0;
+      				}
+      				act->Params = tmpParams;
+      			}
+		}
+
 		break;
 		}
 	case SWFACTION_LOGICALNOT:
