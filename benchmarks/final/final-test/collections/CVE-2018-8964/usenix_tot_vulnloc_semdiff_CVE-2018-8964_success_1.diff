diff --git a/util/decompile.c b/util/decompile.c
index c844fa49..47fc3b0e 100644
--- a/util/decompile.c
+++ b/util/decompile.c
@@ -3396,13 +3396,28 @@ decompileActions(int n, SWF_ACTION *actions, int indent)
 
 	svindent = gIndent;
 	gIndent = indent;
-	
+// FIXME: Crash CWE-416: Use After Free
+	/* RATIONALE:
+	   Add defensive checks to avoid iterating on a NULL actions pointer
+	   or using an out-of-range index returned by decompileAction.
+	   This minimizes the chance of dereferencing invalid memory
+	   if callers pass an invalid pointer/length.
+	*/
+	if (actions == NULL || n <= 0) {
+		gIndent = svindent;
+		return;
+	}
+
 	for(i=0;i<n;i++) {
-		i+=decompileAction(i, actions, n);
+		int delta = decompileAction(i, actions, n);
+		if (delta <= 0) break; /* guard against unexpected negative/zero returns */
+		if (i + delta >= n) break; /* prevent stepping past the array */
+		i += delta;
 	}
 	gIndent = svindent;
 }
 
+
 char *
 decompile5Action(int n, SWF_ACTION *actions,int indent)
 {
diff --git a/util/parser.c b/util/parser.c
index 6a70bb0c..156de572 100644
--- a/util/parser.c
+++ b/util/parser.c
@@ -971,11 +971,27 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
   		act->Params = (struct SWF_ACTIONPUSHPARAM *) calloc (1, sizeof (struct SWF_ACTIONPUSHPARAM));
   		act->NumParam = 0;
   		while ( fileOffset < end ) {
+			/* RATIONALE: Combine both protections: copy strings out of parser-owned
+			   buffers so they don't dangle, and use a temporary pointer for
+			   realloc so we don't lose the original pointer on allocation failure. */
+			struct SWF_ACTIONPUSHPARAM *tmp_params;
+			char *tmpstr;
 			param = &(act->Params[act->NumParam++]);
 			param->Type = readUInt8(f);
 			switch( param->Type ) {
 			case 0: /* STRING */
-				param->p.String = readString(f);
+				tmpstr = readString(f);
+				if (tmpstr) {
+					param->p.String = (char *) malloc(strlen(tmpstr) + 1);
+					if (param->p.String == NULL) {
+						fprintf(stderr, "Out of memory copying parameter string\n");
+						act->NumParam--;
+						return 0;
+					}
+					strcpy(param->p.String, tmpstr);
+				} else {
+					param->p.String = NULL;
+				}
 				break;
 			case 1: /* FLOAT */
 				param->p.Float = readFloat(f);
@@ -1003,12 +1019,20 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 				break;
 			default:
 				printf("Unknown data type to push %x\n", param->Type );
-				exit(1);
+			// FIXME: Crash CWE-416: Use After Free
+			 	exit(1);
 			}
-      			act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
-							 (act->NumParam + 1) *
-							 sizeof (struct SWF_ACTIONPUSHPARAM));
-    		}
+      			tmp_params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
+								 (act->NumParam + 1) *
+								 sizeof (struct SWF_ACTIONPUSHPARAM));
+			if (tmp_params == NULL) {
+				fprintf(stderr, "Out of memory reallocating action params\n");
+				act->NumParam--;
+				return 0;
+			}
+			act->Params = tmp_params;
+		}
+
 		break;
 		}
 	case SWFACTION_LOGICALNOT:
