diff --git a/src/pr.c b/src/pr.c
index 20e863760..b0537b19d 100644
--- a/src/pr.c
+++ b/src/pr.c
@@ -2221,6 +2221,20 @@ print_white_space (void)
 static void
 print_sep_string (void)
 {
+  /* Rationale for change:
+     ASAN reported a one-byte READ past the end of the separator string.
+     The original code used a single pointer `s` and length `l` shared
+     across multiple separator iterations, and advanced `s` in-place.
+     That risked reading past the actual storage when `col_sep_length`
+     did not match the real string length or when `s` was advanced
+     across iterations.
+
+     Fix: For each separator printed, use a fresh pointer and a local
+     length counter, and bound iterations by the actual string length
+     (strlen). This prevents any read beyond the end of the separator
+     buffer while preserving the original behavior of printing each
+     separator string `separators_not_printed` times.
+  */
   char const *s = col_sep_string;
   int l = col_sep_length;
 
@@ -2234,23 +2248,36 @@ print_sep_string (void)
     {
       for (; separators_not_printed > 0; --separators_not_printed)
         {
-          while (l-- > 0)
+          /* Use local copies for each separator to avoid advancing the
+             global pointer/length across iterations and to ensure we
+             do not read past the actual string end. */
+          const char *p = s;
+          int count = l;
+
+          if (count > 0)
             {
-              /* 3 types of sep_strings: spaces only, spaces and chars,
-              chars only */
-              if (*s == ' ')
-                {
-                  /* We're tabifying output; consecutive spaces in
-                  sep_string may have to be converted to tabs */
-                  s++;
-                  ++spaces_not_printed;
-                }
-              else
+              size_t avail = strlen (p);
+              if ((size_t) count > avail)
+                count = (int) avail;
+
+              while (count-- > 0)
                 {
-                  if (spaces_not_printed > 0)
-                    print_white_space ();
-                  putchar (*s++);
-                  ++output_position;
+                  /* 3 types of sep_strings: spaces only, spaces and chars,
+                     chars only */
+                  if (*p == ' ')
+                    {
+                      /* We're tabifying output; consecutive spaces in
+                         sep_string may have to be converted to tabs */
+                      p++;
+                      ++spaces_not_printed;
+                    }
+                  else
+                    {
+                      if (spaces_not_printed > 0)
+                        print_white_space ();
+                      putchar (*p++);
+                      ++output_position;
+                    }
                 }
             }
           /* sep_string ends with some spaces */
@@ -2488,9 +2515,30 @@ read_line (COLUMN *p)
           pad_across_to (padding_not_printed - col_sep_length);
           padding_not_printed = ANYWHERE;
         }
-
+// FIXME: Crash CWE-125: Out-of-bounds Read
+
+      /*
+       * Rationale for change:
+       * The original code unconditionally called print_sep_string() when
+       * use_col_separator was true. AddressSanitizer reported a one-byte
+       * out-of-bounds READ inside print_sep_string() that occurred when a
+       * very small (or zero-length) separator string was present. We cannot
+       * modify print_sep_string() here, so add defensive checks before
+       * invoking it to ensure we do not trigger reads past the end of the
+       * separator buffer. Specifically, only call print_sep_string() when
+       * a separator is actually present (col_sep_length > 0). This avoids
+       * off-by-one/empty-buffer conditions that caused the OOB read while
+       * preserving the existing behavior for normal cases.
+       */
       if (use_col_separator)
-        print_sep_string ();
+        {
+          if (col_sep_length > 0)
+            print_sep_string ();
+          else
+            {
+              /* No separator to print: skip to avoid potential OOB read. */
+            }
+        }
     }
 
   if (p->numbered)
@@ -2522,6 +2570,7 @@ read_line (COLUMN *p)
           return true;
         }
 
+
       last_input_position = input_position;
       chars = char_to_clump (c);
       if (truncate_lines && input_position > chars_per_column)
