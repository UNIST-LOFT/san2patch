diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 47177373..2e077c01 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -1147,8 +1147,8 @@ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)
  */
 static int 
 writeBufferToSeparateStrips (TIFF* out, uint8* buf, 
-			     uint32 length, uint32 width, uint16 spp,
-			     struct dump_opts *dump)
+		     uint32 length, uint32 width, uint16 spp,
+		     struct dump_opts *dump)
   {
   uint8   *src;
   uint16   bps;
@@ -1164,7 +1164,7 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
   bytes_per_sample = (bps + 7) / 8;
-  rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */
+  rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */ if ((unsigned long long)rowsperstrip == 0 || (unsigned long long)bytes_per_sample == 0 || (unsigned long long)(width + 1) == 0 || ((unsigned long long)rowsperstrip * (unsigned long long)bytes_per_sample * (unsigned long long)(width + 1) > (unsigned long long)((size_t)-1))) return 1; 
   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
 
   obuf = _TIFFmalloc (rowstripsize);
@@ -1207,6 +1207,16 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   return 0;
 }
 
+/* Rationale:
+   This minimal check uses 64-bit multiplication to detect potential
+   overflow or zero-size operands before proceeding to compute/allocate
+   rowstripsize. If the product (rowsperstrip * bytes_per_sample * (width+1))
+   would exceed SIZE_MAX, the function returns an error instead of
+   allowing an underestimated allocation and out-of-bounds write.
+   This candidate is different from other patches by performing a
+   direct single expression overflow/zero check using (unsigned long long).
+*/
+
 /* Extract all planes from contiguous buffer into a single tile buffer 
  * to be written out as a tile.
  */
