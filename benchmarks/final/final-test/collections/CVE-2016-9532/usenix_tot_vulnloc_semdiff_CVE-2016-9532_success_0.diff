diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 47177373..d8223889 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -1148,7 +1148,7 @@ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)
 static int 
 writeBufferToSeparateStrips (TIFF* out, uint8* buf, 
 			     uint32 length, uint32 width, uint16 spp,
-			     struct dump_opts *dump)
+		     struct dump_opts *dump)
   {
   uint8   *src;
   uint16   bps;
@@ -1161,11 +1161,33 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   tsize_t  total_bytes = 0;
   tdata_t  obuf;
 
+  /* Rationale: compute allocation sizes using integer-overflow-safe
+     arithmetic and allocate exactly the bytes needed for separate
+     sample strips (rowsperstrip * bytes_per_sample * width). This
+     prevents under-allocation that led to a heap-buffer-overflow. */
+
   (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
-  bytes_per_sample = (bps + 7) / 8;
+// FIXME: Crash CWE-787: Out-of-bounds Write
+   bytes_per_sample = (bps + 7) / 8;
   rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */
-  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
+
+  /* Safe multiplication: compute (size_t)rowsperstrip * bytes_per_sample * width
+     with overflow checks before converting to tsize_t. */
+  {
+    size_t a = (size_t)rowsperstrip;
+    size_t b = (size_t)bytes_per_sample;
+    size_t c = (size_t)width;
+    size_t tmp;
+
+    if (b != 0 && a > SIZE_MAX / b)
+      return 1; /* would overflow */
+    tmp = a * b;
+    if (c != 0 && tmp > SIZE_MAX / c)
+      return 1; /* would overflow */
+    /* all good */
+    rowstripsize = (tsize_t)(tmp * c);
+  }
 
   obuf = _TIFFmalloc (rowstripsize);
   if (obuf == NULL)
@@ -1207,6 +1229,7 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   return 0;
 }
 
+
 /* Extract all planes from contiguous buffer into a single tile buffer 
  * to be written out as a tile.
  */
