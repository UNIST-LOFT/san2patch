diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 47177373..8532fc9d 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -1147,8 +1147,8 @@ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)
  */
 static int 
 writeBufferToSeparateStrips (TIFF* out, uint8* buf, 
-			     uint32 length, uint32 width, uint16 spp,
-			     struct dump_opts *dump)
+		     uint32 length, uint32 width, uint16 spp,
+		     struct dump_opts *dump)
   {
   uint8   *src;
   uint16   bps;
@@ -1165,7 +1165,27 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
   bytes_per_sample = (bps + 7) / 8;
   rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */
-  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
+// FIXME: Crash CWE-787: Out-of-bounds Write
+   /* Rationale:
+    * The previous ad-hoc calculation for rowstripsize could miscompute the
+    * exact number of bytes required for a strip when bits-per-sample is not
+    * a whole number of bytes or when packing/stride differ. This caused a
+    * one-byte heap overflow in extractContigSamples24bits. Use TIFFVStripSize
+    * to compute the worst-case number of bytes required for 'rowsperstrip'
+    * rows of a single plane. As a defensive fallback, compute a conservative
+    * per-row size for a single sample plane and ensure at least one byte is
+    * allocated to avoid zero-sized malloc behaviour.
+    */
+   rowstripsize = TIFFVStripSize(out, rowsperstrip);
+   if (rowstripsize <= 0)
+     {
+     /* Fallback conservative calculation: number of bytes per row for a
+      * single sample plane = ((bps * width) + 7) / 8, times rowsperstrip.
+      */
+     rowstripsize = rowsperstrip * ((bps * width + 7) / 8);
+     if (rowstripsize < 1)
+       rowstripsize = 1;
+     }
 
   obuf = _TIFFmalloc (rowstripsize);
   if (obuf == NULL)
@@ -1178,6 +1198,13 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
       nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;
 
       stripsize = TIFFVStripSize(out, nrows);
+      /* Defensive check: ensure we never try to write more bytes than we
+       * allocated for obuf. Normally TIFFVStripSize(out, rowsperstrip)
+       * computed the allocation size, so this should not trigger, but keep
+       * it as a safety clamp.
+       */
+      if (stripsize > rowstripsize)
+        stripsize = rowstripsize;
       src = buf + (row * rowsize);
       total_bytes += stripsize;
       memset (obuf, '\0', rowstripsize);
@@ -1198,6 +1225,7 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
         {
 	TIFFError(TIFFFileName(out), "Error, can't write strip %u", strip - 1);
 	_TIFFfree(obuf);
+
 	return 1;
 	}
       }
@@ -2989,23 +3017,34 @@ extractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,
   while (ready_bits > 0)
     {
     bytebuff1 = (buff2 >> 24);
-    *dst++ = bytebuff1;
+    /* Ensure we don't write past the computed end */
+    if (dst < out + (size_t)((((uint64_t)(((end >= start) ? (end - start + 1) : 0) * (uint64_t)count) * (uint64_t)spp * (uint64_t)bps + 7) / 8)))
+      {
+      *dst++ = bytebuff1;
+      }
+    else
+      {
+      /* no space left, stop writing trailing bits */
+      break;
+      }
 
     buff2 = (buff2 << 8);
     bytebuff2 = bytebuff1;
     ready_bits -= 8;
     } 
   
+_extract24_done:
   return (0);
   } /* end extractContigSamples24bits */
 
 static int
 extractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,
                             tsample_t sample, uint16 spp, uint16 bps, 
- 			    tsample_t count, uint32 start, uint32 end)
+                            tsample_t count, uint32 start, uint32 end)
   {
   int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;
   uint32 col, src_byte, src_bit, bit_offset;
+
   uint32 longbuff1 = 0, longbuff2 = 0;
   uint64 maskbits = 0, matchbits = 0;
   uint64 buff1 = 0, buff2 = 0, buff3 = 0;
