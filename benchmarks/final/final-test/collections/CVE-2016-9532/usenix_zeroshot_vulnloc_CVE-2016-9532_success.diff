diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 47177373..24b90d47 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -1147,8 +1147,8 @@ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)
  */
 static int 
 writeBufferToSeparateStrips (TIFF* out, uint8* buf, 
-			     uint32 length, uint32 width, uint16 spp,
-			     struct dump_opts *dump)
+		     uint32 length, uint32 width, uint16 spp,
+		     struct dump_opts *dump)
   {
   uint8   *src;
   uint16   bps;
@@ -1165,7 +1165,19 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
   bytes_per_sample = (bps + 7) / 8;
   rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */
-  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
+// FIXME: Crash
+   /* Rationale:
+    * The previous calculation for rowstripsize used "rowsperstrip * bytes_per_sample * (width + 1)"
+    * which underestimates the required buffer size for encoded strips (especially when
+    * compression or other TIFF internals affect the encoded size) and can lead to
+    * heap-buffer-overflow when TIFFWriteEncodedStrip writes more bytes than allocated.
+    * Use TIFFVStripSize(out, rowsperstrip) to compute a safe maximum encoded strip
+    * buffer size for the configured rowsperstrip and ensure we allocate at least
+    * that many bytes. Also guard against zero-size results.
+    */
+   rowstripsize = (tsize_t) TIFFVStripSize(out, rowsperstrip);
+   if (rowstripsize <= 0)
+     rowstripsize = (tsize_t) (stripsize > 0 ? stripsize : 1);
 
   obuf = _TIFFmalloc (rowstripsize);
   if (obuf == NULL)
@@ -2946,6 +2958,17 @@ extractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,
     bit_offset = col * bps * spp;
     for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)
       {
+      /*
+       * Rationale:
+       * The crash occurs because two bytes are written to dst in the "else" path
+       * even when only one byte of output buffer remains. To avoid a heap
+       * buffer overflow, change the condition so that the "else" path that
+       * writes two bytes is only taken when more than 16 bits are already
+       * available (ready_bits > 16). This prevents the code path that wrote
+       * two bytes when exactly 16 bits were available (which caused the extra
+       * byte write beyond the allocated buffer). Additionally add a defensive
+       * check before writing the second byte as an extra safeguard.
+       */
       if (sindex == 0)
         {
         src_byte = bit_offset / 8;
@@ -2965,7 +2988,7 @@ extractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,
 	buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
       buff1 = (buff1 & matchbits) << (src_bit);
 
-      if (ready_bits < 16) /* add another bps bits to the buffer */
+      if (ready_bits <= 16) /* add another bps bits to the buffer */
         {
         bytebuff1 = bytebuff2 = 0;
         buff2 = (buff2 | (buff1 >> ready_bits));
@@ -2973,13 +2996,28 @@ extractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,
       else /* If we have a full buffer's worth, write it out */
         {
         bytebuff1 = (buff2 >> 24);
-        *dst++ = bytebuff1;
-        bytebuff2 = (buff2 >> 16);
-        *dst++ = bytebuff2;
-        ready_bits -= 16;
+// FIXME: Crash
+         *dst++ = bytebuff1;
+        /* Only write the second byte when there truly were >16 bits ready
+           (the changed condition above ensures this), and keep an extra
+           defensive check in case of unexpected buffer sizing. */
+        if (ready_bits > 16)
+          {
+          bytebuff2 = (buff2 >> 16);
+          *dst++ = bytebuff2;
+          ready_bits -= 16;
 
-        /* shift in new bits */
-        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
+          /* shift in new bits */
+          buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
+          }
+        else
+          {
+          /* If we didn't write the second byte, we still need to update
+             buff2 to reflect the newly added bits (do not subtract 16).
+             Place the new bits in the lower portion so subsequent iterations
+             or the trailing loop will output them correctly. */
+          buff2 = (buff2 | (buff1 >> ready_bits));
+          }
         }
       ready_bits += bps;
       }
@@ -3002,7 +3040,7 @@ extractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,
 static int
 extractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,
                             tsample_t sample, uint16 spp, uint16 bps, 
- 			    tsample_t count, uint32 start, uint32 end)
+ 		    tsample_t count, uint32 start, uint32 end)
   {
   int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;
   uint32 col, src_byte, src_bit, bit_offset;
