diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 47177373..8ae86b65 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -1147,8 +1147,8 @@ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)
  */
 static int 
 writeBufferToSeparateStrips (TIFF* out, uint8* buf, 
-			     uint32 length, uint32 width, uint16 spp,
-			     struct dump_opts *dump)
+		     uint32 length, uint32 width, uint16 spp,
+		     struct dump_opts *dump)
   {
   uint8   *src;
   uint16   bps;
@@ -1161,11 +1161,48 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   tsize_t  total_bytes = 0;
   tdata_t  obuf;
 
+  /* Rationale:
+   * Fix integer-sizing and rounding errors in computing the allocation size
+   * for the per-strip buffer. The original code used an incorrect formula
+   * (rowsperstrip * bytes_per_sample * (width + 1)) which can under-allocate
+   * packed samples and lead to out-of-bounds writes. Here we compute the
+   * required bytes per row using 64-bit arithmetic with explicit rounding
+   * from bits to bytes, check for overflow against SIZE_MAX, and only then
+   * allocate. If the checks fail we return an error rather than risking
+   * heap corruption.
+   */
+
   (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
   (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
   bytes_per_sample = (bps + 7) / 8;
   rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */
-  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
+
+/* Compute safe allocation size for the largest possible strip (rowsperstrip rows)
+   using 64-bit temporaries and rounding from bits to bytes. */
+  {
+    uint64_t bits_per_row, bytes_per_row, req_size64;
+
+    if (rowsperstrip == 0) /* defensive check */
+      return 1;
+
+    bits_per_row = (uint64_t)width * (uint64_t)bps * (uint64_t)spp;
+    bytes_per_row = (bits_per_row + 7) / 8; /* round up bits to full bytes */
+
+    /* If width or bps or spp is zero then bytes_per_row may be 0; bail out */
+    if (bytes_per_row == 0)
+      return 1;
+
+    /* Check multiplication overflow: bytes_per_row * rowsperstrip must fit in size_t */
+    if (bytes_per_row > (uint64_t)(SIZE_MAX) / (uint64_t)rowsperstrip)
+      return 1;
+
+    req_size64 = bytes_per_row * (uint64_t)rowsperstrip;
+
+    if (req_size64 == 0 || req_size64 > (uint64_t)SIZE_MAX)
+      return 1;
+
+    rowstripsize = (tsize_t)req_size64;
+  }
 
   obuf = _TIFFmalloc (rowstripsize);
   if (obuf == NULL)
@@ -1179,11 +1216,46 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
 
       stripsize = TIFFVStripSize(out, nrows);
       src = buf + (row * rowsize);
+// Rationale: compute exact number of bytes required for the destination buffer using
+// safe 64-bit arithmetic and round-up from bits to bytes to avoid truncation and
+// integer overflow. Allocate a temporary buffer of the exact required size and use
+// it for extraction and writing. This prevents writing past the end of the buffer
+// (CWE-787) when packing packed samples such as 24-bit contiguous samples.
+      {
+      uint64_t bits_per_row = (uint64_t)width * (uint64_t)bps * (uint64_t)spp;
+      uint64_t bytes_per_row = (bits_per_row + 7) / 8; /* round up bits->bytes */
+      uint64_t required_u64 = bytes_per_row * (uint64_t)nrows;
+      size_t required_size;
+      void *tmp_obuf;
+
+      /* Validate parameters to avoid overflow and unreasonable allocations */
+      if (bps == 0 || spp == 0 || width == 0 || nrows == 0) {
+        TIFFError(TIFFFileName(out), "Invalid TIFF parameters (bps/spp/width/nrows)");
+        return 1;
+      }
+      if (bytes_per_row == 0) {
+        TIFFError(TIFFFileName(out), "Computed zero bytes per row");
+        return 1;
+      }
+      /* Check for multiplication overflow and that required_u64 fits in size_t */
+      if (bytes_per_row > (uint64_t)SIZE_MAX / (uint64_t)nrows) {
+        TIFFError(TIFFFileName(out), "Required buffer size too large");
+        return 1;
+      }
+      required_size = (size_t)required_u64;
+
+      /* Allocate temporary buffer with the exact required size and zero it */
+      tmp_obuf = _TIFFmalloc(required_size);
+      if (tmp_obuf == NULL) {
+        TIFFError(TIFFFileName(out), "Out of memory allocating strip buffer");
+        return 1;
+      }
+
       total_bytes += stripsize;
-      memset (obuf, '\0', rowstripsize);
-      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))
+      memset (tmp_obuf, '\0', required_size);
+      if (extractContigSamplesToBuffer(tmp_obuf, src, nrows, width, s, spp, bps, dump))
         {
-        _TIFFfree(obuf);
+        _TIFFfree(tmp_obuf);
         return 1;
 	}
       if ((dump->outfile != NULL) && (dump->level == 1))
@@ -1191,15 +1263,17 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
         dump_info(dump->outfile, dump->format,"", 
                   "Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d", 
                   s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);
-        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);
+        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, tmp_obuf);
 	}
 
-      if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)
+      if (TIFFWriteEncodedStrip(out, strip++, tmp_obuf, stripsize) < 0)
         {
 	TIFFError(TIFFFileName(out), "Error, can't write strip %u", strip - 1);
-	_TIFFfree(obuf);
+	_TIFFfree(tmp_obuf);
 	return 1;
 	}
+      _TIFFfree(tmp_obuf);
+      }
       }
     }      
 
@@ -1207,6 +1281,7 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   return 0;
 }
 
+
 /* Extract all planes from contiguous buffer into a single tile buffer 
  * to be written out as a tile.
  */
