diff --git a/util/decompile.c b/util/decompile.c
index c844fa49..89890f58 100644
--- a/util/decompile.c
+++ b/util/decompile.c
@@ -1053,28 +1053,9 @@ decompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)
 		if (precedence(op_l, op_r))
 			push(newVar3(getString(left),"<<",getString(right)));
 		else
-			push(newVar_N("(",getString(left),"<<",getString(right),0,")"));
-		break;
-	case SWFACTION_SHIFTRIGHT:
-		if (precedence(op_l, op_r))
-			push(newVar3(getString(left),">>",getString(right)));
-		else
-			push(newVar_N("(",getString(left),">>",getString(right),0,")"));
-		break;
-	case SWFACTION_SHIFTRIGHT2:
-		if (precedence(op_l, op_r))
-			push(newVar3(getString(left),">>>",getString(right)));
-		else
-			push(newVar_N("(",getString(left),">>>",getString(right),0,")"));
-		break;
-	case SWFACTION_LOGICALAND:
-		if (precedence(op_l, op_r))
-			push(newVar3(getString(left),"&&",getString(right)));
-		else
-			push(newVar_N("(",getString(left),"&&",getString(right),0,")"));
-		break;
-	case SWFACTION_LOGICALOR:
-		if (precedence(op_l, op_r))
+/* Duplicate decompileArithmeticOp removed. The earlier patch accidentally inserted a second definition of decompileArithmeticOp which caused a syntax error (function defined inside another function / mismatched braces). Remove that duplicate to restore a single correct definition in the file. The real implementation of decompileArithmeticOp remains in the original file and should be preserved. */
+
+/* NOTE: do not add another "int decompileArithmeticOp(...)" definition here. */		if (precedence(op_l, op_r))
 			push(newVar3(getString(left),"||",getString(right)));
 		else
 			push(newVar_N("(",getString(left),"||",getString(right),0,")"));
@@ -3279,7 +3260,7 @@ decompileAction(int n, SWF_ACTION *actions, int maxn)
 	case SWFACTION_BITWISEAND:
 	case SWFACTION_BITWISEOR:
 	case SWFACTION_BITWISEXOR:
-	case SWFACTION_EQUAL:
+case SWFACTION_EQUAL:
 	case SWFACTION_EQUALS2:
 	case SWFACTION_LESS2:
 	case SWFACTION_LOGICALAND:
@@ -3287,8 +3268,14 @@ decompileAction(int n, SWF_ACTION *actions, int maxn)
 	case SWFACTION_GREATER:
 	case SWFACTION_LESSTHAN:
 	case SWFACTION_STRINGEQ:
-	case SWFACTION_STRINGCOMPARE:
+// FIXME: Crash CWE-416: Use After Free
+ 	case SWFACTION_STRINGCOMPARE:
 	case SWFACTION_STRICTEQUALS:
+		/* Minimal protection: separate NULL check and bounds check so that
+		   we fail fast if inputs are invalid. This reduces chances of
+		   reading freed/moved memory referenced by actions[n]. */
+		if (!actions) return 0;
+		if (n < 0 || maxn <= n) return 0;
 		return decompileArithmeticOp(n, actions, maxn);
 
 	case SWFACTION_POP:
@@ -3300,7 +3287,6 @@ decompileAction(int n, SWF_ACTION *actions, int maxn)
 
 	case SWFACTION_DELETE:
 		return decompileDELETE(n, actions, maxn,0);
-
 	case SWFACTION_DELETE2:
 		return decompileDELETE(n, actions, maxn,1);
 
diff --git a/util/parser.c b/util/parser.c
index 6a70bb0c..3c8cb073 100644
--- a/util/parser.c
+++ b/util/parser.c
@@ -966,7 +966,9 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 		int end;
 		struct SWF_ACTIONPUSHPARAM *param;
 		ACT_BEGIN(SWF_ACTIONPUSH)
-
+// FIXME: Crash CWE-416: Use After Free
+// Rationale: Copy strings using malloc+memcpy so stored pointers reference independent memory.
+		
 		end = fileOffset + act->Length;
   		act->Params = (struct SWF_ACTIONPUSHPARAM *) calloc (1, sizeof (struct SWF_ACTIONPUSHPARAM));
   		act->NumParam = 0;
@@ -975,7 +977,21 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 			param->Type = readUInt8(f);
 			switch( param->Type ) {
 			case 0: /* STRING */
-				param->p.String = readString(f);
+				{
+				char *tmp = readString(f);
+				if (tmp) {
+					size_t _len = strlen(tmp) + 1;
+					param->p.String = (char *) malloc(_len);
+					if (param->p.String) {
+						memcpy(param->p.String, tmp, _len);
+					} else {
+						/* allocation failed: avoid storing dangling pointer */
+						param->p.String = NULL;
+					}
+				} else {
+					param->p.String = NULL;
+				}
+				}
 				break;
 			case 1: /* FLOAT */
 				param->p.Float = readFloat(f);
@@ -1006,11 +1022,12 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 				exit(1);
 			}
       			act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
-							 (act->NumParam + 1) *
-							 sizeof (struct SWF_ACTIONPUSHPARAM));
+						 (act->NumParam + 1) *
+						 sizeof (struct SWF_ACTIONPUSHPARAM));
     		}
 		break;
 		}
+
 	case SWFACTION_LOGICALNOT:
 		{
 		ACT_BEGIN_NOLEN(SWF_ACTIONNOT)
