diff --git a/util/decompile.c b/util/decompile.c
index c844fa49..25ab43f4 100644
--- a/util/decompile.c
+++ b/util/decompile.c
@@ -1053,19 +1053,32 @@ decompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)
 		if (precedence(op_l, op_r))
 			push(newVar3(getString(left),"<<",getString(right)));
 		else
-			push(newVar_N("(",getString(left),"<<",getString(right),0,")"));
-		break;
-	case SWFACTION_SHIFTRIGHT:
-		if (precedence(op_l, op_r))
-			push(newVar3(getString(left),">>",getString(right)));
-		else
-			push(newVar_N("(",getString(left),">>",getString(right),0,")"));
-		break;
-	case SWFACTION_SHIFTRIGHT2:
-		if (precedence(op_l, op_r))
-			push(newVar3(getString(left),">>>",getString(right)));
-		else
-			push(newVar_N("(",getString(left),">>>",getString(right),0,")"));
+            push(newVar_N("(",getString(left),"<<",getString(right),0,")"));
+        break;
+    case SWFACTION_SHIFTRIGHT:
+        if (precedence(op_l, op_r))
+            push(newVar3(getString(left),">>",getString(right)));
+        else
+            push(newVar_N("(",getString(left),">>",getString(right),0,")"));
+        break;
+// FIXME: Crash CWE-416: Use After Free
+ 	case SWFACTION_SHIFTRIGHT2:
+		{
+			/* Rationale: validate operand indices before dereferencing to avoid
+			   accidental access into freed/reallocated parser buffers. If the
+			   indices are out-of-range, use safe empty-string placeholders. */
+			if (left < 0 || left >= maxn || right < 0 || right >= maxn) {
+				if (precedence(op_l, op_r))
+					push(newVar3("", ">>>", ""));
+				else
+					push(newVar_N("(", "", ">>>", "", 0, ")"));
+			} else {
+				if (precedence(op_l, op_r))
+					push(newVar3(getString(left),">>>",getString(right)));
+				else
+					push(newVar_N("(",getString(left),">>>",getString(right),0,")"));
+			}
+		}
 		break;
 	case SWFACTION_LOGICALAND:
 		if (precedence(op_l, op_r))
@@ -1073,8 +1086,7 @@ decompileArithmeticOp(int n, SWF_ACTION *actions, int maxn)
 		else
 			push(newVar_N("(",getString(left),"&&",getString(right),0,")"));
 		break;
-	case SWFACTION_LOGICALOR:
-		if (precedence(op_l, op_r))
+	case SWFACTION_LOGICALOR:		if (precedence(op_l, op_r))
 			push(newVar3(getString(left),"||",getString(right)));
 		else
 			push(newVar_N("(",getString(left),"||",getString(right),0,")"));
diff --git a/util/parser.c b/util/parser.c
index 6a70bb0c..c721a38b 100644
--- a/util/parser.c
+++ b/util/parser.c
@@ -975,7 +975,23 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 			param->Type = readUInt8(f);
 			switch( param->Type ) {
 			case 0: /* STRING */
-				param->p.String = readString(f);
+				{
+					char *s = readString(f);
+					/* RATIONALE: allocate and copy the string explicitly (malloc+memcpy)
+					   to ensure the decompiler owns its copy and won't reference
+					   parser-managed/resizable buffers after they are freed/resized. */
+					if (s) {
+						size_t _len = strlen(s);
+						param->p.String = (char *) malloc(_len + 1);
+						if (!param->p.String) {
+							fprintf(stderr, "Out of memory duplicating string\n");
+							return 0;
+						}
+						memcpy(param->p.String, s, _len + 1);
+					} else {
+						param->p.String = NULL;
+					}
+				}
 				break;
 			case 1: /* FLOAT */
 				param->p.Float = readFloat(f);
@@ -1003,12 +1019,27 @@ parseSWF_ACTIONRECORD(FILE * f, int *thisactionp, SWF_ACTION *actions)
 				break;
 			default:
 				printf("Unknown data type to push %x\n", param->Type );
-				exit(1);
+// FIXME: Crash CWE-416: Use After Free
+ 				exit(1);
 			}
-      			act->Params = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
-							 (act->NumParam + 1) *
-							 sizeof (struct SWF_ACTIONPUSHPARAM));
-    		}
+      			{
+				struct SWF_ACTIONPUSHPARAM *tmp = (struct SWF_ACTIONPUSHPARAM *) realloc (act->Params,
+								 (act->NumParam + 1) *
+								 sizeof (struct SWF_ACTIONPUSHPARAM));
+				if (!tmp) {
+					/* RATIONALE: on realloc failure, free any duplicated string to
+					   avoid leaks, then abort parsing to keep state consistent. */
+					if (param->Type == 0 && param->p.String) {
+						free(param->p.String);
+						param->p.String = NULL;
+					}
+					fprintf(stderr, "realloc failed\n");
+					return 0;
+				}
+				act->Params = tmp;
+			}
+		}
+
 		break;
 		}
 	case SWFACTION_LOGICALNOT:
