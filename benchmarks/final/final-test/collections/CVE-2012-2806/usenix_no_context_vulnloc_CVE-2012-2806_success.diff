diff --git a/jdapimin.c b/jdapimin.c
index cadb59fc..d2c0b2d3 100644
--- a/jdapimin.c
+++ b/jdapimin.c
@@ -288,18 +288,64 @@ jpeg_consume_input (j_decompress_ptr cinfo)
 {
   int retcode = JPEG_SUSPENDED;
 
+  /* Defensive checks: ensure required submodules are present before use.
+   * Rationale: some malformed inputs (or incorrect setup) may result in
+   * input controller or source hooks being NULL. Calling through a NULL
+   * function pointer can crash; verifying pointers here prevents that.
+   */
+  if (cinfo == NULL) {
+    return JPEG_SUSPENDED;
+  }
+  if (cinfo->inputctl == NULL || cinfo->src == NULL) {
+    /* No input modules installed: nothing to do. */
+    return JPEG_SUSPENDED;
+  }
+
   /* NB: every possible DSTATE value should be listed in this switch */
   switch (cinfo->global_state) {
   case DSTATE_START:
     /* Start-of-datastream actions: reset appropriate modules */
-    (*cinfo->inputctl->reset_input_controller) (cinfo);
+    if (cinfo->inputctl->reset_input_controller)
+      (*cinfo->inputctl->reset_input_controller) (cinfo);
     /* Initialize application's data source module */
-    (*cinfo->src->init_source) (cinfo);
+    if (cinfo->src->init_source)
+      (*cinfo->src->init_source) (cinfo);
     cinfo->global_state = DSTATE_INHEADER;
-    /*FALLTHROUGH*/
+// FIXME: Crash CWE-787: Out-of-bounds Write (stack-based / CWE-121)
+     /*FALLTHROUGH*/
   case DSTATE_INHEADER:
+    /* Before calling into the input controller, ensure the consume_input
+     * hook is present. This avoids indirect calls through NULL pointers.
+     */
+    if (cinfo->inputctl->consume_input == NULL) {
+      return JPEG_SUSPENDED;
+    }
+
     retcode = (*cinfo->inputctl->consume_input) (cinfo);
+
+    /* If a Start-Of-Scan marker was reached, do basic validation of
+     * the header-derived component count before setting up decompress
+     * parameters. This mitigates out-of-bounds writes in later
+     * SOS/marker processing by rejecting obviously invalid values.
+     *
+     * Rationale: the sanitizer indicated a stack overflow stemming
+     * from malformed marker counts/indices. Validating cinfo->num_components
+     * here prevents proceeding into default_decompress_parms() when
+     * the parsed header is implausible.
+     */
     if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
+      /* Basic sanity checks: num_components should be positive and not
+       * exceed MAX_COMPONENTS. Also, comp_info must be present when
+       * num_components > 0.
+       */
+      if (cinfo->num_components <= 0 || cinfo->num_components > MAX_COMPONENTS ||
+          (cinfo->num_components > 0 && cinfo->comp_info == NULL)) {
+        /* Malformed header: do not proceed. Return suspended to let caller
+         * handle the error or abort parsing gracefully.
+         */
+        return JPEG_SUSPENDED;
+      }
+
       /* Set up default parameters based on header data */
       default_decompress_parms(cinfo);
       /* Set global state: ready for start_decompress */
@@ -326,6 +372,7 @@ jpeg_consume_input (j_decompress_ptr cinfo)
 }
 
 
+
 /*
  * Have we finished reading the input file?
  */
diff --git a/jdmarker.c b/jdmarker.c
index d8dcba98..6769991f 100644
--- a/jdmarker.c
+++ b/jdmarker.c
@@ -245,19 +245,41 @@ get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
 
   cinfo->progressive_mode = is_prog;
   cinfo->arith_code = is_arith;
-
+// FIXME: Crash CWE-787: Out-of-bounds Write (stack-based / CWE-121)
+ 
   INPUT_2BYTES(cinfo, length, return FALSE);
 
+  /* Basic sanity: marker must be at least 8 bytes for the fields we read */
+  if (length < 8)
+    ERREXIT(cinfo, JERR_BAD_LENGTH);
+
   INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
   INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
   INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
   INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
 
+  /* Rationale: ensure num_components is within a safe limit before doing
+   * any arithmetic or allocation that depends on it. This prevents
+   * integer overflow and excessively large allocations leading to
+   * out-of-bounds writes later on.
+   */
+  if (cinfo->num_components <= 0)
+    ERREXIT(cinfo, JERR_EMPTY_IMAGE); /* keep existing check behavior */
+
+  /* Enforce library maximum for components to avoid buffer overflows. */
+  if (cinfo->num_components > MAX_COMPONENTS)
+    ERREXIT(cinfo, JERR_BAD_LENGTH);
+
+  /* Prevent absurdly large component counts that could cause later
+   * arithmetic problems. Using MAX_COMPONENTS avoids relying on INT_MAX
+   * so we don't need to add a new header include here.
+   */
+
   length -= 8;
 
   TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
-	   (int) cinfo->image_width, (int) cinfo->image_height,
-	   cinfo->num_components);
+       (int) cinfo->image_width, (int) cinfo->image_height,
+       cinfo->num_components);
 
   if (cinfo->marker->saw_SOF)
     ERREXIT(cinfo, JERR_SOF_DUPLICATE);
@@ -269,13 +291,15 @@ get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
       || cinfo->num_components <= 0)
     ERREXIT(cinfo, JERR_EMPTY_IMAGE);
 
+  /* Ensure the remaining length matches the expected size (3 bytes per component). */
   if (length != (cinfo->num_components * 3))
     ERREXIT(cinfo, JERR_BAD_LENGTH);
 
-  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
+  /* Allocate component info only once; ensure allocation size is reasonable. */
+  if (cinfo->comp_info == NULL)    /* do only once, even if suspend */
     cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
-			((j_common_ptr) cinfo, JPOOL_IMAGE,
-			 cinfo->num_components * SIZEOF(jpeg_component_info));
+            ((j_common_ptr) cinfo, JPOOL_IMAGE,
+             cinfo->num_components * SIZEOF(jpeg_component_info));
   
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
