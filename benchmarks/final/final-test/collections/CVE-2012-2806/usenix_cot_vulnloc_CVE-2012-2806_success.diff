diff --git a/jdmarker.c b/jdmarker.c
index d8dcba98..27aedeac 100644
--- a/jdmarker.c
+++ b/jdmarker.c
@@ -302,6 +302,17 @@ LOCAL(boolean)
 get_sos (j_decompress_ptr cinfo)
 /* Process a SOS marker */
 {
+  /* Rationale:
+   * Fix for CWE-787 (out-of-bounds write) in SOS parsing.
+   * The SOS marker gives a count 'n' of components in the scan. The code
+   * previously trusted that 'n' would not exceed cinfo->num_components and
+   * proceeded to write into cinfo->cur_comp_info[i] for i in [0..n-1]. If
+   * n > cinfo->num_components this caused writes past the end of the
+   * cur_comp_info array (stack overflow). To fix this we validate that the
+   * parsed 'n' does not exceed cinfo->num_components before performing any
+   * writes. We keep other behavior unchanged and still enforce the existing
+   * maximums and length checks.
+   */
   INT32 length;
   int i, ci, n, c, cc;
   jpeg_component_info * compptr;
@@ -316,13 +327,19 @@ get_sos (j_decompress_ptr cinfo)
 
   TRACEMS1(cinfo, 1, JTRC_SOS, n);
 
-  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)
+  /* Validate that the number of components in the scan is sane and
+   * does not exceed the number of components known for this image.
+   * This prevents subsequent writes to cinfo->cur_comp_info[] from
+   * overflowing the array.
+   */
+  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN || n > cinfo->num_components)
     ERREXIT(cinfo, JERR_BAD_LENGTH);
 
   cinfo->comps_in_scan = n;
 
   /* Collect the component-spec parameters */
-
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 
   for (i = 0; i < cinfo->num_components; i++)
     cinfo->cur_comp_info[i] = NULL;
 
@@ -340,6 +357,9 @@ get_sos (j_decompress_ptr cinfo)
 
   id_found:
 
+    /* At this point 'i' is guaranteed to be < cinfo->num_components because
+     * we validated 'n' above. Assigning is therefore safe.
+     */
     cinfo->cur_comp_info[i] = compptr;
     compptr->dc_tbl_no = (c >> 4) & 15;
     compptr->ac_tbl_no = (c     ) & 15;
@@ -1011,8 +1031,29 @@ read_markers (j_decompress_ptr cinfo)
     case M_SOF15:		/* Differential lossless, arithmetic */
       ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
       break;
-
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 
     case M_SOS:
+      /*
+       * Rationale for modification:
+       * The vulnerability is caused by get_sos reading marker-derived counts
+       * (such as number of components) and writing data into stack-allocated
+       * structures without validating those counts, which can lead to an
+       * 8-byte out-of-bounds write past the end of the local cinfo-related
+       * stack frame. To mitigate this without changing get_sos itself (per
+       * constraints), add a defensive sanity check here before calling
+       * get_sos. If the frame/component information isn't present or the
+       * component count is unreasonable, we safely suspend parsing rather
+       * than invoking get_sos on malformed input.
+       *
+       * Note: We use a conservative upper bound of 10 components (the JPEG
+       * specification and common implementations use a small limit). This
+       * prevents excessively large component counts from triggering the
+       * downstream overflow in get_sos.
+       */
+      if (cinfo->num_components <= 0 || cinfo->num_components > 10)
+	return JPEG_SUSPENDED;
+
       if (! get_sos(cinfo))
 	return JPEG_SUSPENDED;
       cinfo->unread_marker = 0;	/* processed the marker */
