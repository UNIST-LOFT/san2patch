diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..75f643f 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -226,7 +226,8 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         if (block)
         {
             item->zz_usize = ZZIP_GET64(block->z_usize);
-            item->zz_csize = ZZIP_GET64(block->z_csize);
+// FIXME: Crash
+             item->zz_csize = ZZIP_GET64(block->z_csize);
             item->zz_offset = ZZIP_GET64(block->z_offset);
             item->zz_diskstart = ZZIP_GET32(block->z_diskstart);
         }
@@ -250,15 +251,107 @@ error:
 ZZIP_EXTRA_BLOCK *
 zzip_mem_entry_extra_block(ZZIP_MEM_ENTRY * entry, short datatype)
 {
+    /*
+     * Rationale for change:
+     * The original implementation could read beyond the end of the
+     * allocated extra-data buffer when parsing extra blocks (for
+     * example a truncated zip64 extra block). This led to heap-buffer
+     * overflows when callers read fields from the returned block.
+     *
+     * Fix approach:
+     * - Parse the extra-data buffer using byte-wise accesses and
+     *   explicit length checks so we never dereference pointers beyond
+     *   the reported ext length.
+     * - Only return a pointer to an extra block if the block header
+     *   (type + size) and the payload are fully contained within the
+     *   ext buffer, and the payload length is at least large enough
+     *   to hold the minimal expected structure (sizeof(zzip_extra_zip64))
+     *   when a zip64 block is requested. This avoids unsafe reads by
+     *   callers using ZZIP_GET64/ZZIP_GET32 on the returned block.
+     *
+     * This change is local to this function and does not change the
+     * externally visible behavior except that malformed/truncated
+     * extra blocks are safely ignored (NULL returned) instead of
+     * causing an overflow.
+     */
+
     int i = 2;
     while (1)
     {
         char* ext = (char*)( entry->zz_ext[i] );
+        /* If ext is NULL or length is non-positive just move on. */
+        if (!ext || entry->zz_extlen[i] <= 0)
+        {
+            i--;
+            if (i < 0) break;
+            continue;
+        }
+
         char* ext_end = ext + entry->zz_extlen[i];
-        if (ext)
+
+        /*
+         * Walk the extra-data blocks safely. The canonical extra block
+         * header is 4 bytes: 2 bytes type, 2 bytes size (zzip_extra_block_headerlength).
+         * We read these bytes directly using unsigned-char indexing
+         * to avoid any unaligned/oversized dereferences.
+         */
+        while (ext + zzip_extra_block_headerlength <= ext_end)
         {
-            while (ext + zzip_extra_block_headerlength <= ext_end)
+            /* Read block type and size in a safe, byte-wise manner. */
+            unsigned int b0 = (unsigned char)ext[0];
+            unsigned int b1 = (unsigned char)ext[1];
+            unsigned int b2 = (unsigned char)ext[2];
+            unsigned int b3 = (unsigned char)ext[3];
+
+            unsigned short block_type = (unsigned short)(b0 | (b1 << 8));
+            unsigned short block_size = (unsigned short)(b2 | (b3 << 8));
+
+            /* Compute pointer to payload and check bounds before any use. */
+            char *payload = ext + zzip_extra_block_headerlength;
+            char *payload_end;
+
+            /* Ensure payload does not point before ext or beyond ext_end. */
+            if (payload < ext || (size_t)block_size > (size_t)(ext_end - payload))
+            {
+                /* Block declared size would overflow the remaining buffer; stop scanning. */
+                break;
+            }
+
+            payload_end = payload + block_size;
+
+            if ((short)block_type == datatype)
             {
+                /* If caller asks for zip64 ensure payload is at least as
+                 * large as our expected zip64 structure to avoid later
+                 * out-of-bounds reads when using ZZIP_GET64/ZZIP_GET32.
+                 */
+                if (datatype == ZZIP_EXTRA_zip64)
+                {
+                    if ((size_t)block_size >= sizeof(zzip_extra_zip64))
+                    {
+                        return (ZZIP_EXTRA_BLOCK *)ext;
+                    }
+                    else
+                    {
+                        /* Truncated zip64 block: treat as not present */
+                        return 0;
+                    }
+                }
+
+                /* For other datatypes we return the block pointer if fully contained. */
+                return (ZZIP_EXTRA_BLOCK *)ext;
+            }
+
+            /* Move to next block. */
+            ext = payload_end;
+        }
+
+        i--;
+        if (i < 0) break;
+    }
+    return 0;
+}
+
                 if (datatype == zzip_extra_block_get_datatype(ext))
                 {
                     return ((ZZIP_EXTRA_BLOCK*) ext);
