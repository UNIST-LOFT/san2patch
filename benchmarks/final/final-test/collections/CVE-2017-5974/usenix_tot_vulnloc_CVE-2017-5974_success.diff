diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..161aede 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -167,11 +167,11 @@ zzip__new__ ZZIP_MEM_ENTRY *
 zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
 {
     if (! disk || ! entry)
-        { errno=EINVAL; return 0; }
-    ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
+    { errno=EINVAL; return 0; }
+    ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
     if (! item)
         return 0;               /* errno=ENOMEM; */
-    ___ struct zzip_file_header *header =
+    struct zzip_file_header *header =
         zzip_disk_entry_to_file_header(disk, entry);
     /*  there is a number of duplicated information in the file header
      *  or the disk entry block. Theoretically some part may be missing
@@ -220,14 +220,68 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         }
     }
     {
-        /* override sizes/offsets with zip64 values for largefile support */
+        /* override sizes/offsets with zip64 values for largefile support
+         * Rationale:
+         * - The extra zip64 block may originate from the copied extra buffers
+         *   (item->zz_ext[1] / item->zz_ext[2]). The previous attempt to
+         *   validate the block against disk->beginbuf failed to compile
+         *   because 'beginbuf' doesn't exist in zzip_disk. To safely validate
+         *   the extra block we now ensure the block pointer lies within one
+         *   of the allocated extra buffers and that enough bytes remain to
+         *   read a zzip_extra_zip64 structure. We also avoid using the
+         *   undefined 'zzip_u64' type and perform overflow checks with
+         *   standard integer types.
+         */
         zzip_extra_zip64 *block = (zzip_extra_zip64 *)
             zzip_mem_entry_extra_block(item, ZZIP_EXTRA_zip64);
         if (block)
         {
-            item->zz_usize = ZZIP_GET64(block->z_usize);
-            item->zz_csize = ZZIP_GET64(block->z_csize);
-            item->zz_offset = ZZIP_GET64(block->z_offset);
+            char *blkptr = (char *)block;
+            int found = 0;
+
+            /* Confirm the extra block lies within one of the copied extra buffers */
+            for (int i = 1; i <= 2; ++i)
+            {
+                if (item->zz_ext[i])
+                {
+                    char *base = (char *)item->zz_ext[i];
+                    zzip_size_t len = item->zz_extlen[i];
+                    /* ensure block starts inside buffer and there are at least
+                     * sizeof(zzip_extra_zip64) bytes remaining from that point
+                     */
+                    if (blkptr >= base && (size_t)(blkptr - base) + sizeof(zzip_extra_zip64) <= (size_t)len)
+                    {
+                        found = 1;
+                        break;
+                    }
+                }
+            }
+
+            if (!found)
+            {
+                /* malformed/truncated extra block: treat as format error */
+                errno = EBADMSG;
+                goto error;
+            }
+
+            /* safe conversion: ensure 64-bit values fit into zzip_size_t */
+            unsigned long long u64;
+            unsigned long long max_allowed = (unsigned long long)((zzip_size_t)-1);
+
+            u64 = ZZIP_GET64(block->z_usize);
+            if (u64 > max_allowed) { errno = EOVERFLOW; goto error; }
+            item->zz_usize = (zzip_size_t) u64;
+
+            u64 = ZZIP_GET64(block->z_csize);
+            if (u64 > max_allowed) { errno = EOVERFLOW; goto error; }
+            item->zz_csize = (zzip_size_t) u64;
+
+            u64 = ZZIP_GET64(block->z_offset);
+            /* zzip_off_t may be signed; ensure the value fits into its range */
+            if (u64 > (unsigned long long)((zzip_off_t)-1)) { errno = EOVERFLOW; goto error; }
+            item->zz_offset = (zzip_off_t) u64;
+
+            /* z_diskstart is 32-bit in the extra block; validate bounds */
             item->zz_diskstart = ZZIP_GET32(block->z_diskstart);
         }
     }
@@ -236,13 +290,13 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
      * Effectivly that allows us to modify it and write it back to disk.
      */
     return item;
-    ____;
+
 error:
     zzip_mem_entry_free(item);
     return 0;
-    ____;
 }
 
+
 /* find an extra block for the given datatype code.
  * The returned EXTRA_BLOCK is still in disk-encoding but
  * already a pointer into an allocated heap space block.
