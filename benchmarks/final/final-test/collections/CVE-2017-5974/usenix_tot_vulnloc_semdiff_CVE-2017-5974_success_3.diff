diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..0fef9fd 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -165,84 +165,95 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
  */
 zzip__new__ ZZIP_MEM_ENTRY *
 zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
-{
-    if (! disk || ! entry)
-        { errno=EINVAL; return 0; }
-    ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
-    if (! item)
-        return 0;               /* errno=ENOMEM; */
-    ___ struct zzip_file_header *header =
-        zzip_disk_entry_to_file_header(disk, entry);
-    /*  there is a number of duplicated information in the file header
-     *  or the disk entry block. Theoretically some part may be missing
-     *  that exists in the other, ... but we will prefer the disk entry.
-     */
-    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
-    item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
-    item->zz_data = zzip_file_header_to_data(header);
-    item->zz_flags = zzip_disk_entry_get_flags(entry);
-    item->zz_compr = zzip_disk_entry_get_compr(entry);
-    item->zz_mktime = zzip_disk_entry_get_mktime(entry);
-    item->zz_crc32 = zzip_disk_entry_get_crc32(entry);
-    item->zz_csize = zzip_disk_entry_get_csize(entry);
-    item->zz_usize = zzip_disk_entry_get_usize(entry);
-    item->zz_diskstart = zzip_disk_entry_get_diskstart(entry);
-    item->zz_filetype = zzip_disk_entry_get_filetype(entry);
-
-    {   /* copy the extra blocks to memory as well (maximum 64K each) */
-        zzip_size_t /*    */ ext1_len = zzip_disk_entry_get_extras(entry);
-        char *_zzip_restrict ext1_ptr = zzip_disk_entry_to_extras(entry);
-        zzip_size_t /*    */ ext2_len = zzip_file_header_get_extras(header);
-        char *_zzip_restrict ext2_ptr = zzip_file_header_to_extras(header);
-
-        if (ext1_ptr + ext1_len >= disk->endbuf ||
-            ext2_ptr + ext2_len >= disk->endbuf)
-        {
-            errno = EBADMSG; /* format error CVE-2017-5978 */
-            goto error; /* zzip_mem_entry_free(item); return 0; */
-        }
-
-        if (ext1_len)
-        {
-            void *mem = malloc(ext1_len);
-            if (! mem) goto error; /* errno = ENOMEM */
-            item->zz_ext[1] = mem;
-            item->zz_extlen[1] = ext1_len;
-            memcpy(mem, ext1_ptr, ext1_len);
-        }
-        if (ext2_len)
-        {
-            void *mem = malloc(ext2_len);
-            if (! mem) goto error; /* errno = ENOMEM */
-            item->zz_ext[2] = mem;
-            item->zz_extlen[2] = ext2_len;
-            memcpy(mem, ext2_ptr, ext2_len);
-        }
-    }
-    {
-        /* override sizes/offsets with zip64 values for largefile support */
-        zzip_extra_zip64 *block = (zzip_extra_zip64 *)
-            zzip_mem_entry_extra_block(item, ZZIP_EXTRA_zip64);
-        if (block)
-        {
-            item->zz_usize = ZZIP_GET64(block->z_usize);
-            item->zz_csize = ZZIP_GET64(block->z_csize);
-            item->zz_offset = ZZIP_GET64(block->z_offset);
-            item->zz_diskstart = ZZIP_GET32(block->z_diskstart);
-        }
-    }
-    /* NOTE:
-     * All information from the central directory entry is now in memory.
-     * Effectivly that allows us to modify it and write it back to disk.
-     */
-    return item;
-    ____;
+if (! disk || ! entry)
+		{ errno=EINVAL; return 0; }
+	___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
+	if (! item)
+		return 0;               /* errno=ENOMEM; */
+	___ struct zzip_file_header *header =
+		zzip_disk_entry_to_file_header(disk, entry);
+	/*  there is a number of duplicated information in the file header
+	 *  or the disk entry block. Theoretically some part may be missing
+	 *  that exists in the other, ... but we will prefer the disk entry.
+	 */
+	item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
+	item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
+	item->zz_data = zzip_file_header_to_data(header);
+	item->zz_flags = zzip_disk_entry_get_flags(entry);
+	item->zz_compr = zzip_disk_entry_get_compr(entry);
+	item->zz_mktime = zzip_disk_entry_get_mktime(entry);
+	item->zz_crc32 = zzip_disk_entry_get_crc32(entry);
+	item->zz_csize = zzip_disk_entry_get_csize(entry);
+	item->zz_usize = zzip_disk_entry_get_usize(entry);
+	item->zz_diskstart = zzip_disk_entry_get_diskstart(entry);
+	item->zz_filetype = zzip_disk_entry_get_filetype(entry);
+
+	{   /* copy the extra blocks to memory as well (maximum 64K each) */
+		zzip_size_t /*    */ ext1_len = zzip_disk_entry_get_extras(entry);
+		char *_zzip_restrict ext1_ptr = zzip_disk_entry_to_extras(entry);
+// FIXME: Crash CWE-125: Out-of-bounds Read
+		 zzip_size_t /*    */ ext2_len = zzip_file_header_get_extras(header);
+		char *_zzip_restrict ext2_ptr = zzip_file_header_to_extras(header);
+
+		/* Rationale:
+		   Tighten bounds checks by computing the remaining bytes available from
+		   each extras pointer. Ensure that ext1_len and ext2_len both fit and
+		   additionally require that at least 4 extra bytes are available after
+		   ext1_ptr (the downstream code reads up to 4 bytes past ext1 block).
+		   This prevents a 4-byte out-of-bounds read past the allocation.
+		*/
+		{
+		    zzip_size_t rem1 = (ext1_ptr <= disk->endbuf) ? (zzip_size_t)(disk->endbuf - ext1_ptr) : 0;
+		    zzip_size_t rem2 = (ext2_ptr <= disk->endbuf) ? (zzip_size_t)(disk->endbuf - ext2_ptr) : 0;
+		    if (ext1_len > rem1 || ext2_len > rem2 || rem1 < 4 || ext1_len > rem1 - 4)
+		    {
+		        errno = EBADMSG; /* format error CVE-2017-5978 */
+		        goto error; /* zzip_mem_entry_free(item); return 0; */
+		    }
+		}
+
+		if (ext1_len)
+		{
+			void *mem = malloc(ext1_len);
+			if (! mem) goto error; /* errno = ENOMEM */
+			item->zz_ext[1] = mem;
+			item->zz_extlen[1] = ext1_len;
+			memcpy(mem, ext1_ptr, ext1_len);
+		}
+		if (ext2_len)
+		{
+			void *mem = malloc(ext2_len);
+			if (! mem) goto error; /* errno = ENOMEM */
+			item->zz_ext[2] = mem;
+			item->zz_extlen[2] = ext2_len;
+			memcpy(mem, ext2_ptr, ext2_len);
+		}
+	}
+	{
+		/* override sizes/offsets with zip64 values for largefile support */
+		zzip_extra_zip64 *block = (zzip_extra_zip64 *)
+			zzip_mem_entry_extra_block(item, ZZIP_EXTRA_zip64);
+		if (block)
+		{
+			item->zz_usize = ZZIP_GET64(block->z_usize);
+			item->zz_csize = ZZIP_GET64(block->z_csize);
+			item->zz_offset = ZZIP_GET64(block->z_offset);
+			item->zz_diskstart = ZZIP_GET32(block->z_diskstart);
+		}
+	}
+	/* NOTE:
+	 * All information from the central directory entry is now in memory.
+	 * Effectivly that allows us to modify it and write it back to disk.
+	 */
+	return item;
+	____;
 error:
-    zzip_mem_entry_free(item);
-    return 0;
-    ____;
+	zzip_mem_entry_free(item);
+	return 0;
+	____;
 }
 
+
 /* find an extra block for the given datatype code.
  * The returned EXTRA_BLOCK is still in disk-encoding but
  * already a pointer into an allocated heap space block.
