diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..331b68c 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -195,23 +195,54 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         zzip_size_t /*    */ ext2_len = zzip_file_header_get_extras(header);
         char *_zzip_restrict ext2_ptr = zzip_file_header_to_extras(header);
 
-        if (ext1_ptr + ext1_len >= disk->endbuf ||
-            ext2_ptr + ext2_len >= disk->endbuf)
+        /* Rationale for changes:
+         * - Validate archive-derived lengths to avoid integer wraparound and
+         *   to ensure we do not read past the disk buffer (prevent OOB read).
+         * - Enforce a reasonable maximum for extra blocks (ZIP extra field
+         *   entries are limited in practice; use 0xFFFF as an upper bound).
+         * - Perform per-pointer bound checks using (disk->endbuf - ptr) to
+         *   guarantee the available space is at least the requested length.
+         * - Only allocate after all validations succeed to avoid allocating
+         *   based on malformed lengths.
+         */
+        const zzip_size_t MAX_EXTRA = 0xFFFF;
+
+        /* Quick reject if sizes exceed policy limits */
+        if (ext1_len > MAX_EXTRA || ext2_len > MAX_EXTRA)
         {
-            errno = EBADMSG; /* format error CVE-2017-5978 */
-            goto error; /* zzip_mem_entry_free(item); return 0; */
+            errno = EBADMSG; /* format error */
+            goto error;
         }
 
+        /* Per-extra bounds checks. Check pointer validity and available
+         * space before any allocation or memcpy. Check ptr >= endbuf first
+         * to avoid underflow in the subtraction below.
+         */
         if (ext1_len)
         {
+            if (!ext1_ptr || ext1_ptr >= disk->endbuf ||
+                ext1_len > (zzip_size_t)(disk->endbuf - ext1_ptr))
+            {
+                errno = EBADMSG; /* format error */
+                goto error;
+            }
+
             void *mem = malloc(ext1_len);
             if (! mem) goto error; /* errno = ENOMEM */
             item->zz_ext[1] = mem;
             item->zz_extlen[1] = ext1_len;
             memcpy(mem, ext1_ptr, ext1_len);
         }
+
         if (ext2_len)
         {
+            if (!ext2_ptr || ext2_ptr >= disk->endbuf ||
+                ext2_len > (zzip_size_t)(disk->endbuf - ext2_ptr))
+            {
+                errno = EBADMSG; /* format error */
+                goto error;
+            }
+
             void *mem = malloc(ext2_len);
             if (! mem) goto error; /* errno = ENOMEM */
             item->zz_ext[2] = mem;
