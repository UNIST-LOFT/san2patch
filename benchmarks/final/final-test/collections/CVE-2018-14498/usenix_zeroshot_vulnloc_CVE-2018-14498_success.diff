diff --git a/rdbmp.c b/rdbmp.c
index 6b73f7c0..10a4a026 100644
--- a/rdbmp.c
+++ b/rdbmp.c
@@ -132,15 +132,31 @@ get_8bit_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   register JDIMENSION col;
 
   /* Fetch next row from virtual array */
+  /* Rationale: prevent underflow of source->source_row. Decrementing an
+   * unsigned row counter when it is zero causes a very large index to be
+   * passed to access_virt_sarray, which can return an invalid pointer and
+   * lead to heap-buffer-overflow when the row is read. We check for the
+   * zero-case and return 0 (no more rows). Also defensively check the
+   * returned pointers to avoid dereferencing NULL/wild pointers.
+   */
+  if (source->source_row == 0)
+    return 0;
   source->source_row--;
   image_ptr = (*cinfo->mem->access_virt_sarray)
     ((j_common_ptr) cinfo, source->whole_image,
      source->source_row, (JDIMENSION) 1, FALSE);
+  if (image_ptr == NULL)
+    return 0;
 
   /* Expand the colormap indexes to real data */
+  if (colormap == NULL) /* defensive: colormap must exist for 8-bit images */
+    return 0;
   inptr = image_ptr[0];
+  if (inptr == NULL)
+    return 0;
   outptr = source->pub.buffer[0];
-  for (col = cinfo->image_width; col > 0; col--) {
+// FIXME: Crash
+   for (col = cinfo->image_width; col > 0; col--) {
     t = GETJSAMPLE(*inptr++);
     *outptr++ = colormap[0][t]; /* can omit GETJSAMPLE() safely */
     *outptr++ = colormap[1][t];
@@ -161,15 +177,24 @@ get_24bit_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   register JDIMENSION col;
 
   /* Fetch next row from virtual array */
+  /* Rationale: same underflow protection as in get_8bit_row to avoid
+   * passing an invalid row index to access_virt_sarray.
+   */
+  if (source->source_row == 0)
+    return 0;
   source->source_row--;
   image_ptr = (*cinfo->mem->access_virt_sarray)
     ((j_common_ptr) cinfo, source->whole_image,
      source->source_row, (JDIMENSION) 1, FALSE);
+  if (image_ptr == NULL)
+    return 0;
 
   /* Transfer data.  Note source values are in BGR order
    * (even though Microsoft's own documents say the opposite).
    */
   inptr = image_ptr[0];
+  if (inptr == NULL)
+    return 0;
   outptr = source->pub.buffer[0];
   for (col = cinfo->image_width; col > 0; col--) {
     outptr[2] = *inptr++;       /* can omit GETJSAMPLE() safely */
@@ -265,7 +290,8 @@ preload_image (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
     ERREXIT(cinfo, JERR_BMP_BADDEPTH);
   }
   source->source_row = cinfo->image_height;
-
+// FIXME: Crash
+ 
   /* And read the first row */
   return (*source->pub.get_pixel_rows) (cinfo, sinfo);
 }
@@ -299,6 +325,48 @@ start_input_bmp (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
   int bPad;
   JDIMENSION row_width;
 
+/*
+Rationale for modification:
+- The original code set source->source_row = cinfo->image_height before reading the first row
+  which can be incorrect for BMP files because biHeight's sign indicates row order (bottom-up
+  when positive, top-down when negative). Using cinfo->image_height directly can lead to out-of-
+  bounds accesses in get_*bit_row implementations (heap-buffer-overflow observed).
+
+- Fix: determine the correct starting source->source_row based on the sign of biHeight:
+    * If biHeight > 0 (bottom-up BMP), start at the last row: image_height - 1.
+    * Otherwise (top-down BMP or zero), start at row 0.
+  This avoids underflow/overflow when the get_pixel_rows functions index into the virtual array.
+
+- Additional sanity checks: ensure image_height is non-zero and that the get_pixel_rows
+  function pointer and the virtual whole_image buffer are present before attempting to read
+  the first row. If a condition is invalid, call ERREXIT to report the error.
+*/
+
+  /* Determine starting source_row based on BMP orientation and validate state */
+  if (cinfo->image_height == 0) {
+    /* No rows to read -- invalid image */
+    ERREXIT(cinfo, JERR_BMP_BADDEPTH);
+  }
+
+  /* biHeight is declared above; its sign indicates row order in BMP files. */
+  if (biHeight > 0) {
+    /* bottom-up BMP: start from the last row */
+    source->source_row = (JDIMENSION) (cinfo->image_height - 1);
+  } else {
+    /* top-down BMP: start from the first row */
+    source->source_row = (JDIMENSION) 0;
+  }
+
+  /* Ensure the get_pixel_rows handler and the backing store are available */
+  if (source->pub.get_pixel_rows == NULL)
+    ERREXIT(cinfo, JERR_BMP_BADDEPTH);
+  if (source->whole_image == NULL)
+    ERREXIT(cinfo, JERR_BMP_BADDEPTH);
+
+  /* And read the first row */
+  return (*source->pub.get_pixel_rows) (cinfo, sinfo);
+
+
   /* Read and verify the bitmap file header */
   if (! ReadOK(source->pub.input_file, bmpfileheader, 14))
     ERREXIT(cinfo, JERR_INPUT_EOF);
