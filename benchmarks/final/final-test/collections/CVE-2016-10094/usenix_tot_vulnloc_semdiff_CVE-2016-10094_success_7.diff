diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..836b8ac6 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2894,33 +2894,57 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 				t2p->t2p_error = T2P_ERR_ERROR;
 				return(0);
 			}
-			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
+			if (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
+				/* Rationale: Prevent buffer overflow by validating that the number of
+				   bytes to copy (count - 2) fits into the remaining allocated buffer
+				   (t2p->tiff_datasize - bufferoffset). If it does not fit, fail
+				   safely to avoid any out-of-bounds write. Also validate the raw
+				   tile read does not exceed remaining space. */
 				if (count >= 4) {
-                                        int retTIFFReadRawTile;
-                    /* Ignore EOI marker of JpegTables */
+					int retTIFFReadRawTile;
+					/* Ignore EOI marker of JpegTables */
+					/* Validate copy size to avoid overflow */
+					{
+						u_int64_t need = (u_int64_t)(count - 2);
+						u_int64_t available = (u_int64_t)t2p->tiff_datasize;
+						if (available < (u_int64_t)bufferoffset || need > (available - (u_int64_t)bufferoffset)) {
+							/* Not enough space to copy JpegTables - fail safely */
+							_TIFFfree(buffer);
+							t2p->t2p_error = T2P_ERR_ERROR;
+							return (0);
+						}
+					}
 					_TIFFmemcpy(buffer, jpt, count - 2);
 					bufferoffset += count - 2;
-                    /* Store last 2 bytes of the JpegTables */
-					table_end[0] = buffer[bufferoffset-2];
-					table_end[1] = buffer[bufferoffset-1];
+					/* Store last 2 bytes of the JpegTables */
+					table_end[0] = buffer[bufferoffset - 2];
+					table_end[1] = buffer[bufferoffset - 1];
 					xuint32 = bufferoffset;
-                                        bufferoffset -= 2;
-                                        retTIFFReadRawTile= TIFFReadRawTile(
-						input, 
-						tile, 
-						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
+					bufferoffset -= 2;
+					retTIFFReadRawTile = TIFFReadRawTile(
+						input,
+						tile,
+						(tdata_t)&(((unsigned char *)buffer)[bufferoffset]),
 						-1);
-                                        if( retTIFFReadRawTile < 0 )
-                                        {
-                                            _TIFFfree(buffer);
-                                            t2p->t2p_error = T2P_ERR_ERROR;
-                                            return(0);
-                                        }
+					if (retTIFFReadRawTile < 0) {
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return (0);
+					}
+					/* Ensure the raw tile read did not overflow the buffer */
+					{
+						u_int64_t available_after = (u_int64_t)t2p->tiff_datasize - (u_int64_t)bufferoffset;
+						if ((u_int64_t)retTIFFReadRawTile > available_after) {
+							_TIFFfree(buffer);
+							t2p->t2p_error = T2P_ERR_ERROR;
+							return (0);
+						}
+					}
 					bufferoffset += retTIFFReadRawTile;
-                    /* Overwrite SOI marker of image scan with previously */
-                    /* saved end of JpegTables */
-					buffer[xuint32-2]=table_end[0];
-					buffer[xuint32-1]=table_end[1];
+					/* Overwrite SOI marker of image scan with previously */
+					/* saved end of JpegTables */
+					buffer[xuint32 - 2] = table_end[0];
+					buffer[xuint32 - 1] = table_end[1];
 				}
 			}
 			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
