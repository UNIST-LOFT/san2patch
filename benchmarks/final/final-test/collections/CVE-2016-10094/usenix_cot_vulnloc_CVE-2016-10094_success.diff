diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..18dd8787 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2881,52 +2881,87 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 		}
 #endif
 #ifdef JPEG_SUPPORT
-		if(t2p->tiff_compression == COMPRESSION_JPEG){
-			unsigned char table_end[2];
-			uint32 count = 0;
-			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
-			if(buffer==NULL){
-				TIFFError(TIFF2PDF_MODULE, 
-					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory "
+if(t2p->tiff_compression == COMPRESSION_JPEG){
+		unsigned char table_end[2];
+		uint32 count = 0;
+		buffer= (unsigned char*) _TIFFmalloc((t2p->tiff_datasize) + 2);
+		if(buffer==NULL){
+			TIFFError(TIFF2PDF_MODULE, 
+				"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory "
                                         "for t2p_readwrite_pdf_image_tile, %s", 
-                                          (TIFF_SIZE_T) t2p->tiff_datasize, 
-					TIFFFileName(input));
-				t2p->t2p_error = T2P_ERR_ERROR;
-				return(0);
-			}
-			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
-				if (count >= 4) {
-                                        int retTIFFReadRawTile;
-                    /* Ignore EOI marker of JpegTables */
-					_TIFFmemcpy(buffer, jpt, count - 2);
-					bufferoffset += count - 2;
-                    /* Store last 2 bytes of the JpegTables */
-					table_end[0] = buffer[bufferoffset-2];
-					table_end[1] = buffer[bufferoffset-1];
-					xuint32 = bufferoffset;
-                                        bufferoffset -= 2;
-                                        retTIFFReadRawTile= TIFFReadRawTile(
+                                          (TIFF_SIZE_T) (t2p->tiff_datasize + 2), 
+				TIFFFileName(input));
+			t2p->t2p_error = T2P_ERR_ERROR;
+			return(0);
+		}
+		/* Ensure bufferoffset starts from the OJPEG data length as in other paths */
+		bufferoffset = t2p->pdf_ojpegdatalength;
+		if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
+			if (count >= 4) {
+				size_t copy_len = (size_t)count - 2;
+				/* Ensure we won't copy more than the allocated buffer (minus the 2 extra bytes)
+				 * The buffer was allocated with +2 bytes to allow room for EOI/table_end bytes.
+				 */
+				if (copy_len > (size_t)t2p->tiff_datasize) {
+					_TIFFfree(buffer);
+					TIFFError(TIFF2PDF_MODULE,
+						"JpegTables size is larger than allocated buffer in t2p_readwrite_pdf_image_tile, %s",
+						TIFFFileName(input));
+					t2p->t2p_error = T2P_ERR_ERROR;
+					return(0);
+				}
+				/* Safe copy of JpegTables except the last 2 bytes (EOI) */
+				_TIFFmemcpy(buffer, jpt, copy_len);
+				bufferoffset += (uint32)copy_len;
+				/* Store last 2 bytes of the JpegTables */
+				if (bufferoffset < 2) {
+					/* Unexpected state, protect against underflow */
+					_TIFFfree(buffer);
+					t2p->t2p_error = T2P_ERR_ERROR;
+					return(0);
+				}
+				table_end[0] = buffer[bufferoffset-2];
+				table_end[1] = buffer[bufferoffset-1];
+				xuint32 = bufferoffset;
+				/* Make room for the tile data to overwrite the last two bytes (EOI)
+				 * and ensure we don't ask TIFFReadRawTile to write more than the
+				 * remaining buffer space.
+				 */
+				bufferoffset -= 2;
+				{
+					size_t remaining = (size_t)((t2p->tiff_datasize + 2) - bufferoffset);
+					int retTIFFReadRawTile;
+					if (remaining <= 0) {
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
+					/* Read at most the remaining buffer size to avoid overflow */
+					retTIFFReadRawTile= TIFFReadRawTile(
 						input, 
 						tile, 
 						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-						-1);
-                                        if( retTIFFReadRawTile < 0 )
-                                        {
-                                            _TIFFfree(buffer);
-                                            t2p->t2p_error = T2P_ERR_ERROR;
-                                            return(0);
-                                        }
-					bufferoffset += retTIFFReadRawTile;
-                    /* Overwrite SOI marker of image scan with previously */
-                    /* saved end of JpegTables */
-					buffer[xuint32-2]=table_end[0];
-					buffer[xuint32-1]=table_end[1];
+						(tsize_t)remaining);
+					if( retTIFFReadRawTile < 0 )
+					{
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
+					/* Protect against unexpected larger return values */
+					if ((size_t)retTIFFReadRawTile > (size_t)remaining) {
+						retTIFFReadRawTile = (int)remaining;
+					}
+					bufferoffset += (uint32)retTIFFReadRawTile;
 				}
 			}
-			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
-			_TIFFfree(buffer);
-			return(bufferoffset);
 		}
+
+		t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
+		_TIFFfree(buffer);
+		return(bufferoffset);
+	}
+
 #endif
 		(void)0;
 	}
