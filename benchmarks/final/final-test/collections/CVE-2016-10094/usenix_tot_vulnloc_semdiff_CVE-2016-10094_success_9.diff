diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..929d993b 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2895,34 +2895,64 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 				return(0);
 			}
 			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
+				/* Rationale: Ensure JpegTables pointer and lengths do not cause buffer overflow.
+				   Compute copy length in size_t and validate against t2p->tiff_datasize and bufferoffset
+				   to avoid writing past the allocated buffer. If checks fail, free buffer and abort.
+				*/
+				if (jpt == NULL) {
+					_TIFFfree(buffer);
+					t2p->t2p_error = T2P_ERR_ERROR;
+					return(0);
+				}
 				if (count >= 4) {
-                                        int retTIFFReadRawTile;
-                    /* Ignore EOI marker of JpegTables */
+					size_t cpylen = (size_t)(count - 2);
+					/* validate tiff_datasize is positive and that bufferoffset + cpylen won't overflow/overrun */
+					if (t2p->tiff_datasize <= 0 || (size_t)bufferoffset > (size_t)t2p->tiff_datasize || cpylen > (size_t)t2p->tiff_datasize - (size_t)bufferoffset) {
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
+					int retTIFFReadRawTile;
+					/* Ignore EOI marker of JpegTables */
 					_TIFFmemcpy(buffer, jpt, count - 2);
 					bufferoffset += count - 2;
-                    /* Store last 2 bytes of the JpegTables */
+					/* Store last 2 bytes of the JpegTables */
+					/* ensure we have at least 2 bytes offset to read/write */
+					if ((size_t)bufferoffset < 2 || (size_t)bufferoffset - 2 >= (size_t)t2p->tiff_datasize) {
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
 					table_end[0] = buffer[bufferoffset-2];
 					table_end[1] = buffer[bufferoffset-1];
 					xuint32 = bufferoffset;
-                                        bufferoffset -= 2;
-                                        retTIFFReadRawTile= TIFFReadRawTile(
+					bufferoffset -= 2;
+					retTIFFReadRawTile= TIFFReadRawTile(
 						input, 
 						tile, 
 						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
 						-1);
-                                        if( retTIFFReadRawTile < 0 )
-                                        {
-                                            _TIFFfree(buffer);
-                                            t2p->t2p_error = T2P_ERR_ERROR;
-                                            return(0);
-                                        }
+					if( retTIFFReadRawTile < 0 )
+					{
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
+					/* ensure the tile data we just read doesn't overflow buffer */
+					if ((size_t)retTIFFReadRawTile > (size_t)t2p->tiff_datasize - (size_t)bufferoffset) {
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
 					bufferoffset += retTIFFReadRawTile;
-                    /* Overwrite SOI marker of image scan with previously */
-                    /* saved end of JpegTables */
+					/* Overwrite SOI marker of image scan with previously */
+					/* saved end of JpegTables */
+					/* xuint32 was validated to be >= 2 above */
 					buffer[xuint32-2]=table_end[0];
 					buffer[xuint32-1]=table_end[1];
 				}
 			}
+
 			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
 			_TIFFfree(buffer);
 			return(bufferoffset);
