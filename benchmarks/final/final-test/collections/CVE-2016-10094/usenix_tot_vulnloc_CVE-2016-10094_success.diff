diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..1cb31d57 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2896,32 +2896,66 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 			}
 			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
 				if (count >= 4) {
-                                        int retTIFFReadRawTile;
+/* Rationale: Validate sizes and ensure we never copy more bytes than the allocated buffer (t2p->tiff_datasize). Bail out on any inconsistency to avoid heap overflow. Use size_t arithmetic and explicit bounds checks before performing the memcpy and before consuming TIFFReadRawTile bytes. */
+                                         int retTIFFReadRawTile;
                     /* Ignore EOI marker of JpegTables */
-					_TIFFmemcpy(buffer, jpt, count - 2);
-					bufferoffset += count - 2;
+{
+    size_t desired_copy;
+    size_t remaining;
+
+    /* Defensive check: ensure count is non-negative and large enough (count >= 4 ensured by outer if)
+       Compute desired_copy = count - 2 as size_t (safe because count >= 4) */
+    desired_copy = (size_t)count - 2U;
+
+    /* Calculate remaining space in the allocated buffer. If bufferoffset is already beyond
+       the allocation, treat as error. */
+    if ((size_t)t2p->tiff_datasize <= (size_t)bufferoffset) {
+        _TIFFfree(buffer);
+        t2p->t2p_error = T2P_ERR_ERROR;
+        return(0);
+    }
+    remaining = (size_t)t2p->tiff_datasize - (size_t)bufferoffset;
+
+    /* If desired_copy doesn't fit, fail safely (do not truncate silently) */
+    if (desired_copy > remaining) {
+        _TIFFfree(buffer);
+        t2p->t2p_error = T2P_ERR_ERROR;
+        return(0);
+    }
+
+    /* Safe copy: will not overflow because we checked desired_copy <= remaining */
+    _TIFFmemcpy(buffer, jpt, desired_copy);
+    bufferoffset += (tsize_t)desired_copy;
+}
                     /* Store last 2 bytes of the JpegTables */
-					table_end[0] = buffer[bufferoffset-2];
-					table_end[1] = buffer[bufferoffset-1];
-					xuint32 = bufferoffset;
+				table_end[0] = buffer[bufferoffset-2];
+				table_end[1] = buffer[bufferoffset-1];
+				xuint32 = bufferoffset;
                                         bufferoffset -= 2;
                                         retTIFFReadRawTile= TIFFReadRawTile(
-						input, 
-						tile, 
-						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-						-1);
+					input, 
+					tile, 
+					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
+					-1);
                                         if( retTIFFReadRawTile < 0 )
                                         {
                                             _TIFFfree(buffer);
                                             t2p->t2p_error = T2P_ERR_ERROR;
                                             return(0);
                                         }
-					bufferoffset += retTIFFReadRawTile;
+    /* Ensure the data read by TIFFReadRawTile will not overflow the buffer */
+    if ((size_t)bufferoffset + (size_t)retTIFFReadRawTile > (size_t)t2p->tiff_datasize) {
+        _TIFFfree(buffer);
+        t2p->t2p_error = T2P_ERR_ERROR;
+        return(0);
+    }
+				bufferoffset += retTIFFReadRawTile;
                     /* Overwrite SOI marker of image scan with previously */
                     /* saved end of JpegTables */
-					buffer[xuint32-2]=table_end[0];
-					buffer[xuint32-1]=table_end[1];
-				}
+				buffer[xuint32-2]=table_end[0];
+				buffer[xuint32-1]=table_end[1];
+			}
+
 			}
 			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
 			_TIFFfree(buffer);
