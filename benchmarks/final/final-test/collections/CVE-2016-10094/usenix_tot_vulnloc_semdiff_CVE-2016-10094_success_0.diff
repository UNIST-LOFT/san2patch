diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..a716387f 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2898,6 +2898,16 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 				if (count >= 4) {
                                         int retTIFFReadRawTile;
                     /* Ignore EOI marker of JpegTables */
+                    /* Rationale: Validate that the destination buffer has enough
+                       space before copying to prevent heap-buffer-overflow. If
+                       the buffer is too small or NULL, free and fail safely. */
+					if (buffer == NULL || t2p->tiff_datasize == 0 ||
+					    bufferoffset > t2p->tiff_datasize ||
+					    (size_t)bufferoffset + (size_t)(count - 2) > t2p->tiff_datasize) {
+					    _TIFFfree(buffer);
+					    t2p->t2p_error = T2P_ERR_ERROR;
+					    return(0);
+					}
 					_TIFFmemcpy(buffer, jpt, count - 2);
 					bufferoffset += count - 2;
                     /* Store last 2 bytes of the JpegTables */
@@ -2906,10 +2916,10 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 					xuint32 = bufferoffset;
                                         bufferoffset -= 2;
                                         retTIFFReadRawTile= TIFFReadRawTile(
-						input, 
-						tile, 
-						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-						-1);
+					input, 
+					tile, 
+					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
+					-1);
                                         if( retTIFFReadRawTile < 0 )
                                         {
                                             _TIFFfree(buffer);
@@ -2923,6 +2933,7 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 					buffer[xuint32-1]=table_end[1];
 				}
 			}
+
 			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
 			_TIFFfree(buffer);
 			return(bufferoffset);
