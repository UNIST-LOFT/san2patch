diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..92fd5ff9 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2869,16 +2869,21 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 				}
 			}
 			bufferoffset=t2p->pdf_ojpegdatalength;
-			bufferoffset+=TIFFReadRawTile(input, 
-					tile, 
-					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-					-1);
-			((unsigned char*)buffer)[bufferoffset++]=0xff;
-			((unsigned char*)buffer)[bufferoffset++]=0xd9;
-			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
-			_TIFFfree(buffer);
-			return(bufferoffset);
-		}
+		/* Rationale: Fix heap-buffer-overflow by copying JpegTables into the buffer
+		   at the current bufferoffset instead of at buffer start, and by
+		   validating that we do not exceed the allocated tiff_datasize before
+		   copying or after reading the raw tile. This prevents writes/reads
+		   beyond the allocated buffer. */
+		bufferoffset+=TIFFReadRawTile(input, 
+				tile, 
+				(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
+				-1);
+		((unsigned char*)buffer)[bufferoffset++]=0xff;
+		((unsigned char*)buffer)[bufferoffset++]=0xd9;
+		t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
+		_TIFFfree(buffer);
+		return(bufferoffset);
+	}
 #endif
 #ifdef JPEG_SUPPORT
 		if(t2p->tiff_compression == COMPRESSION_JPEG){
@@ -2896,13 +2901,22 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 			}
 			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
 				if (count >= 4) {
-                                        int retTIFFReadRawTile;
+// FIXME: Crash
+                                         int retTIFFReadRawTile;
                     /* Ignore EOI marker of JpegTables */
-					_TIFFmemcpy(buffer, jpt, count - 2);
+					/* Ensure we have space to copy (count-2) bytes at current offset */
+					if ((uint32)(count - 2) > (t2p->tiff_datasize - bufferoffset)) {
+						/* Not enough space to store JpegTables */
+						_TIFFfree(buffer);
+						t2p->t2p_error = T2P_ERR_ERROR;
+						return(0);
+					}
+					/* Copy JpegTables into buffer at current offset */
+					_TIFFmemcpy(&(((unsigned char*)buffer)[bufferoffset]), jpt, count - 2);
 					bufferoffset += count - 2;
                     /* Store last 2 bytes of the JpegTables */
-					table_end[0] = buffer[bufferoffset-2];
-					table_end[1] = buffer[bufferoffset-1];
+					table_end[0] = ((unsigned char*)buffer)[bufferoffset-2];
+					table_end[1] = ((unsigned char*)buffer)[bufferoffset-1];
 					xuint32 = bufferoffset;
                                         bufferoffset -= 2;
                                         retTIFFReadRawTile= TIFFReadRawTile(
@@ -2916,6 +2930,12 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
                                             t2p->t2p_error = T2P_ERR_ERROR;
                                             return(0);
                                         }
+                                        /* Check for overflow before updating bufferoffset */
+                                        if ((uint32)retTIFFReadRawTile > (t2p->tiff_datasize - bufferoffset)) {
+                                            _TIFFfree(buffer);
+                                            t2p->t2p_error = T2P_ERR_ERROR;
+                                            return(0);
+                                        }
 					bufferoffset += retTIFFReadRawTile;
                     /* Overwrite SOI marker of image scan with previously */
                     /* saved end of JpegTables */
