diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 47d76298..380ca800 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -2895,34 +2895,52 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_
 				return(0);
 			}
 			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
-				if (count >= 4) {
+					if (count >= 4) {
                                         int retTIFFReadRawTile;
+                    /* Rationale: validate copy size against allocated destination (t2p->tiff_datasize) to avoid overflow.
+                       Ensure we don't copy more JpegTables bytes than the buffer can hold and limit TIFFReadRawTile to remaining space. */
+                    size_t jt_copy = (count > 2) ? (size_t)(count - 2) : 0;
+                    if (jt_copy == 0 || jt_copy > (size_t)t2p->tiff_datasize) {
+                        _TIFFfree(buffer);
+                        t2p->t2p_error = T2P_ERR_ERROR;
+                        return(0);
+                    }
                     /* Ignore EOI marker of JpegTables */
-					_TIFFmemcpy(buffer, jpt, count - 2);
-					bufferoffset += count - 2;
+				_TIFFmemcpy(buffer, jpt, count - 2);
+				bufferoffset += count - 2;
                     /* Store last 2 bytes of the JpegTables */
-					table_end[0] = buffer[bufferoffset-2];
-					table_end[1] = buffer[bufferoffset-1];
-					xuint32 = bufferoffset;
+				table_end[0] = buffer[bufferoffset-2];
+				table_end[1] = buffer[bufferoffset-1];
+				xuint32 = bufferoffset;
                                         bufferoffset -= 2;
-                                        retTIFFReadRawTile= TIFFReadRawTile(
+                                        /* Limit raw tile read to remaining buffer space to prevent overflow */
+                                        {
+                                            size_t remaining = (t2p->tiff_datasize > (size_t)bufferoffset) ? (size_t)(t2p->tiff_datasize - (size_t)bufferoffset) : 0;
+                                            if (remaining == 0) {
+                                                _TIFFfree(buffer);
+                                                t2p->t2p_error = T2P_ERR_ERROR;
+                                                return(0);
+                                            }
+                                            retTIFFReadRawTile= TIFFReadRawTile(
 						input, 
 						tile, 
 						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-						-1);
+						(tsize_t)remaining);
+                                        }
                                         if( retTIFFReadRawTile < 0 )
                                         {
                                             _TIFFfree(buffer);
                                             t2p->t2p_error = T2P_ERR_ERROR;
                                             return(0);
                                         }
-					bufferoffset += retTIFFReadRawTile;
+				bufferoffset += retTIFFReadRawTile;
                     /* Overwrite SOI marker of image scan with previously */
                     /* saved end of JpegTables */
-					buffer[xuint32-2]=table_end[0];
-					buffer[xuint32-1]=table_end[1];
-				}
+				buffer[xuint32-2]=table_end[0];
+				buffer[xuint32-1]=table_end[1];
 			}
+		}
+
 			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
 			_TIFFfree(buffer);
 			return(bufferoffset);
