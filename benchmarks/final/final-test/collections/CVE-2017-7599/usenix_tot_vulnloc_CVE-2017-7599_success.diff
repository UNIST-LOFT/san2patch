diff --git a/libtiff/tif_dirwrite.c b/libtiff/tif_dirwrite.c
index c9e871be..5d8285fa 100644
--- a/libtiff/tif_dirwrite.c
+++ b/libtiff/tif_dirwrite.c
@@ -576,28 +576,72 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 					uint16* nb;
 					TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);
 					if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))
-						goto bad;
-				}
-			}
-			if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))
-			{
-				if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))
-					goto bad;
-			}
-			if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))
-			{
-				if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))
-					goto bad;
-			}
-			if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))
-			{
-				if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))
-					goto bad;
-			}
-			if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))
-			{
-				if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))
-					goto bad;
+                        goto bad;
+                }
+            }
+            if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))
+            {
+                if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))
+                    goto bad;
+            }
+    // Hardened: validate sample min/max values before attempting conversions/writes.
+    // Rationale: Prevent unchecked narrowing and invalid floating->integer conversions
+    // (CWE-197/CWE-681). We explicitly check finiteness and ranges for each
+    // per-sample value and fail the directory write if any value is invalid,
+    // avoiding implementation-defined/undefined behavior from blind casts.
+            if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))
+            {
+                /* Ensure prototypes/macros for floating checks and integer limits are available. */
+                #include <math.h>
+                #include <stdint.h>
+
+                int valid = 1;
+                int i;
+                int spp = (int)tif->tif_dir.td_samplesperpixel;
+                double *smin = tif->tif_dir.td_sminsamplevalue;
+                if (smin == NULL || spp <= 0)
+                    valid = 0;
+                else {
+                    for (i = 0; i < spp; i++) {
+                        double v = smin[i];
+                        /* reject NaN/Inf */
+                        if (!isfinite(v)) { valid = 0; break; }
+                        /* require values to fit in signed 16-bit to avoid truncation */
+                        if (v < (double)INT16_MIN || v > (double)INT16_MAX) { valid = 0; break; }
+                    }
+                }
+                if (!valid) goto bad;
+                if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))
+                    goto bad;
+            }
+            if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))
+            {
+                /* Ensure prototypes/macros for floating checks and integer limits are available. */
+                #include <math.h>
+                #include <stdint.h>
+
+                int valid = 1;
+                int i;
+                int spp = (int)tif->tif_dir.td_samplesperpixel;
+                double *smax = tif->tif_dir.td_smaxsamplevalue;
+                if (smax == NULL || spp <= 0)
+                    valid = 0;
+                else {
+                    for (i = 0; i < spp; i++) {
+                        double v = smax[i];
+                        /* reject NaN/Inf */
+                        if (!isfinite(v)) { valid = 0; break; }
+                        /* require values to fit in signed 16-bit to avoid truncation */
+                        if (v < (double)INT16_MIN || v > (double)INT16_MAX) { valid = 0; break; }
+                    }
+                }
+                if (!valid) goto bad;
+                if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))
+                    goto bad;
+            }
+            if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))
+            {
+                if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))					goto bad;
 			}
 			if (TIFFFieldSet(tif,FIELD_TILEDEPTH))
 			{
@@ -2094,40 +2138,77 @@ TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* d
 static int
 TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
 {
+        /* Make sure math prototypes and fixed-width integer limits are available. */
+        #include <math.h>
+        #include <stdint.h>
+
         static const char module[] = "TIFFWriteDirectoryTagCheckedRational";
-	uint32 m[2];
-	assert(sizeof(uint32)==4);
-        if( value < 0 )
+    uint32 m[2];
+    assert(sizeof(uint32)==4);
+    /* Rationale:
+       - Defend against NaN/Inf and out-of-range values before any cast.
+       - Do explicit range checks against the 32-bit unsigned limits (0..0xFFFFFFFF).
+       - Return failure (0) instead of performing unsafe casts that can truncate or
+         cause implementation-defined/undefined behavior.
+    */
+    /* Validate floating point first to avoid undefined/implementation-defined casts */
+    if (isnan(value) || !isfinite(value)) {
+        TIFFErrorExt(tif->tif_clientdata, module, "Value is not a finite number");
+        return 0;
+    }
+    if( value < 0 )
+    {
+        TIFFErrorExt(tif->tif_clientdata,module,"Negative value is illegal");
+        return 0;
+    }
+    else if (value==0.0)
+    {
+        m[0]=0;
+        /* safe: exact 1 as denominator for zero value */
+        m[1]=1;
+    }
+    else {
+        /* Use the full 32-bit unsigned max as a double for comparisons */
+        double max32 = 4294967295.0; /* 0xFFFFFFFF */
+        /* If the value is an exact 32-bit unsigned integer within range, use that */
+        if (value <= max32 && value == (double)(uint32)value) {
+            m[0] = (uint32)value;
+            m[1] = 1;
+        }
+        /* If value is fractional < 1, try to represent it with denominator 0xFFFFFFFF */
+        else if (value < 1.0)
         {
-            TIFFErrorExt(tif->tif_clientdata,module,"Negative value is illegal");
-            return 0;
+            double prod = value * max32;
+            if (!isfinite(prod) || prod < 0.0 || prod > max32) {
+                TIFFErrorExt(tif->tif_clientdata, module, "Value cannot be represented as a rational (overflow)");
+                return 0;
+            }
+            /* safe cast after bounds check */
+            m[0] = (uint32)prod;
+            m[1] = (uint32)0xFFFFFFFFU;
         }
-	else if (value==0.0)
-	{
-		m[0]=0;
-		m[1]=1;
-	}
-	else if (value==(double)(uint32)value)
-	{
-		m[0]=(uint32)value;
-		m[1]=1;
-	}
-	else if (value<1.0)
-	{
-		m[0]=(uint32)(value*0xFFFFFFFF);
-		m[1]=0xFFFFFFFF;
-	}
-	else
-	{
-		m[0]=0xFFFFFFFF;
-		m[1]=(uint32)(0xFFFFFFFF/value);
-	}
-	if (tif->tif_flags&TIFF_SWAB)
-	{
-		TIFFSwabLong(&m[0]);
-		TIFFSwabLong(&m[1]);
-	}
-	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
+        else
+        {
+            /* value >= 1.0 and not an exact uint32 integer */
+            if (value > max32) {
+                TIFFErrorExt(tif->tif_clientdata, module, "Value too large to represent as 32-bit rational");
+                return 0;
+            }
+            double denom_d = max32 / value; /* 0xFFFFFFFF / value */
+            if (!isfinite(denom_d) || denom_d < 1.0 || denom_d > max32) {
+                TIFFErrorExt(tif->tif_clientdata, module, "Value cannot be represented as a rational (denominator overflow)");
+                return 0;
+            }
+            m[0] = (uint32)0xFFFFFFFFU;
+            m[1] = (uint32)denom_d;
+        }
+    }
+    if (tif->tif_flags&TIFF_SWAB)
+    {
+        TIFFSwabLong(&m[0]);
+        TIFFSwabLong(&m[1]);
+    }
+    return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
 }
 
 static int
