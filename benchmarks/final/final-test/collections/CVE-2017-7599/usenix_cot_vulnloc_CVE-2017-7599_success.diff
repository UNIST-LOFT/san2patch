diff --git a/libtiff/tif_dirwrite.c b/libtiff/tif_dirwrite.c
index c9e871be..a120914d 100644
--- a/libtiff/tif_dirwrite.c
+++ b/libtiff/tif_dirwrite.c
@@ -947,7 +947,24 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 	uint32 i;
 	int ok;
 	conv = _TIFFmalloc(count*sizeof(double));
-	if (conv == NULL)
+	/*
+ * Rationale for changes:
+ * The original code performed blind narrowing conversions (casts) from the source
+ * "value[]" elements into smaller integer types (int8/int16/int32/uint8/uint16/uint32)
+ * and into floats without validating the source values. This caused sanitizer
+ * failures when values were outside the destination ranges (e.g. 65280 -> int16)
+ * or when floating-point exceptional values (NaN/Inf) were converted to integers.
+ *
+ * Fix: before performing the narrowing conversion, validate each source element:
+ *  - For floating-point samples: check for NaN/Inf (isnan/isinf) and reject them.
+ *  - For integer samples (signed/unsigned): ensure the source is finite,
+ *    integral (no fractional part) and within the target type range. If any
+ *    value fails validation, report an error and abort the directory write by
+ *    returning 0. This avoids silent truncation/UB and keeps existing behavior
+ *    otherwise.
+ */
+
+if (conv == NULL)
 	{
 		TIFFErrorExt(tif->tif_clientdata, module, "Out of memory");
 		return (0);
@@ -959,11 +976,29 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			if (tif->tif_dir.td_bitspersample<=32)
 			{
 				for (i = 0; i < count; ++i)
+				{
+					/* reject NaN/Inf before casting to float */
+					if (value[i] != value[i] || isinf(value[i]))
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Invalid floating-point value for tag %u at index %u (NaN/Inf)", tag, i);
+						return (0);
+					}
 					((float*)conv)[i] = (float)value[i];
+				}
 				ok = TIFFWriteDirectoryTagFloatArray(tif,ndir,dir,tag,count,(float*)conv);
 			}
 			else
 			{
+				for (i = 0; i < count; ++i)
+				{
+					if (value[i] != value[i] || isinf(value[i]))
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Invalid floating-point value for tag %u at index %u (NaN/Inf)", tag, i);
+						return (0);
+					}
+				}
 				ok = TIFFWriteDirectoryTagDoubleArray(tif,ndir,dir,tag,count,value);
 			}
 			break;
@@ -971,19 +1006,50 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
 				for (i = 0; i < count; ++i)
-					((int8*)conv)[i] = (int8)value[i];
+				{
+					long long tmp = (long long)value[i];
+					/* must be integral and in signed 8-bit range */
+					if (value[i] != (double)tmp || tmp < -128LL || tmp > 127LL || value[i] != value[i] || isinf(value[i]))
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Value %g out of range for signed 8-bit tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					((int8*)conv)[i] = (int8)tmp;
+				}
 				ok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
-			{
+// FIXME: Crash CWE-681: Incorrect Conversion between Numeric Types
+ 			{
 				for (i = 0; i < count; ++i)
-					((int16*)conv)[i] = (int16)value[i];
+				{
+					long long tmp = (long long)value[i];
+					/* must be integral and in signed 16-bit range */
+					if (value[i] != (double)tmp || tmp < -32768LL || tmp > 32767LL || value[i] != value[i] || isinf(value[i]))
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Value %g out of range for signed 16-bit tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					((int16*)conv)[i] = (int16)tmp;
+				}
 				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);
 			}
 			else
 			{
 				for (i = 0; i < count; ++i)
-					((int32*)conv)[i] = (int32)value[i];
+				{
+					long long tmp = (long long)value[i];
+					/* must be integral and in signed 32-bit range */
+					if (value[i] != (double)tmp || tmp < -2147483648LL || tmp > 2147483647LL || value[i] != value[i] || isinf(value[i]))
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Value %g out of range for signed 32-bit tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					((int32*)conv)[i] = (int32)tmp;
+				}
 				ok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32*)conv);
 			}
 			break;
@@ -991,23 +1057,69 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
 				for (i = 0; i < count; ++i)
-					((uint8*)conv)[i] = (uint8)value[i];
+				{
+					if (value[i] != value[i] || isinf(value[i]) || value[i] < 0.0)
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Invalid unsigned value %g for tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					unsigned long long utmp = (unsigned long long)value[i];
+					if ((double)utmp != value[i] || utmp > 255ULL)
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Value %g out of range for unsigned 8-bit tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					((uint8*)conv)[i] = (uint8)utmp;
+				}
 				ok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
 			{
 				for (i = 0; i < count; ++i)
-					((uint16*)conv)[i] = (uint16)value[i];
+				{
+					if (value[i] != value[i] || isinf(value[i]) || value[i] < 0.0)
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Invalid unsigned value %g for tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					unsigned long long utmp = (unsigned long long)value[i];
+					if ((double)utmp != value[i] || utmp > 65535ULL)
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Value %g out of range for unsigned 16-bit tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					((uint16*)conv)[i] = (uint16)utmp;
+				}
 				ok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16*)conv);
 			}
 			else
 			{
 				for (i = 0; i < count; ++i)
-					((uint32*)conv)[i] = (uint32)value[i];
+				{
+					if (value[i] != value[i] || isinf(value[i]) || value[i] < 0.0)
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Invalid unsigned value %g for tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					unsigned long long utmp = (unsigned long long)value[i];
+					if ((double)utmp != value[i] || utmp > 4294967295ULL)
+					{
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Value %g out of range for unsigned 32-bit tag %u at index %u", value[i], tag, i);
+						return (0);
+					}
+					((uint32*)conv)[i] = (uint32)utmp;
+				}
 				ok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32*)conv);
 			}
 			break;
 		default:
+
 			ok = 0;
 	}
 
@@ -2094,9 +2206,35 @@ TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* d
 static int
 TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
 {
+        /*
+         * Rationale for changes:
+         * The original implementation performed unchecked conversions from double
+         * to uint32 which could result in narrowing conversions of NaN/Inf or
+         * values outside the range of uint32. Sanitizers reported errors such
+         * as "value -nan is outside the range of representable values of type
+         * 'unsigned int'" and large integers being truncated into signed types.
+         * To fix this (CWE-681), we must validate the input before conversion:
+         *  - reject NaN and infinite values
+         *  - reject negative values
+         *  - only cast to uint32 when the value is an exact integer within
+         *    [0, UINT32_MAX]
+         *  - for non-integer values >= 1 produce a safe rational with a
+         *    non-zero denominator computed to avoid division by zero and
+         *    to keep values within uint32 range
+         *  - for values between 0 and 1 produce a numerator in range [1, UINT32_MAX]
+         *    (rounding to preserve precision) and use UINT32_MAX as denominator
+         * These checks prevent undefined behavior from invalid casts and avoid
+         * writing invalid tag data.
+         */
         static const char module[] = "TIFFWriteDirectoryTagCheckedRational";
 	uint32 m[2];
 	assert(sizeof(uint32)==4);
+	/* Reject NaN and infinities explicitly */
+	if (isnan(value) || isinf(value))
+	{
+		TIFFErrorExt(tif->tif_clientdata,module,"NaN or infinite value is illegal");
+		return 0;
+	}
         if( value < 0 )
         {
             TIFFErrorExt(tif->tif_clientdata,module,"Negative value is illegal");
@@ -2105,22 +2243,41 @@ TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
 	else if (value==0.0)
 	{
 		m[0]=0;
-		m[1]=1;
+// FIXME: Crash CWE-681: Incorrect Conversion between Numeric Types
+ 		m[1]=1;
 	}
-	else if (value==(double)(uint32)value)
+	else if (value>=1.0)
 	{
-		m[0]=(uint32)value;
-		m[1]=1;
-	}
-	else if (value<1.0)
-	{
-		m[0]=(uint32)(value*0xFFFFFFFF);
-		m[1]=0xFFFFFFFF;
+		/*
+		 * If value is an exact integer that fits in uint32, use numerator=value, denominator=1.
+		 * Otherwise, create a rational with numerator=UINT32_MAX and a denominator
+		 * computed as floor(UINT32_MAX / value). Ensure denominator is at least 1
+		 * to avoid zero denominators when value > UINT32_MAX.
+		 */
+		double intpart;
+		if (modf(value, &intpart) == 0.0 && intpart <= (double)0xFFFFFFFFU)
+		{
+			m[0]=(uint32)intpart;
+			m[1]=1;
+		}
+		else
+		{
+			uint32 denom = (uint32)((double)0xFFFFFFFFU / value);
+			if (denom == 0)
+				denom = 1;
+			m[0]=0xFFFFFFFFU;
+			m[1]=denom;
+		}
 	}
 	else
 	{
-		m[0]=0xFFFFFFFF;
-		m[1]=(uint32)(0xFFFFFFFF/value);
+		/* 0 < value < 1.0: scale into [1..UINT32_MAX] and round to preserve precision */
+		double prod = value * (double)0xFFFFFFFFU;
+		uint32 numer = (uint32)(prod + 0.5);
+		if (numer == 0)
+			numer = 1; /* ensure non-zero numerator for positive values */
+		m[0]=numer;
+		m[1]=0xFFFFFFFFU;
 	}
 	if (tif->tif_flags&TIFF_SWAB)
 	{
