diff --git a/libtiff/tif_dirwrite.c b/libtiff/tif_dirwrite.c
index c9e871be..a3c21f5c 100644
--- a/libtiff/tif_dirwrite.c
+++ b/libtiff/tif_dirwrite.c
@@ -953,6 +953,18 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 		return (0);
 	}
 
+	/*
+	 * Rationale: The previous implementation performed direct C casts from the
+	 * source "value" array to narrower integer and unsigned integer types which
+	 * can invoke undefined behavior when the source value is NaN, infinite, or
+	 * outside the representable range of the target type. Sanitizers reported
+	 * runtime errors (out-of-range values for signed/unsigned types). To avoid
+	 * these issues we sanitize each value before casting: detect NaN (v != v),
+	 * clamp to the target type range, and map NaN to a safe default (0) for
+	 * integer conversions. This preserves functionality while preventing
+	 * out-of-range casts that caused UB/crashes.
+	 */
+
 	switch (tif->tif_dir.td_sampleformat)
 	{
 		case SAMPLEFORMAT_IEEEFP:
@@ -971,19 +983,41 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
 				for (i = 0; i < count; ++i)
-					((int8*)conv)[i] = (int8)value[i];
+				{
+					double v = value[i];
+					/* map NaN to 0, then clamp to int8 range */
+					if (v != v) v = 0.0; /* NaN check */
+					if (v < -128.0) v = -128.0;
+					if (v > 127.0) v = 127.0;
+					((int8*)conv)[i] = (int8)v;
+				}
 				ok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
-			{
+// FIXME: Crash
+ 			{
 				for (i = 0; i < count; ++i)
-					((int16*)conv)[i] = (int16)value[i];
+				{
+					double v = value[i];
+					/* map NaN to 0, then clamp to int16 range */
+					if (v != v) v = 0.0; /* NaN check */
+					if (v < -32768.0) v = -32768.0;
+					if (v > 32767.0) v = 32767.0;
+					((int16*)conv)[i] = (int16)v;
+				}
 				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);
 			}
 			else
 			{
 				for (i = 0; i < count; ++i)
-					((int32*)conv)[i] = (int32)value[i];
+				{
+					double v = value[i];
+					/* map NaN to 0, then clamp to int32 range */
+					if (v != v) v = 0.0; /* NaN check */
+					if (v < (double)(-2147483647 - 1)) v = (double)(-2147483647 - 1);
+					if (v > 2147483647.0) v = 2147483647.0;
+					((int32*)conv)[i] = (int32)v;
+				}
 				ok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32*)conv);
 			}
 			break;
@@ -991,19 +1025,40 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
 				for (i = 0; i < count; ++i)
-					((uint8*)conv)[i] = (uint8)value[i];
+				{
+					double v = value[i];
+					/* map NaN to 0, then clamp to uint8 range */
+					if (v != v) v = 0.0; /* NaN check */
+					if (v < 0.0) v = 0.0;
+					if (v > 255.0) v = 255.0;
+					((uint8*)conv)[i] = (uint8)v;
+				}
 				ok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
 			{
 				for (i = 0; i < count; ++i)
-					((uint16*)conv)[i] = (uint16)value[i];
+				{
+					double v = value[i];
+					/* map NaN to 0, then clamp to uint16 range */
+					if (v != v) v = 0.0; /* NaN check */
+					if (v < 0.0) v = 0.0;
+					if (v > 65535.0) v = 65535.0;
+					((uint16*)conv)[i] = (uint16)v;
+				}
 				ok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16*)conv);
 			}
 			else
 			{
 				for (i = 0; i < count; ++i)
-					((uint32*)conv)[i] = (uint32)value[i];
+				{
+					double v = value[i];
+					/* map NaN to 0, then clamp to uint32 range */
+					if (v != v) v = 0.0; /* NaN check */
+					if (v < 0.0) v = 0.0;
+					if (v > 4294967295.0) v = 4294967295.0;
+					((uint32*)conv)[i] = (uint32)v;
+				}
 				ok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32*)conv);
 			}
 			break;
@@ -2097,30 +2152,68 @@ TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir,
         static const char module[] = "TIFFWriteDirectoryTagCheckedRational";
 	uint32 m[2];
 	assert(sizeof(uint32)==4);
-        if( value < 0 )
-        {
-            TIFFErrorExt(tif->tif_clientdata,module,"Negative value is illegal");
-            return 0;
-        }
-	else if (value==0.0)
-	{
-		m[0]=0;
-		m[1]=1;
-	}
-	else if (value==(double)(uint32)value)
-	{
-		m[0]=(uint32)value;
-		m[1]=1;
-	}
-	else if (value<1.0)
-	{
-		m[0]=(uint32)(value*0xFFFFFFFF);
-		m[1]=0xFFFFFFFF;
-	}
-	else
+	/*
+	 * Rationale:
+	 * - Handle NaN and infinite values explicitly to avoid undefined
+	 *   casts to uint32 (which sanitize observed as runtime errors).
+	 * - Reject negative values since rationals here are unsigned.
+	 * - Provide safe clamping/rounding behavior for values that cannot
+	 *   be represented exactly as uint32 numerator/denominator.
+	 */
 	{
-		m[0]=0xFFFFFFFF;
-		m[1]=(uint32)(0xFFFFFFFF/value);
+		const double UINT32_MAX_D = 4294967295.0; /* 0xFFFFFFFF */
+		const uint32 UINT32_MAX_U = 0xFFFFFFFFU;
+
+		/* Detect NaN: NaN is the only floating point value that is != itself */
+		if (value != value) {
+			TIFFErrorExt(tif->tif_clientdata,module,"NaN value is illegal");
+			return 0;
+		}
+
+		/* Negative values are illegal for unsigned rationals */
+		if (value < 0.0) {
+			TIFFErrorExt(tif->tif_clientdata,module,"Negative value is illegal");
+			return 0;
+		}
+
+		/* Handle zero explicitly */
+		if (value == 0.0) {
+			m[0]=0;
+			m[1]=1;
+		}
+		/* If value is larger than or equal to UINT32_MAX, clamp to max */
+		else if (value >= UINT32_MAX_D) {
+			/* represent as the largest integer representable in uint32 */
+			m[0]=UINT32_MAX_U;
+			m[1]=1;
+		}
+		/* If value is an exact integer in uint32 range, store as numerator/1 */
+		else if (value == (double)(uint32)value) {
+			m[0]=(uint32)value;
+			m[1]=1;
+		}
+		/* For values less than 1, create a fraction with large denominator */
+		else if (value < 1.0) {
+			/* Round to nearest to reduce quantization error */
+			double numd = value * UINT32_MAX_D + 0.5;
+			uint32 num = (uint32)numd;
+			if (num == 0)
+				num = 1; /* ensure numerator not zero for very small values */
+			m[0]=num;
+			m[1]=UINT32_MAX_U;
+		}
+		else {
+			/* value > 1.0 and < UINT32_MAX_D
+			 * Represent using a large numerator and a computed denominator.
+			 * Compute denominator = round(UINT32_MAX / value), ensure >=1.
+			 */
+			double dd = UINT32_MAX_D / value;
+			uint32 denom = (uint32)(dd + 0.5);
+			if (denom == 0)
+				denom = 1;
+			m[0]=UINT32_MAX_U;
+			m[1]=denom;
+		}
 	}
 	if (tif->tif_flags&TIFF_SWAB)
 	{
