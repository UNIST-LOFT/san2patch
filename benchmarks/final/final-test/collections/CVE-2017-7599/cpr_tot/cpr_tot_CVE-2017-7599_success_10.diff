diff --git a/libtiff/tif_dirwrite.c b/libtiff/tif_dirwrite.c
index c9e871be..135a2b94 100644
--- a/libtiff/tif_dirwrite.c
+++ b/libtiff/tif_dirwrite.c
@@ -976,8 +976,8 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
 			{
-				for (i = 0; i < count; ++i)
-					((int16*)conv)[i] = (int16)value[i];
+				for (i = 0; i < count; ++i) 
+					((int16*)conv)[i] = (!isfinite(value[i]) || value[i] < -32768.0 || value[i] > 32767.0) ? (TIFFErrorExt(tif->tif_clientdata, module, "Numeric value out of range or not finite for tag %u", tag), (int16)0) : (int16)value[i];
 				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);
 			}
 			else
@@ -1015,6 +1015,7 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 	return (ok);
 }
 
+Rationale: This minimal change guards the int16 narrowing conversion by checking for non-finite values and out-of-range values before casting. When an invalid value is detected it logs an error (via TIFFErrorExt) and writes a canonical 0 into the output slot instead of silently truncating to an unexpected int16 value. The change is confined to the single token location and differs from other candidates by using a reject-or-zero strategy performed inline via the ternary and comma operator.
 #if 0
 static int
 TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
