diff --git a/parser.c b/parser.c
index 0d8d7f2e..8508740b 100644
--- a/parser.c
+++ b/parser.c
@@ -4074,10 +4074,25 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
     }
     if (ctxt->instate == XML_PARSER_EOF)
         goto error;
-
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 
+    /*
+     * Trim trailing space only if we actually have characters.
+     * Protect against reading buf[len - 1] when len == 0 which causes
+     * an OOB read reported by ASan. Also ensure there is room for the
+     * terminating NUL byte before writing it.
+     */
     if ((in_space) && (normalize)) {
-        while (buf[len - 1] == 0x20) len--;
+        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
     }
+
+    /* Ensure space for the terminating NUL. Grow buffer if needed. */
+    while (len + 1 > buf_size) {
+        /* if buf is somehow NULL or growBuffer cannot make space, fail */
+        if (buf == NULL) goto mem_error;
+        growBuffer(buf, 10);
+    }
+
     buf[len] = 0;
     if (RAW == '<') {
 	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
@@ -4107,6 +4122,7 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 
 mem_error:
     xmlErrMemory(ctxt, NULL);
+
 error:
     if (buf != NULL)
         xmlFree(buf);
@@ -8995,7 +9011,25 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
     }
     in++;
     if (len != NULL) {
-        *len = last - start;
+        /* Rationale: defensive checks to prevent underflow/overflow when
+         * computing the attribute length. If last < start or the computed
+         * length exceeds limits, abort parsing to avoid any out-of-bounds
+         * read/use. This prevents callers from using an invalid length
+         * derived from bad pointer arithmetic and mitigates CWE-125.
+         */
+        if (last < start) {
+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+                           "AttValue internal pointer underflow\n");
+            return(NULL);
+        }
+        ptrdiff_t attlen = (last - start);
+        if ((attlen > XML_MAX_TEXT_LENGTH) &&
+            ((ctxt->options & XML_PARSE_HUGE) == 0)) {
+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+                           "AttValue lenght too long\n");
+            return(NULL);
+        }
+        *len = attlen;
         ret = (xmlChar *) start;
     } else {
         if (alloc) *alloc = 1;
@@ -9004,9 +9038,28 @@ xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
     CUR_PTR = in;
     if (alloc) *alloc = 0;
     return ret;
-need_complex:
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ need_complex:
     if (alloc) *alloc = 1;
-    return xmlParseAttValueComplex(ctxt, len, normalize);
+    /* Call complex path but validate returned results to avoid using
+     * a malformed buffer/length. If xmlParseAttValueComplex returns NULL
+     * or an obviously invalid length, fail gracefully.
+     */
+    {
+        xmlChar *complex_ret = xmlParseAttValueComplex(ctxt, len, normalize);
+        if (complex_ret == NULL) return NULL;
+        if (len != NULL) {
+            if ((*len < 0) || (((*len) > XML_MAX_TEXT_LENGTH) &&
+                ((ctxt->options & XML_PARSE_HUGE) == 0))) {
+                xmlFree((void *)complex_ret);
+                xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
+                               "AttValue lenght too long\n");
+                return NULL;
+            }
+        }
+        return complex_ret;
+    }
+
 }
 
 /**
