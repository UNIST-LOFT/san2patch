diff --git a/parser.c b/parser.c
index 0d8d7f2e..a3ba8d5a 100644
--- a/parser.c
+++ b/parser.c
@@ -3888,7 +3888,7 @@ xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
  * of xmlParseAttValue() when the attribute parsing requires handling
  * of non-ASCII characters, or normalization compaction.
  *
- * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
+  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
  */
 static xmlChar *
 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
@@ -3916,11 +3916,24 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 
     /*
      * allocate a translation buffer.
-     */
+// FIXME: Crash CWE-125: Out-of-bounds Read
+      */
     buf_size = XML_PARSER_BUFFER_SIZE;
     buf = (xmlChar *) xmlMallocAtomic(buf_size);
     if (buf == NULL) goto mem_error;
 
+    /*
+     * Initialize current to the start of the buffer and ensure any
+     * future reallocations update 'current' consistently. The crash
+     * described by the sanitizer corresponds to an illegal read one
+     * byte before the allocated region (likely because 'current' was
+     * left uninitialized or not updated after a reallocation). To
+     * make the parsing operations safe we initialize 'current' and
+     * replace in-place growth calls below with explicit realloc that
+     * keeps 'current' valid relative to 'buf'.
+     */
+    current = buf;
+
     /*
      * OK loop until we reach one of the ending char or a size limit.
      */
@@ -3947,8 +3960,22 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 		if (val == '&') {
 		    if (ctxt->replaceEntities) {
 			if (len + 10 > buf_size) {
-			    growBuffer(buf, 10);
+			    /*
+			     * Grow the buffer safely: use xmlRealloc on 'buf', and
+			     * update 'current' to keep the same offset into the
+			     * (possibly moved) buffer. This prevents 'current'
+			     * from becoming a pointer outside the allocated region
+			     * (which could otherwise lead to reads before the
+			     * allocation as observed).
+			     */
+			    xmlChar *tmp = (xmlChar *) xmlRealloc(buf, buf_size + 10);
+			    if (tmp == NULL) goto mem_error;
+			    /* preserve current offset */
+			    current = tmp + (current - buf);
+			    buf = tmp;
+			    buf_size += 10;
 			}
+
 			buf[len++] = '&';
 		    } else {
 			/*
@@ -4074,9 +4101,22 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
     }
     if (ctxt->instate == XML_PARSER_EOF)
         goto error;
-
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 
+    /*
+     * Defensive fix: ensure we never read buf[len - 1] when len == 0.
+     * The sanitizer reported an illegal read one byte before the allocated
+     * buffer (buf[len - 1] when len == 0). Ensure len > 0 before trimming
+     * trailing spaces. Also ensure there is space for the terminating NUL
+     * byte by growing the buffer if necessary.
+     */
     if ((in_space) && (normalize)) {
-        while (buf[len - 1] == 0x20) len--;
+        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
+    }
+
+    /* Ensure space for terminating NUL */
+    while (len + 1 > buf_size) {
+        growBuffer(buf, 10);
     }
     buf[len] = 0;
     if (RAW == '<') {
@@ -4107,6 +4147,7 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 
 mem_error:
     xmlErrMemory(ctxt, NULL);
+
 error:
     if (buf != NULL)
         xmlFree(buf);
