diff --git a/libtiff/tif_dirwrite.c b/libtiff/tif_dirwrite.c
index c9e871be..a241a8da 100644
--- a/libtiff/tif_dirwrite.c
+++ b/libtiff/tif_dirwrite.c
@@ -576,28 +576,73 @@ TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)
 					uint16* nb;
 					TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);
 					if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))
-						goto bad;
-				}
-			}
-			if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))
-			{
-				if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))
-					goto bad;
-			}
-			if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))
-			{
-				if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))
-					goto bad;
-			}
-			if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))
-			{
-				if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))
-					goto bad;
-			}
-			if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))
-			{
-				if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))
-					goto bad;
+                        goto bad;
+                }
+            }
+            if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))
+            {
+                if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))
+                    goto bad;
+            }
+// FIXME: Crash CWE-197: Numeric Truncation Error
+            if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))
+            {
+                /* Rationale:
+                 * The original call passes values that may be negative or out of the
+                 * 0..255 range and they are written into an unsigned byte-sized
+                 * destination which causes UBSan-reported truncation. To avoid
+                 * truncation we validate the range of each sample, copy them into
+                 * an explicitly unsigned byte buffer and then call the existing
+                 * writer. If validation fails we bail out (goto bad) so no
+                 * truncated/wrong bytes are written.
+                 */
+                unsigned int _spp = tif->tif_dir.td_samplesperpixel;
+                unsigned char *_sbuf = (unsigned char *)malloc((size_t)_spp * sizeof(unsigned char));
+                unsigned int _i;
+                if (_sbuf == NULL)
+                    goto bad;
+                for (_i = 0; _i < _spp; _i++) {
+                    long _v = tif->tif_dir.td_sminsamplevalue[_i];
+                    if (_v < 0 || _v > 255) {
+                        free(_sbuf);
+                        goto bad;
+                    }
+                    _sbuf[_i] = (unsigned char)_v;
+                }
+                if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,_sbuf)) {
+                    free(_sbuf);
+                    goto bad;
+                }
+                free(_sbuf);
+            }
+            if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))
+            {
+                /* Rationale:
+                 * Same treatment for maximum sample values to prevent truncation
+                 * when writing into byte-sized destinations.
+                 */
+                unsigned int _spp2 = tif->tif_dir.td_samplesperpixel;
+                unsigned char *_sbuf2 = (unsigned char *)malloc((size_t)_spp2 * sizeof(unsigned char));
+                unsigned int _j;
+                if (_sbuf2 == NULL)
+                    goto bad;
+                for (_j = 0; _j < _spp2; _j++) {
+                    long _v2 = tif->tif_dir.td_smaxsamplevalue[_j];
+                    if (_v2 < 0 || _v2 > 255) {
+                        free(_sbuf2);
+                        goto bad;
+                    }
+                    _sbuf2[_j] = (unsigned char)_v2;
+                }
+                if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,_sbuf2)) {
+                    free(_sbuf2);
+                    goto bad;
+                }
+                free(_sbuf2);
+            }
+            if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))
+            {
+                if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))					goto bad;
 			}
 			if (TIFFFieldSet(tif,FIELD_TILEDEPTH))
 			{
@@ -989,10 +1034,28 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			break;
 		case SAMPLEFORMAT_UINT:
 			if (tif->tif_dir.td_bitspersample<=8)
-			{
+// Rationale: Prevent silent truncation by validating values before converting to an 8-bit unsigned
+// If any value is out-of-range for an unsigned byte (0..255) or is NaN, do not write and indicate failure.
+ 			{
+				/* validate all values first to avoid silent narrowing/truncation */
+				ok = 1;
 				for (i = 0; i < count; ++i)
-					((uint8*)conv)[i] = (uint8)value[i];
-				ok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);
+				{
+					double v = value[i];
+					/* check for NaN and range violation */
+					if (v != v || v < 0.0 || v > 255.0)
+					{
+						ok = 0;
+						break;
+					}
+				}
+				if (ok)
+				{
+					for (i = 0; i < count; ++i)
+						((uint8*)conv)[i] = (uint8)value[i];
+					ok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);
+				}
+				/* if validation failed ok is 0 and no write was attempted */
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
 			{
@@ -1011,6 +1074,7 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 			ok = 0;
 	}
 
+
 	_TIFFfree(conv);
 	return (ok);
 }
