diff --git a/libtiff/tif_dirwrite.c b/libtiff/tif_dirwrite.c
index c9e871be..f0a6ba37 100644
--- a/libtiff/tif_dirwrite.c
+++ b/libtiff/tif_dirwrite.c
@@ -970,8 +970,8 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 		case SAMPLEFORMAT_INT:
 			if (tif->tif_dir.td_bitspersample<=8)
 			{
-				for (i = 0; i < count; ++i)
-					((int8*)conv)[i] = (int8)value[i];
+				for (i = 0; i < count; ++i) 
+					((int8*)conv)[i] = (value[i] < -128.0 ? (int8)-128 : (value[i] > 127.0 ? (int8)127 : (int8)value[i]));
 				ok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);
 			}
 			else if (tif->tif_dir.td_bitspersample<=16)
@@ -1015,6 +1015,7 @@ TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* di
 	return (ok);
 }
 
+Rationale: This minimal change clamps each double value into the signed 8-bit range before narrowing. By replacing the direct cast with a ternary clamp using explicit bounds (-128 and 127), negative/large values (like -115 represented as unsigned) cannot produce an out-of-range narrowing that triggers UBSan/ASan representability errors. This preserves the function structure and behavior for in-range values while preventing unsafe conversions. This candidate is different from other variants because it performs a straightforward clamp using double comparisons and direct int8 constants.
 #if 0
 static int
 TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
