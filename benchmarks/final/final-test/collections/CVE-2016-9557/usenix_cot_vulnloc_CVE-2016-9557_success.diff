diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..622a9a4 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -130,8 +130,8 @@ static jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];
 jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
   int clrspc)
 {
-	jas_image_t *image;
-	uint_fast32_t rawsize;
+jas_image_t *image;
+	size_t rawsize;
 	uint_fast32_t inmem;
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
@@ -157,10 +157,47 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 
 	/* Compute the approximate raw size of the image. */
 	rawsize = 0;
+// FIXME: Crash CWE-190: Integer Overflow or Wraparound
+	/*
+	 * Rationale for modification:
+	 *	The original code used a 32-bit/fast integer accumulator and performed
+	 *	unchecked multiplications of untrusted image dimensions and precision,
+	 *	which can overflow and lead to under-allocation and memory corruption.
+	 *	To prevent this, use size_t for size calculations and perform explicit
+	 *	overflow checks before each multiplication/addition. If an overflow is
+	 *	detected, clamp rawsize to the maximum representable size to ensure
+	 *	that the subsequent in-memory buffering decision will treat the image
+	 *	as too large to buffer, avoiding unsafe allocations. The function
+	 *	continues normally otherwise.
+	 */
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+		size_t w = (size_t)cmptparm->width;
+		size_t h = (size_t)cmptparm->height;
+		size_t bps = (size_t)((cmptparm->prec + 7) / 8);
+		/* Check w * h overflow: */
+		if (w != 0 && h > ((size_t)-1) / w) {
+			/* Overflow: treat as very large image */
+			rawsize = (size_t)-1;
+			break;
+		}
+		{
+			size_t pixels = w * h;
+			/* Check pixels * bps overflow: */
+			if (bps != 0 && pixels > ((size_t)-1) / bps) {
+				/* Overflow: treat as very large image */
+				rawsize = (size_t)-1;
+				break;
+			}
+			size_t term = pixels * bps;
+			/* Check addition overflow: */
+			if (rawsize > ((size_t)-1) - term) {
+				/* Overflow: treat as very large image */
+				rawsize = (size_t)-1;
+				break;
+			}
+			rawsize += term;
+		}
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
@@ -190,6 +227,7 @@ jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
 
+
 	if (!(image = jas_malloc(sizeof(jas_image_t)))) {
 		return 0;
 	}
