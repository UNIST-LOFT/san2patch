diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..d9b8287 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -131,7 +131,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
   int clrspc)
 {
 	jas_image_t *image;
-	uint_fast32_t rawsize;
+	size_t rawsize;
 	uint_fast32_t inmem;
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
@@ -159,8 +159,34 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	rawsize = 0;
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+/* Rationale: Perform size calculations in size_t and check for overflow at each step. */
+		{
+			size_t max_size = (size_t)-1;
+			/* Validate precision to avoid absurdly large bytes-per-sample. */
+			if (cmptparm->prec <= 0 || cmptparm->prec > 32) {
+				jas_image_destroy(image);
+				return 0;
+			}
+			size_t bps = ((size_t)cmptparm->prec + 7) / 8;
+			/* Check width * bps does not overflow. */
+			if (cmptparm->width != 0 && bps > max_size / (size_t)cmptparm->width) {
+				jas_image_destroy(image);
+				return 0;
+			}
+			size_t tmp = (size_t)cmptparm->width * bps;
+			/* Check tmp * height does not overflow. */
+			if (cmptparm->height != 0 && (size_t)cmptparm->height > max_size / tmp) {
+				jas_image_destroy(image);
+				return 0;
+			}
+			size_t comp_size = tmp * (size_t)cmptparm->height;
+			/* Check accumulation does not overflow. */
+			if (rawsize > max_size - comp_size) {
+				jas_image_destroy(image);
+				return 0;
+			}
+			rawsize += comp_size;
+		}
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
@@ -186,6 +212,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	return image;
 }
 
+
 jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
