diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..abbaf30 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -136,6 +136,17 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
 
+	/* Rationale:
+	   The original code performed multiplications using the types of the
+	   component parameters which could lead to signed integer overflow
+	   during intermediate computations (as reported by the sanitizer).
+	   To avoid this, perform the arithmetic in a wider unsigned type
+	   (uint64_t), check for overflow, and then safely cap/convert the
+	   result to fit into rawsize (uint_fast32_t). This prevents UB from
+	   overflow while preserving the original behavior: if the computed
+	   raw size is enormous, treat it as large enough that data should
+	   not be buffered in memory (by capping to the maximum value). */
+
 	if (!(image = jas_image_create0())) {
 		return 0;
 	}
@@ -157,10 +168,37 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 
 	/* Compute the approximate raw size of the image. */
 	rawsize = 0;
-	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
-	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+	{
+		uint64_t accum = 0;
+		for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
+		  ++cmptparm) {
+			uint64_t w = (uint64_t)cmptparm->width;
+			uint64_t h = (uint64_t)cmptparm->height;
+			uint64_t prec = (uint64_t)(cmptparm->prec + 7);
+			/* Compute component size in 64-bit to avoid overflow in intermediate calculations. */
+			uint64_t compsz = w * h;
+			compsz = compsz * prec;
+			compsz = compsz / 8;
+			/* If any intermediate computation overflows 64-bit semantics this will
+			   wrap, but such extreme values are effectively "too large" to
+			   buffer in memory; cap accordingly. Check before adding to accum. */
+			if (compsz > UINT64_MAX - accum) {
+				accum = UINT64_MAX;
+				break;
+			}
+			accum += compsz;
+			/* If accumulated size exceeds what rawsize can represent, cap and stop. */
+			if (accum > (uint64_t)UINT_FAST32_MAX) {
+				accum = (uint64_t)UINT_FAST32_MAX;
+				break;
+			}
+		}
+		/* Convert back to the original rawsize type, capping as necessary. */
+		if (accum > (uint64_t)UINT_FAST32_MAX) {
+			rawsize = (uint_fast32_t)UINT_FAST32_MAX;
+		} else {
+			rawsize = (uint_fast32_t)accum;
+		}
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
