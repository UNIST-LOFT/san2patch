diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..2093477 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -131,7 +131,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
   int clrspc)
 {
 	jas_image_t *image;
-	uint_fast32_t rawsize;
+	size_t rawsize;
 	uint_fast32_t inmem;
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
@@ -159,8 +159,32 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	rawsize = 0;
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+// Rationale: Prevent signed/unsigned overflow in multiplications used to compute the allocation size.
+// Use size_t arithmetic and explicit overflow checks so that maliciously large dimensions cannot
+// wrap and lead to an undersized allocation and subsequent out-of-bounds write.
+		size_t w = (size_t)cmptparm->width;
+		size_t h = (size_t)cmptparm->height;
+		size_t bps = (size_t)((cmptparm->prec + 7) / 8);
+		size_t comp_size;
+		size_t maxsz = (size_t)-1;
+		/* Check w * h overflow */
+		if (h != 0 && w > maxsz / h) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		comp_size = w * h;
+		/* Check comp_size * bps overflow */
+		if (bps != 0 && comp_size > maxsz / bps) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		comp_size *= bps;
+		/* Check rawsize + comp_size overflow */
+		if (rawsize > maxsz - comp_size) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		rawsize += comp_size;
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
@@ -186,6 +210,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	return image;
 }
 
+
 jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
