diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..95b14ca 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -159,8 +159,8 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	rawsize = 0;
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+		if ((size_t)cmptparm->width == 0 || (size_t)cmptparm->height == 0 || cmptparm->prec <= 0 || cmptparm->prec > 32 || (size_t)cmptparm->height > ((size_t)-1) / (size_t)cmptparm->width || (((size_t)(cmptparm->prec + 7) / 8) != 0 && (size_t)cmptparm->width * (size_t)cmptparm->height > ((size_t)-1) / ((size_t)(cmptparm->prec + 7) / 8)) || (size_t)rawsize > ((size_t)-1) - (size_t)cmptparm->width * (size_t)cmptparm->height * ((size_t)(cmptparm->prec + 7) / 8)) return 0; rawsize += cmptparm->width * cmptparm->height *
+	  (cmptparm->prec + 7) / 8; 
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
@@ -186,7 +186,12 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	return image;
 }
 
-jas_image_t *jas_image_create0()
+Rationale: This candidate replaces the <PATCH> token with a comprehensive one-line guard that casts the width/height/precision to size_t and performs explicit overflow checks:
+- validates non-zero and reasonable precision (1..32)
+- checks width*height won't overflow size_t via division checks
+- checks multiplication by bytes-per-sample won't overflow
+- checks rawsize accumulation won't overflow a size_t-sized capacity
+If any check fails the function returns NULL, preventing undersized allocations/overflows. This approach uses (size_t)-1 as the size limit and is a minimal single-line insertion (semantically different from other candidates).jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
 
