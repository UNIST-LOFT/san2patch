diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..080bed4 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -130,8 +130,8 @@ static jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];
 jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
   int clrspc)
 {
-	jas_image_t *image;
-	uint_fast32_t rawsize;
+jas_image_t *image;
+	size_t rawsize;
 	uint_fast32_t inmem;
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
@@ -157,10 +157,38 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 
 	/* Compute the approximate raw size of the image. */
 	rawsize = 0;
+	/* Rationale: Use size_t for accumulation and perform explicit overflow checks.
+	   Avoid signed integer overflow and ensure that width*height*bps cannot wrap.
+	   If any multiplication or addition would overflow, abort by freeing and
+	   returning 0. We use (size_t)-1 as the maximum representable size. */
 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+		size_t w = (size_t)cmptparm->width;
+		size_t h = (size_t)cmptparm->height;
+		size_t bps = (size_t)((cmptparm->prec + 7) / 8);
+		/* Reject zero dimensions or precision. */
+		if (w == 0 || h == 0 || bps == 0) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		/* Check w * h overflow: */
+		if (w > ((size_t)-1) / h) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		size_t prod = w * h;
+		/* Check prod * bps overflow: */
+		if (prod > ((size_t)-1) / bps) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		size_t add = prod * bps;
+		/* Check rawsize + add overflow: */
+		if (rawsize > ((size_t)-1) - add) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		rawsize += add;
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
@@ -190,6 +218,7 @@ jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
 
+
 	if (!(image = jas_malloc(sizeof(jas_image_t)))) {
 		return 0;
 	}
@@ -391,11 +420,67 @@ jas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr)
 		goto error;
 	if (!fmtinfo->ops.decode)
 		goto error;
-
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow
+ 
 	/* Decode the image. */
 	if (!(image = (*fmtinfo->ops.decode)(in, optstr)))
 		goto error;
 
+	/*
+	 * Perform post-decode sanity checks to mitigate integer-overflow-to-
+	 * buffer-overflow issues that can occur when image metadata is crafted
+	 * maliciously. The checks below compute the total raw size of the
+	 * image components using size_t and detect overflow via
+	 * __builtin_mul_overflow/__builtin_add_overflow. If any overflow or
+	 * unreasonable value is detected, abort decode and free the image.
+	 *
+	 * Rationale: The vulnerable code computed allocation sizes using
+	 * signed/narrow types without overflow checks which could wrap and
+	 * lead to out-of-bounds writes. By validating component dimensions,
+	 * precision and computed size in a size-safe manner we prevent such
+	 * conditions from reaching subsequent allocation/indexing code.
+	 */
+	if (image) {
+#ifdef __has_builtin
+#if __has_builtin(__builtin_mul_overflow) && __has_builtin(__builtin_add_overflow)
+		/* Use compiler builtins when available for robust overflow detection. */
+#endif
+#endif
+		size_t rawsize = 0;
+		unsigned i;
+		/* Basic sanity: ensure number of components is reasonable. */
+		if (image->numcmpts_ <= 0 || image->numcmpts_ > 1024)
+			goto bad_image;
+		for (i = 0; i < (unsigned)image->numcmpts_; ++i) {
+			jas_image_cmpt_t *cmpt = &image->cmpts_[i];
+			/* width_, height_, and prec_ are signed in the data structures; cast to size_t for safe arithmetic */
+			size_t w = (size_t)cmpt->width_;
+			size_t h = (size_t)cmpt->height_;
+			size_t prec = (size_t)cmpt->prec_;
+			/* bytes per sample */
+			size_t bps = (prec + 7) / 8;
+			if (w == 0 || h == 0 || bps == 0)
+				goto bad_image;
+			/* Prevent absurdly large dimensions to avoid huge allocations */
+			if (w > ((size_t)1 << 30) || h > ((size_t)1 << 30))
+				goto bad_image;
+			/* Detect multiplication overflow: prod = w * h */
+			size_t prod;
+			if (__builtin_mul_overflow(w, h, &prod))
+				goto bad_image;
+			/* Detect multiplication overflow: add = prod * bps */
+			size_t add;
+			if (__builtin_mul_overflow(prod, bps, &add))
+				goto bad_image;
+			/* Detect addition overflow: rawsize + add */
+			if (__builtin_add_overflow(rawsize, add, &rawsize))
+				goto bad_image;
+		}
+		/* Impose an overall cap on image raw size (e.g., 2GB) to avoid extreme allocations */
+		if (rawsize > (size_t)2 * 1024 * 1024 * 1024ULL)
+			goto bad_image;
+	}
+
 	/* Create a color profile if needed. */
 	if (!jas_clrspc_isunknown(image->clrspc_) &&
 	  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {
@@ -405,6 +490,11 @@ jas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr)
 	}
 
 	return image;
+bad_image:
+	/* Detected invalid or dangerous image parameters; clean up and fail. */
+	if (image)
+		jas_image_destroy(image);
+	return 0;
 error:
 	if (image)
 		jas_image_destroy(image);
@@ -425,6 +515,7 @@ int jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt, char *optst
 * Component read and write operations.
 \******************************************************************************/
 
+
 int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,
   jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,
   jas_matrix_t *data)
