diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..d314a49 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -131,7 +131,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
   int clrspc)
 {
 	jas_image_t *image;
-	uint_fast32_t rawsize;
+	size_t rawsize;
 	uint_fast32_t inmem;
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
@@ -155,13 +155,61 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 		image->cmpts_[cmptno] = 0;
 	}
 
-	/* Compute the approximate raw size of the image. */
-	rawsize = 0;
-	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
-	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+	/*
+	 * Rationale: Validate untrusted per-component parameters and use
+	 * size_t arithmetic to avoid signed integer overflow when computing
+	 * the total raw size. Reject obviously unreasonable values so that
+	 * subsequent allocations cannot be tricked into undersized buffers.
+	 */
+	{
+		const size_t MAX_DIMENSION = 65536; /* sensible upper bound */
+		const int MAX_COMPONENTS = 256;
+		const int MAX_PRECISION = 64;
+		const size_t MAX_TOTAL_PIXELS = (1ULL << 30);
+
+		if (numcmpts < 1 || numcmpts > MAX_COMPONENTS) {
+			jas_image_destroy(image);
+			return 0;
+		}
+
+		/* Validate each component and check for overflow while summing. */
+		rawsize = 0;
+		for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno, ++cmptparm) {
+			if (cmptparm->width < 1 || cmptparm->height < 1 ||
+			  cmptparm->width > (int)MAX_DIMENSION || cmptparm->height > (int)MAX_DIMENSION ||
+			  cmptparm->prec < 1 || cmptparm->prec > MAX_PRECISION) {
+				jas_image_destroy(image);
+				return 0;
+			}
+			/* Prevent unreasonably large pixel counts per component. */
+			if ((size_t)cmptparm->width * (size_t)cmptparm->height > MAX_TOTAL_PIXELS) {
+				jas_image_destroy(image);
+				return 0;
+			}
+			/* Compute component size in bytes using size_t and check overflow. */
+			{
+				size_t npixels = (size_t)cmptparm->width * (size_t)cmptparm->height;
+				size_t bytes_per_pixel = (cmptparm->prec + 7) / 8;
+				if (bytes_per_pixel == 0) {
+					jas_image_destroy(image);
+					return 0;
+				}
+				if (npixels > (SIZE_MAX / bytes_per_pixel)) {
+					/* multiplication would overflow */
+					jas_image_destroy(image);
+					return 0;
+				}
+				size_t compbytes = npixels * bytes_per_pixel;
+				if (rawsize > (SIZE_MAX - compbytes)) {
+					/* accumulation would overflow */
+					jas_image_destroy(image);
+					return 0;
+				}
+				rawsize += compbytes;
+			}
+		}
 	}
+
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
 	inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);
@@ -186,6 +234,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	return image;
 }
 
+
 jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
