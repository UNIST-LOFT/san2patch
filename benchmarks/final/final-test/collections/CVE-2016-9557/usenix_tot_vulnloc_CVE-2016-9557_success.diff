diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index b40ba0c..ee3e4d9 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -131,11 +131,18 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
   int clrspc)
 {
 	jas_image_t *image;
-	uint_fast32_t rawsize;
+	size_t rawsize;
 	uint_fast32_t inmem;
 	int cmptno;
 	jas_image_cmptparm_t *cmptparm;
 
+	/* Rationale:
+	   Fix integer overflow and consequent out-of-bounds writes by performing
+	   size-aware arithmetic using size_t and explicit overflow checks before
+	   performing multiplications/additions. If any check fails, abort image
+	   creation and return 0 to avoid allocating an incorrectly small buffer.
+	*/
+
 	if (!(image = jas_image_create0())) {
 		return 0;
 	}
@@ -157,10 +164,41 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 
 	/* Compute the approximate raw size of the image. */
 	rawsize = 0;
-	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
-		rawsize += cmptparm->width * cmptparm->height *
-		  (cmptparm->prec + 7) / 8;
+		size_t w = (size_t)cmptparm->width;
+		size_t h = (size_t)cmptparm->height;
+		/* bytes per sample */
+		size_t comp_bytes = (size_t)((cmptparm->prec + 7) / 8);
+
+		/* If any dimension or component size is zero, treat as zero-sized
+		   component (keep consistent with callers) */
+		if (w == 0 || h == 0 || comp_bytes == 0) {
+			continue;
+		}
+
+		/* Check w * h does not overflow */
+		if (w > SIZE_MAX / h) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		size_t pixels = w * h;
+
+		/* Check pixels * comp_bytes does not overflow */
+		if (pixels > SIZE_MAX / comp_bytes) {
+			jas_image_destroy(image);
+			return 0;
+		}
+		size_t comp_storage = pixels * comp_bytes;
+
+		/* Check rawsize + comp_storage does not overflow */
+		if (rawsize > SIZE_MAX - comp_storage) {
+			jas_image_destroy(image);
+			return 0;
+		}
+
+		rawsize += comp_storage;
 	}
 	/* Decide whether to buffer the image data in memory, based on the
 	  raw size of the image. */
@@ -186,6 +224,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	return image;
 }
 
+
 jas_image_t *jas_image_create0()
 {
 	jas_image_t *image;
diff --git a/src/libjasper/jpc/jpc_dec.c b/src/libjasper/jpc/jpc_dec.c
index 4bddb22..03e313e 100644
--- a/src/libjasper/jpc/jpc_dec.c
+++ b/src/libjasper/jpc/jpc_dec.c
@@ -450,6 +450,13 @@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)
 
 	if (dec->state == JPC_MH) {
 
+		/* Rationale: Prevent integer overflow/wraparound when computing
+		   the total raw image size derived from untrusted metadata. Compute
+		   sizes using size_t and perform explicit checks before performing
+		   multiplications/additions. If any check fails, abort image
+		   creation and return an error to avoid allocating too-small
+		   buffers and possible out-of-bounds writes. */
+
 		if (!(compinfos = jas_alloc2(dec->numcomps,
 		  sizeof(jas_image_cmptparm_t)))) {
 			abort();
@@ -464,6 +471,47 @@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)
 			compinfo->height = cmpt->height;
 			compinfo->hstep = cmpt->hstep;
 			compinfo->vstep = cmpt->vstep;
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 		}
+
+		/* Perform safe size computations and overflow checks before
+		   attempting to create the image. */
+		{
+			size_t rawsize = 0;
+			size_t maxsz = (size_t)-1;
+			for (cmptno = 0, compinfo = compinfos; cmptno < dec->numcomps;
+			  ++cmptno, ++compinfo) {
+				/* Validate parameters conservatively. Treat non-positive
+				   dimensions or precision as error. */
+				if (compinfo->width <= 0 || compinfo->height <= 0 ||
+				  compinfo->prec <= 0) {
+					jas_free(compinfos);
+					return -1;
+				}
+				/* compute per-component sizes in size_t */
+				size_t w = (size_t) compinfo->width;
+				size_t h = (size_t) compinfo->height;
+				size_t comp_prec = (size_t) compinfo->prec;
+				size_t comp_bytes = (comp_prec + 7) / 8;
+				/* pixels = w * h; check overflow */
+				if (w > 0 && h > maxsz / w) {
+					jas_free(compinfos);
+					return -1;
+				}
+				size_t pixels = w * h;
+				/* component storage = pixels * comp_bytes; check overflow */
+				if (comp_bytes > 0 && pixels > maxsz / comp_bytes) {
+					jas_free(compinfos);
+					return -1;
+				}
+				size_t comp_storage = pixels * comp_bytes;
+				/* check addition overflow for rawsize + comp_storage */
+				if (rawsize > maxsz - comp_storage) {
+					jas_free(compinfos);
+					return -1;
+				}
+				rawsize += comp_storage;
+			}
 		}
 
 		if (!(dec->image = jas_image_create(dec->numcomps, compinfos,
@@ -486,6 +534,7 @@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)
 		}
 	}
 
+
 	if (sot->len > 0) {
 		dec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -
 		  4 + sot->len;
