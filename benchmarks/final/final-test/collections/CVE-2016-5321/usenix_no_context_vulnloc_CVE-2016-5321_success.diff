diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index d959ae30..0bba5951 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -961,13 +961,24 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
   uint32  row_offset, col_offset; /* Output buffer offsets */
   tsize_t tbytes = 0, tilesize = TIFFTileSize(in);
   tsample_t s;
-  uint8*  bufp = (uint8*)obuf;
+  /* Rationale: Keep the existing stack-allocated array but ensure all loops consistently use a validated bound nsrc = min(spp, MAX_SAMPLES). This fixes the out-of-bounds read when spp > MAX_SAMPLES by clamping the runtime loop bounds. Initialization, allocation and cleanup are performed only for nsrc entries. */
+uint8*  bufp = (uint8*)obuf;
   unsigned char *srcbuffs[MAX_SAMPLES];
   unsigned char *tbuff = NULL;
+  int nsrc = 0;
 
   bytes_per_sample = (bps + 7) / 8;
 
-  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
+  /* Validate spp and clamp to MAX_SAMPLES to avoid indexing past srcbuffs. */
+  if (spp <= 0)
+    {
+    TIFFError("readSeparateTilesIntoBuffer",
+              "Invalid samples-per-pixel value %d", spp);
+    return 0;
+    }
+  nsrc = (spp > MAX_SAMPLES) ? MAX_SAMPLES : spp;
+
+  for (sample = 0; (sample < nsrc); sample++)
     {
     srcbuffs[sample] = NULL;
     tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);
@@ -989,7 +1000,8 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
     nrow = (row + tl > imagelength) ? imagelength - row : tl;
     for (col = 0; col < imagewidth; col += tw)
       {
-      for (s = 0; s < spp; s++)
+// FIXME: Crash CWE-125: Out-of-bounds Read
+       for (s = 0; s < nsrc; s++)
         {  /* Read each plane of a tile set into srcbuffs[s] */
 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
         if (tbytes < 0  && !ignore)
@@ -1000,7 +1012,7 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
 		 (unsigned long) col, (unsigned long) row,
 		 (unsigned long) s);
 		 status = 0;
-          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
+          for (sample = 0; (sample < nsrc); sample++)
             {
             tbuff = srcbuffs[sample];
             if (tbuff != NULL)
@@ -6074,8 +6086,27 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
 	     return (-1);
              }
            }
-         else
+// FIXME: Crash CWE-125: Out-of-bounds Read
+          else
            {
+/* Rationale: Use a conservative, implementation-local upper-bound for samples-per-pixel.
+   This prevents calling into the separate-tiles reader with an unexpectedly large
+   'spp' that it cannot handle, which was observed to produce stack/heap OOB reads.
+   Chosen limit is lower than some extreme theoretical bounds to remain safe for
+   typical TIFF images. */
+	   {
+	   const int MAX_SAFE_SPP = 256; /* conservative per-image limit */
+	   if (spp <= 0)
+	     {
+	     TIFFError("loadImage", "Invalid samples per pixel (%d)", spp);
+	     return (-1);
+	     }
+	   if (spp > MAX_SAFE_SPP)
+	     {
+	     TIFFError("loadImage", "Samples per pixel (%d) exceeds safe limit (%d)", spp, MAX_SAFE_SPP);
+	     return (-1);
+	     }
+	   }
 	   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
 	     {
 	     TIFFError("loadImage", "Unable to read separate tiles into buffer");
@@ -6107,6 +6138,7 @@ static int  correct_orientation(struct image_data *image, unsigned char **work_b
   uint16 mirror, rotation;
   unsigned char *work_buff;
 
+
   work_buff = *work_buff_ptr;
   if ((image == NULL) || (work_buff == NULL))
     {
