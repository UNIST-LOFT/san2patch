diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index d959ae30..9f45c27e 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -965,8 +965,38 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
   unsigned char *srcbuffs[MAX_SAMPLES];
   unsigned char *tbuff = NULL;
 
+  /* Rationale:
+   * Fix for CWE-125 out-of-bounds read in readSeparateTilesIntoBuffer.
+   * Root cause: code later indexes srcbuffs[s] for s from 0..spp-1 but
+   * srcbuffs was only initialized/allocated for indices up to
+   * min(spp, MAX_SAMPLES). If spp > MAX_SAMPLES an out-of-bounds read
+   * occurs. Remediation:
+   *  - Initialize the entire srcbuffs array to NULL to avoid reading
+   *    uninitialized pointers.
+   *  - Add a defensive check: if spp > MAX_SAMPLES, fail early with
+   *    an error to avoid silent truncation or out-of-bounds access.
+   *  - Ensure all cleanup loops iterate over MAX_SAMPLES so we only free
+   *    pointers that were allocated/initialized.
+   *  - Check srcbuffs[s] before using it in TIFFReadTile.
+   */
+
   bytes_per_sample = (bps + 7) / 8;
 
+  /* Initialize all entries to NULL to be defensive. */
+  for (i = 0; i < MAX_SAMPLES; i++)
+    srcbuffs[i] = NULL;
+
+  /* Defensive check: guard against too many samples which would overflow
+   * the fixed-size srcbuffs array. Fail early if spp exceeds MAX_SAMPLES.
+   */
+  if (spp > MAX_SAMPLES)
+    {
+    TIFFError ("readSeparateTilesIntoBuffer",
+               "Number of samples per pixel (%u) exceeds supported limit (%u)",
+               (unsigned) spp, (unsigned) MAX_SAMPLES);
+    return 0;
+    }
+
   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
     {
     srcbuffs[sample] = NULL;
@@ -989,8 +1019,40 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
     nrow = (row + tl > imagelength) ? imagelength - row : tl;
     for (col = 0; col < imagewidth; col += tw)
       {
-      for (s = 0; s < spp; s++)
+// FIXME: Crash CWE-125: Out-of-bounds Read
+       for (s = 0; s < spp; s++)
         {  /* Read each plane of a tile set into srcbuffs[s] */
+	/* Ensure we never index past the fixed-size srcbuffs array. */
+	if (s >= MAX_SAMPLES)
+	  {
+	  TIFFError(TIFFFileName(in),
+	            "Error: sample index %u exceeds MAX_SAMPLES (%u)",
+	            (unsigned) s, (unsigned) MAX_SAMPLES);
+	  status = 0;
+	  for (sample = 0; (sample < MAX_SAMPLES); sample++)
+	    {
+	    tbuff = srcbuffs[sample];
+	    if (tbuff != NULL)
+	      _TIFFfree(tbuff);
+	    }
+	  return status;
+	  }
+	
+	/* Defensive: ensure the buffer for this sample was allocated. */
+	if (srcbuffs[s] == NULL)
+	  {
+	  TIFFError(TIFFFileName(in),
+	            "Error, no buffer available for sample %u", (unsigned) s);
+	  status = 0;
+	  for (sample = 0; (sample < MAX_SAMPLES); sample++)
+	    {
+	    tbuff = srcbuffs[sample];
+	    if (tbuff != NULL)
+	      _TIFFfree(tbuff);
+	    }
+	  return status;
+	  }
+	
 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
         if (tbytes < 0  && !ignore)
           {
@@ -1000,7 +1062,7 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
 		 (unsigned long) col, (unsigned long) row,
 		 (unsigned long) s);
 		 status = 0;
-          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
+          for (sample = 0; (sample < MAX_SAMPLES); sample++)
             {
             tbuff = srcbuffs[sample];
             if (tbuff != NULL)
