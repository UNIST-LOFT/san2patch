diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index d959ae30..a5108d58 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -965,6 +965,16 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
   unsigned char *srcbuffs[MAX_SAMPLES];
   unsigned char *tbuff = NULL;
 
+  /* Rationale:
+   * The original code allocated srcbuffs only for up to MAX_SAMPLES entries
+   * (via the allocation loop below), but later indexed srcbuffs with 's'
+   * running from 0..spp-1 unconditionally. If spp > MAX_SAMPLES this
+   * produced a stack-buffer-overflow. To avoid that we reject images with
+   * spp > MAX_SAMPLES early, free any buffers allocated so far and return
+   * an error. This keeps behavior identical for supported images and
+   * prevents out-of-bounds access without changing other logic.
+   */
+
   bytes_per_sample = (bps + 7) / 8;
 
   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
@@ -980,7 +990,26 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
       return 0;
       }
     srcbuffs[sample] = tbuff;
-    } 
+    }
+
+  /* Prevent out-of-bounds access: if the image has more samples per pixel
+   * than MAX_SAMPLES, we cannot safely index the stack array srcbuffs[]
+   * and must fail instead of continuing and corrupting the stack.
+   */
+  if (spp > MAX_SAMPLES)
+    {
+    TIFFError("readSeparateTilesIntoBuffer",
+              "Image has %u samples per pixel, exceeds MAX_SAMPLES (%d)",
+              (unsigned)spp, MAX_SAMPLES);
+    /* free any buffers allocated above */
+    for (i = 0; i < sample; i++)
+      {
+      if (srcbuffs[i] != NULL)
+        _TIFFfree(srcbuffs[i]);
+      }
+    return 0;
+    }
+
   /* Each tile contains only the data for a single plane
    * arranged in scanlines of tw * bytes_per_sample bytes.
    */
@@ -989,7 +1018,8 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
     nrow = (row + tl > imagelength) ? imagelength - row : tl;
     for (col = 0; col < imagewidth; col += tw)
       {
-      for (s = 0; s < spp; s++)
+// FIXME: Crash
+       for (s = 0; s < spp; s++)
         {  /* Read each plane of a tile set into srcbuffs[s] */
 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
         if (tbytes < 0  && !ignore)
