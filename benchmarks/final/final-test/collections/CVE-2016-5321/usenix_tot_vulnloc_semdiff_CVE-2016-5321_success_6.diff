diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index d959ae30..f948242f 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -984,18 +984,24 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
   /* Each tile contains only the data for a single plane
    * arranged in scanlines of tw * bytes_per_sample bytes.
    */
-  for (row = 0; row < imagelength; row += tl)
+for (row = 0; row < imagelength; row += tl)
     {
     nrow = (row + tl > imagelength) ? imagelength - row : tl;
-    for (col = 0; col < imagewidth; col += tw)
-      {
-      for (s = 0; s < spp; s++)
+/* Rationale: Prevent out-of-bounds access to the stack array 'srcbuffs'.
+   Compute the actual number of elements in srcbuffs at runtime and cap
+   the sample-loop to that value so indexing srcbuffs[s] cannot exceed
+   the allocated array. This is a minimal change that avoids buffer
+   overflow (CWE-119) and consequent out-of-bounds reads (CWE-125).
+*/
+     for (col = 0; col < imagewidth; col += tw)
+      {
+      int max_s = (int)(sizeof(srcbuffs)/sizeof(srcbuffs[0]));
+      for (s = 0; s < spp && s < max_s; s++)
         {  /* Read each plane of a tile set into srcbuffs[s] */
 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
         if (tbytes < 0  && !ignore)
           {
-	  TIFFError(TIFFFileName(in),
-                 "Error, can't read tile for row %lu col %lu, "
+	TIFFError(TIFFFileName(in),                 "Error, can't read tile for row %lu col %lu, "
 		 "sample %lu",
 		 (unsigned long) col, (unsigned long) row,
 		 (unsigned long) s);
