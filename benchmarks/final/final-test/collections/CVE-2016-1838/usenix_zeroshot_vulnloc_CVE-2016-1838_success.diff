diff --git a/parser.c b/parser.c
index 68e1c90f..d5e390ac 100644
--- a/parser.c
+++ b/parser.c
@@ -9811,6 +9811,7 @@ base_changed:
  * @ctxt:  an XML parser context
  * @line:  line of the start tag
  * @nsNr:  number of namespaces on the start tag
+ * @tlen:  length of the token to compare
  *
  * parse an end of tag
  *
@@ -9832,21 +9833,43 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
 	return;
     }
     SKIP(2);
+// FIXME: Crash
 
-    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
-        if (ctxt->input->cur[tlen] == '>') {
-	    ctxt->input->cur += tlen + 1;
-	    ctxt->input->col += tlen + 1;
-	    goto done;
-	}
-	ctxt->input->cur += tlen;
-	ctxt->input->col += tlen;
-	name = (xmlChar*)1;
-    } else {
-	if (prefix == NULL)
-	    name = xmlParseNameAndCompare(ctxt, ctxt->name);
-	else
-	    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+    /*
+     * Rationale:
+     * The previous code compared the next tlen bytes at ctxt->input->cur against
+     * ctxt->name without ensuring that tlen bytes were actually available in the
+     * input buffer, which can lead to a heap-buffer-overflow when the buffer is
+     * shorter than tlen. To prevent out-of-bounds reads we check how many bytes
+     * remain in the current input buffer (ctxt->input->end - ctxt->input->cur)
+     * and only perform the fast-path comparison when enough bytes are present.
+     * If there are not enough bytes available we fall back to the safer parsing
+     * helpers xmlParseNameAndCompare/xmlParseQNameAndCompare which handle
+     * buffering correctly.
+     */
+    {
+        size_t avail = 0;
+        if ((ctxt->input != NULL) && (ctxt->input->end > ctxt->input->cur))
+            avail = (size_t)(ctxt->input->end - ctxt->input->cur);
+
+        if ((tlen > 0) && (avail >= (size_t)tlen) &&
+            (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+            /* ensure we can access ctxt->input->cur[tlen] safely */
+            if (avail > (size_t)tlen && ctxt->input->cur[tlen] == '>') {
+		ctxt->input->cur += tlen + 1;
+		ctxt->input->col += tlen + 1;
+		goto done;
+            }
+            /* advance by tlen only if the bytes were available */
+            ctxt->input->cur += tlen;
+            ctxt->input->col += tlen;
+            name = (xmlChar*)1;
+        } else {
+            if (prefix == NULL)
+                name = xmlParseNameAndCompare(ctxt, ctxt->name);
+            else
+                name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+        }
     }
 
     /*
@@ -9865,6 +9888,7 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
      * [ WFC: Element Type Match ]
      * The Name in an element's end-tag must match the element type in the
      * start-tag.
+
      *
      */
     if (name != (xmlChar*)1) {
