diff --git a/parser.c b/parser.c
index 68e1c90f..d8e0c945 100644
--- a/parser.c
+++ b/parser.c
@@ -9811,6 +9811,7 @@ base_changed:
  * @ctxt:  an XML parser context
  * @line:  line of the start tag
  * @nsNr:  number of namespaces on the start tag
+ * @tlen:  length of the saved start tag name to compare
  *
  * parse an end of tag
  *
@@ -9832,21 +9833,57 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
 	return;
     }
     SKIP(2);
+// FIXME: Crash CWE-125: Out-of-bounds Read
 
-    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
-        if (ctxt->input->cur[tlen] == '>') {
-	    ctxt->input->cur += tlen + 1;
-	    ctxt->input->col += tlen + 1;
-	    goto done;
-	}
-	ctxt->input->cur += tlen;
-	ctxt->input->col += tlen;
-	name = (xmlChar*)1;
-    } else {
-	if (prefix == NULL)
-	    name = xmlParseNameAndCompare(ctxt, ctxt->name);
-	else
-	    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+    /*
+     * Rationale: compute remaining bytes and ensure any direct indexed
+     * read (like ctxt->input->cur[tlen]) or multi-byte comparisons
+     * (xmlStrncmp with length tlen) are bounded by the available
+     * bytes. If the input is truncated, report an error instead of
+     * performing the out-of-bounds read.
+     */
+    {
+        size_t rem = (size_t)(ctxt->input->end - ctxt->input->cur);
+
+        if ((tlen > 0) && (rem >= (size_t)tlen) &&
+            (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+            /* We matched the saved name for tlen bytes. Now check if
+             * we have at least one more byte to safely test ctxt->input->cur[tlen]
+             */
+            if (rem > (size_t)tlen) {
+                if (ctxt->input->cur[tlen] == '>') {
+		    ctxt->input->cur += tlen + 1;
+		    ctxt->input->col += tlen + 1;
+		    goto done;
+		}
+		/* matched name but not '>' next: consume the name and continue
+		 * the normal parsing path which will validate the following
+		 * characters; advancing is safe because rem > tlen (we checked)
+		 */
+		ctxt->input->cur += tlen;
+		ctxt->input->col += tlen;
+		name = (xmlChar*)1;
+            } else {
+                /* matched tlen bytes but no following byte available => truncated */
+                xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
+                return;
+            }
+        } else {
+            /* If we do not have enough bytes even to perform the compare,
+             * fail early rather than allowing xmlParseNameAndCompare to
+             * scan beyond the buffer. Ensure there is at least one byte
+             * to attempt a name parse.
+             */
+            if (ctxt->input->cur >= ctxt->input->end) {
+                xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
+                return;
+            }
+
+            if (prefix == NULL)
+                name = xmlParseNameAndCompare(ctxt, ctxt->name);
+            else
+                name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+        }
     }
 
     /*
@@ -9856,7 +9893,10 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
     if (ctxt->instate == XML_PARSER_EOF)
         return;
     SKIP_BLANKS;
-    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
+    /* Ensure we have at least one byte to read RAW here. If not, it's truncated. */
+    if (ctxt->input->cur >= ctxt->input->end) {
+        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
+    } else if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
 	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
     } else
 	NEXT1;
@@ -9865,6 +9905,7 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
      * [ WFC: Element Type Match ]
      * The Name in an element's end-tag must match the element type in the
      * start-tag.
+
      *
      */
     if (name != (xmlChar*)1) {
