diff --git a/parser.c b/parser.c
index 68e1c90f..a0185c50 100644
--- a/parser.c
+++ b/parser.c
@@ -9832,8 +9832,8 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
 	return;
     }
     SKIP(2);
-
-    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+ 
+    if ((tlen > 0) && ((ctxt->input->end > ctxt->input->cur) && ((size_t)(ctxt->input->end - ctxt->input->cur) > (size_t)tlen)) /* bounds: ensure remaining > tlen */ && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
         if (ctxt->input->cur[tlen] == '>') {
 	    ctxt->input->cur += tlen + 1;
 	    ctxt->input->col += tlen + 1;
@@ -9872,8 +9872,8 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
         if ((line == 0) && (ctxt->node != NULL))
             line = ctxt->node->line;
         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
-		     "Opening and ending tag mismatch: %s line %d and %s\n",
-		                ctxt->name, line, name);
+		 "Opening and ending tag mismatch: %s line %d and %s\n",
+				ctxt->name, line, name);
     }
 
     /*
@@ -9890,6 +9890,11 @@ done:
     return;
 }
 
+/* Rationale: The added condition ensures the remaining bytes in the input
+   buffer are strictly greater than tlen, making both the xmlStrncmp (which
+   reads tlen bytes) and the subsequent access to ctxt->input->cur[tlen]
+   safe. This is a minimal, localized bounds check and differs from other
+   candidates by using the strict '>' check without explicit NULL checks. */
 /**
  * xmlParseCDSect:
  * @ctxt:  an XML parser context
