diff --git a/parser.c b/parser.c
index 68e1c90f..b085f724 100644
--- a/parser.c
+++ b/parser.c
@@ -9832,21 +9832,55 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
 	return;
     }
     SKIP(2);
+// FIXME: Crash CWE-125: Out-of-bounds Read
 
-    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
-        if (ctxt->input->cur[tlen] == '>') {
-	    ctxt->input->cur += tlen + 1;
-	    ctxt->input->col += tlen + 1;
-	    goto done;
-	}
-	ctxt->input->cur += tlen;
-	ctxt->input->col += tlen;
-	name = (xmlChar*)1;
-    } else {
-	if (prefix == NULL)
-	    name = xmlParseNameAndCompare(ctxt, ctxt->name);
-	else
-	    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+    /*
+     * Fix: ensure we have enough available bytes in the input buffer before
+     * performing a string compare of length tlen and before indexing
+     * ctxt->input->cur[tlen]. If the buffer is too small, try to GROW the
+     * buffer (which will request more data) and re-check. This prevents
+     * reads past the end of the input buffer that lead to heap-buffer-overflow.
+     */
+    {
+        size_t avail = 0;
+        if (ctxt->input->end > ctxt->input->cur)
+            avail = (size_t)(ctxt->input->end - ctxt->input->cur);
+
+        if ((tlen > 0) && (avail >= (size_t)tlen) &&
+            (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+            /* We matched the name for tlen characters. Ensure we can safely
+             * check the following character for '>' (need at least tlen+1 bytes).
+             */
+            if (avail > (size_t)tlen) {
+                if (ctxt->input->cur[tlen] == '>') {
+                    ctxt->input->cur += tlen + 1;
+                    ctxt->input->col += tlen + 1;
+                    goto done;
+                }
+            } else {
+                /* not enough data now, try to grow and re-evaluate */
+                GROW;
+                if (ctxt->instate == XML_PARSER_EOF)
+                    return;
+                if (ctxt->input->end > ctxt->input->cur)
+                    avail = (size_t)(ctxt->input->end - ctxt->input->cur);
+                if (avail > (size_t)tlen && ctxt->input->cur[tlen] == '>') {
+                    ctxt->input->cur += tlen + 1;
+                    ctxt->input->col += tlen + 1;
+                    goto done;
+                }
+            }
+
+            /* advance past the name portion we matched */
+            ctxt->input->cur += tlen;
+            ctxt->input->col += tlen;
+            name = (xmlChar*)1;
+        } else {
+            if (prefix == NULL)
+                name = xmlParseNameAndCompare(ctxt, ctxt->name);
+            else
+                name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+        }
     }
 
     /*
@@ -9865,6 +9899,7 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
      * [ WFC: Element Type Match ]
      * The Name in an element's end-tag must match the element type in the
      * start-tag.
+
      *
      */
     if (name != (xmlChar*)1) {
@@ -10227,7 +10262,7 @@ xmlParseElement(xmlParserCtxtPtr ctxt) {
     if (!IS_BYTE_CHAR(RAW)) {
         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
 	 "Premature end of data in tag %s line %d\n",
-		                name, line, NULL);
+				        name, line, NULL);
 
 	/*
 	 * end of parsing of this node.
@@ -10242,7 +10277,49 @@ xmlParseElement(xmlParserCtxtPtr ctxt) {
 
     /*
      * parse the end of tag: '</' should be here.
+     *
+     * Rationale: Prevent reads past the end of the input buffer by verifying
+     * there is a '>' terminator inside the remaining input before calling
+     * xmlParseEndTag2/xmlParseEndTag1. Without this check, the end-tag
+     * scanning can advance past the allocated buffer when input is
+     * truncated, leading to a heap out-of-bounds read (CWE-125).
      */
+    {
+	const xmlChar *tmp = CUR_PTR;
+	const xmlChar *end = ctxt->input->end;
+	/* If there's nothing left, bail out as premature end of tag. */
+	if (tmp >= end) {
+	    xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
+				    "Premature end of data in tag %s line %d\n",
+				    name, line, NULL);
+
+	    /*
+	     * end of parsing of this node.
+	     */
+	    nodePop(ctxt);
+	    namePop(ctxt);
+	    spacePop(ctxt);
+	    if (nsNr != ctxt->nsNr)
+		nsPop(ctxt, ctxt->nsNr - nsNr);
+	    return;
+	}
+
+	/* Scan forward within bounds to find '>' terminator. */
+	while (tmp < end && *tmp != '>') tmp++;
+	if (tmp >= end) {
+	    /* No '>' found in remaining buffer: treat as truncated tag. */
+	    xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
+				    "Premature end of data in tag %s line %d\n",
+				    name, line, NULL);
+	    nodePop(ctxt);
+	    namePop(ctxt);
+	    spacePop(ctxt);
+	    if (nsNr != ctxt->nsNr)
+		nsPop(ctxt, ctxt->nsNr - nsNr);
+	    return;
+	}
+    }
+
     if (ctxt->sax2) {
 	xmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);
 	namePop(ctxt);
@@ -10275,6 +10352,7 @@ xmlParseElement(xmlParserCtxtPtr ctxt) {
  * In practice allow [0-9].[0-9]+ at that level
  *
  * Returns the string giving the XML version number, or NULL
+
  */
 xmlChar *
 xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
