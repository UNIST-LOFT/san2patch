diff --git a/parser.c b/parser.c
index 68e1c90f..72ffffe1 100644
--- a/parser.c
+++ b/parser.c
@@ -9825,28 +9825,57 @@ static void
 xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
                 const xmlChar *URI, int line, int nsNr, int tlen) {
     const xmlChar *name;
+    int avail = 0;
 
     GROW;
     if ((RAW != '<') || (NXT(1) != '/')) {
-	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
-	return;
+        xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
+        return;
     }
     SKIP(2);
-
-    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
-        if (ctxt->input->cur[tlen] == '>') {
-	    ctxt->input->cur += tlen + 1;
-	    ctxt->input->col += tlen + 1;
-	    goto done;
-	}
-	ctxt->input->cur += tlen;
-	ctxt->input->col += tlen;
-	name = (xmlChar*)1;
+// FIXME: Crash CWE-125: Out-of-bounds Read
+
+    /* Rationale:
+     * Ensure we never index past the available input buffer. Compute the
+     * available bytes and only call xmlStrncmp or index into cur[] when
+     * there are enough bytes. If not enough bytes are available to safely
+     * perform the direct comparison, fall back to the name-parsing helpers
+     * which handle streaming/truncated input, or fail-fast if the delimiter
+     * cannot be inspected.
+     */
+    if (tlen > 0) {
+        avail = (int)(ctxt->input->end - ctxt->input->cur);
+        if ((avail >= tlen) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+            /* we matched the name for tlen bytes; ensure we can read the delimiter */
+            if (avail >= tlen + 1) {
+                if (ctxt->input->cur[tlen] == '>') {
+                    ctxt->input->cur += tlen + 1;
+                    ctxt->input->col += tlen + 1;
+                    goto done;
+                }
+                ctxt->input->cur += tlen;
+                ctxt->input->col += tlen;
+                name = (xmlChar*)1;
+            } else {
+                /* truncated end-tag: not enough bytes for delimiter */
+                xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
+                return;
+            }
+        } else {
+            /* Either name didn't match in-place or not enough bytes for compare;
+             * fall back to the safe name-parsing helpers which handle streaming
+             * and ensure bounds checks.
+             */
+            if (prefix == NULL)
+                name = xmlParseNameAndCompare(ctxt, ctxt->name);
+            else
+                name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+        }
     } else {
-	if (prefix == NULL)
-	    name = xmlParseNameAndCompare(ctxt, ctxt->name);
-	else
-	    name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
+        if (prefix == NULL)
+            name = xmlParseNameAndCompare(ctxt, ctxt->name);
+        else
+            name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix);
     }
 
     /*
@@ -9857,9 +9886,9 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
         return;
     SKIP_BLANKS;
     if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
-	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
+        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
     } else
-	NEXT1;
+        NEXT1;
 
     /*
      * [ WFC: Element Type Match ]
@@ -9872,8 +9901,8 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
         if ((line == 0) && (ctxt->node != NULL))
             line = ctxt->node->line;
         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
-		     "Opening and ending tag mismatch: %s line %d and %s\n",
-		                ctxt->name, line, name);
+             "Opening and ending tag mismatch: %s line %d and %s\n",
+                        ctxt->name, line, name);
     }
 
     /*
@@ -9881,15 +9910,16 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
      */
 done:
     if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
-	(!ctxt->disableSAX))
-	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);
+        (!ctxt->disableSAX))
+        ctxt->sax->endElementNs(ctxt->userData, ctxt->name, prefix, URI);
 
     spacePop(ctxt);
     if (nsNr != 0)
-	nsPop(ctxt, nsNr);
+        nsPop(ctxt, nsNr);
     return;
 }
 
+
 /**
  * xmlParseCDSect:
  * @ctxt:  an XML parser context
