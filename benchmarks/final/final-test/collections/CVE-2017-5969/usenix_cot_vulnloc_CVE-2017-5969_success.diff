diff --git a/valid.c b/valid.c
index 9b2df56a..5b03aa10 100644
--- a/valid.c
+++ b/valid.c
@@ -1157,6 +1157,18 @@ xmlFreeElementContent(xmlElementContentPtr cur) {
  */
 static void
 xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {
+    /*
+     * Rationale for the fix:
+     * The original implementation dereferenced content->c1, content->c2,
+     * content->name and content->prefix without checking for NULL. When
+     * any of these fields are NULL a NULL pointer dereference can
+     * occur (CWE-476). To fix this we add defensive NULL checks before
+     * accessing these members. If a child node (c1 or c2) is NULL we
+     * simply skip dumping it. If name or prefix is NULL we skip writing
+     * them. This preserves existing behavior for valid data while
+     * preventing crashes for malformed or incomplete element content
+     * structures.
+     */
     if (content == NULL) return;
 
     if (glob) xmlBufferWriteChar(buf, "(");
@@ -1169,40 +1181,60 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
 		xmlBufferWriteCHAR(buf, content->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, content->name);
+	    if (content->name != NULL) {
+		xmlBufferWriteCHAR(buf, content->name);
+	    }
 	    break;
 	case XML_ELEMENT_CONTENT_SEQ:
-	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
-	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
-		xmlDumpElementContent(buf, content->c1, 1);
-	    else
-		xmlDumpElementContent(buf, content->c1, 0);
-            xmlBufferWriteChar(buf, " , ");
-	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
-	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
-		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
-		xmlDumpElementContent(buf, content->c2, 1);
-	    else
-		xmlDumpElementContent(buf, content->c2, 0);
+	{
+	    xmlElementContentPtr c1 = content->c1;
+	    xmlElementContentPtr c2 = content->c2;
+
+	    if (c1 != NULL) {
+		if ((c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, c1, 1);
+		else
+		    xmlDumpElementContent(buf, c1, 0);
+	    }
+	    xmlBufferWriteChar(buf, " , ");
+	    if (c2 != NULL) {
+		if ((c2->type == XML_ELEMENT_CONTENT_OR) ||
+		    ((c2->type == XML_ELEMENT_CONTENT_SEQ) &&
+		     (c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, c2, 1);
+		else
+		    xmlDumpElementContent(buf, c2, 0);
+	    }
 	    break;
+	}
 	case XML_ELEMENT_CONTENT_OR:
-	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
-	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
-		xmlDumpElementContent(buf, content->c1, 1);
-	    else
-		xmlDumpElementContent(buf, content->c1, 0);
-            xmlBufferWriteChar(buf, " | ");
-	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
-	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
-		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
-		xmlDumpElementContent(buf, content->c2, 1);
-	    else
-		xmlDumpElementContent(buf, content->c2, 0);
+	{
+	    xmlElementContentPtr c1 = content->c1;
+	    xmlElementContentPtr c2 = content->c2;
+
+	    if (c1 != NULL) {
+		if ((c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, c1, 1);
+		else
+		    xmlDumpElementContent(buf, c1, 0);
+	    }
+	    xmlBufferWriteChar(buf, " | ");
+	    if (c2 != NULL) {
+		if ((c2->type == XML_ELEMENT_CONTENT_SEQ) ||
+		    ((c2->type == XML_ELEMENT_CONTENT_OR) &&
+		     (c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, c2, 1);
+		else
+		    xmlDumpElementContent(buf, c2, 0);
+	    }
 	    break;
+	}
 	default:
 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
-		    "Internal: ELEMENT content corrupted invalid type\n",
-		    NULL);
+	        "Internal: ELEMENT content corrupted invalid type\n",
+	        NULL);
     }
     if (glob)
         xmlBufferWriteChar(buf, ")");
