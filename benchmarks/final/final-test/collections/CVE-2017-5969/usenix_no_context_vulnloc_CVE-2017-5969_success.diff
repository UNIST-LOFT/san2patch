diff --git a/valid.c b/valid.c
index 9b2df56a..35041f53 100644
--- a/valid.c
+++ b/valid.c
@@ -1157,6 +1157,13 @@ xmlFreeElementContent(xmlElementContentPtr cur) {
  */
 static void
 xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {
+    /* Rationale:
+     * Defensive checks added to avoid NULL dereferences when content->c1 or
+     * content->c2 are missing in malformed inputs. If a child pointer is
+     * NULL, emit a safe placeholder when a buffer is provided so the dump
+     * remains informative, and skip dereferences. This prevents the
+     * AddressSanitizer-reported SEGV while preserving normal behavior.
+     */
     if (content == NULL) return;
 
     if (glob) xmlBufferWriteChar(buf, "(");
@@ -1169,42 +1176,75 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
 		xmlBufferWriteCHAR(buf, content->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, content->name);
+	    /* name might be NULL in malformed inputs, protect against that */
+	    if (content->name != NULL)
+		xmlBufferWriteCHAR(buf, content->name);
+	    else if (buf)
+		xmlBufferWriteChar(buf, "(null-name)");
 	    break;
 	case XML_ELEMENT_CONTENT_SEQ:
-	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
-	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
-		xmlDumpElementContent(buf, content->c1, 1);
-	    else
-		xmlDumpElementContent(buf, content->c1, 0);
-            xmlBufferWriteChar(buf, " , ");
-	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
-	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
-		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
-		xmlDumpElementContent(buf, content->c2, 1);
-	    else
-		xmlDumpElementContent(buf, content->c2, 0);
+	{
+	    /* Avoid dereferencing content->c1 or content->c2 when NULL */
+	    xmlElementContentPtr c1 = content->c1;
+	    xmlElementContentPtr c2 = content->c2;
+	
+	    if (c1 == NULL) {
+		if (buf) xmlBufferWriteChar(buf, "(null-content)");
+	    } else {
+		if ((c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, c1, 1);
+		else
+		    xmlDumpElementContent(buf, c1, 0);
+	    }
+	    xmlBufferWriteChar(buf, " , ");
+	    if (c2 == NULL) {
+		if (buf) xmlBufferWriteChar(buf, "(null-content)");
+	    } else {
+		if ((c2->type == XML_ELEMENT_CONTENT_OR) ||
+		    ((c2->type == XML_ELEMENT_CONTENT_SEQ) &&
+		     (c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, c2, 1);
+		else
+		    xmlDumpElementContent(buf, c2, 0);
+	    }
+	}
 	    break;
 	case XML_ELEMENT_CONTENT_OR:
-	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
-	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
-		xmlDumpElementContent(buf, content->c1, 1);
-	    else
-		xmlDumpElementContent(buf, content->c1, 0);
-            xmlBufferWriteChar(buf, " | ");
-	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
-	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
-		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
-		xmlDumpElementContent(buf, content->c2, 1);
-	    else
-		xmlDumpElementContent(buf, content->c2, 0);
+	{
+	    /* Similarly protect c1 and c2 here */
+	    xmlElementContentPtr c1 = content->c1;
+	    xmlElementContentPtr c2 = content->c2;
+	
+	    if (c1 == NULL) {
+		if (buf) xmlBufferWriteChar(buf, "(null-content)");
+	    } else {
+		if ((c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, c1, 1);
+		else
+		    xmlDumpElementContent(buf, c1, 0);
+	    }
+	    xmlBufferWriteChar(buf, " | ");
+	    if (c2 == NULL) {
+		if (buf) xmlBufferWriteChar(buf, "(null-content)");
+	    } else {
+		if ((c2->type == XML_ELEMENT_CONTENT_SEQ) ||
+		    ((c2->type == XML_ELEMENT_CONTENT_OR) &&
+		     (c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, c2, 1);
+		else
+		    xmlDumpElementContent(buf, c2, 0);
+	    }
+	}
 	    break;
 	default:
 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
-		    "Internal: ELEMENT content corrupted invalid type\n",
-		    NULL);
+	            "Internal: ELEMENT content corrupted invalid type\n",
+	            NULL);
     }
     if (glob)
+
         xmlBufferWriteChar(buf, ")");
     switch (content->ocur) {
         case XML_ELEMENT_CONTENT_ONCE:
@@ -1683,8 +1723,8 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
-	    xmlBufferWriteChar(buf, " ANY>\n");
+		xmlBufferWriteCHAR(buf, elem->name);
+		xmlBufferWriteChar(buf, " ANY>\n");
 	    break;
 	case XML_ELEMENT_TYPE_MIXED:
 	    xmlBufferWriteChar(buf, "<!ELEMENT ");
@@ -1692,9 +1732,29 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
+	/* Rationale: Add defensive checks to avoid NULL dereferences when elem,
+	   elem->name or elem->content can be missing in malformed inputs.
+	   If elem or elem->name is NULL, emit a safe placeholder instead of
+	   calling xmlBufferWriteCHAR with a NULL pointer. If elem->content is
+	   NULL skip the recursive dump and emit a placeholder so we don't
+	   dereference content. */
+	    if (elem == NULL) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT struct is NULL\n",
+			NULL);
+		return;
+	    }
+	    if (elem->name == NULL) {
+		xmlBufferWriteChar(buf, "(null)");
+	    } else {
+		xmlBufferWriteCHAR(buf, elem->name);
+	    }
 	    xmlBufferWriteChar(buf, " ");
-	    xmlDumpElementContent(buf, elem->content, 1);
+	    if (elem->content != NULL) {
+		xmlDumpElementContent(buf, elem->content, 1);
+	    } else {
+		xmlBufferWriteChar(buf, "(missing-content)");
+	    }
 	    xmlBufferWriteChar(buf, ">\n");
 	    break;
 	case XML_ELEMENT_TYPE_ELEMENT:
@@ -1703,9 +1763,25 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
+	/* Rationale: Mirror the checks used in MIXED case to avoid NULL
+	   pointer dereferences when handling element declarations. */
+	    if (elem == NULL) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT struct is NULL\n",
+			NULL);
+		return;
+	    }
+	    if (elem->name == NULL) {
+		xmlBufferWriteChar(buf, "(null)");
+	    } else {
+		xmlBufferWriteCHAR(buf, elem->name);
+	    }
 	    xmlBufferWriteChar(buf, " ");
-	    xmlDumpElementContent(buf, elem->content, 1);
+	    if (elem->content != NULL) {
+		xmlDumpElementContent(buf, elem->content, 1);
+	    } else {
+		xmlBufferWriteChar(buf, "(missing-content)");
+	    }
 	    xmlBufferWriteChar(buf, ">\n");
 	    break;
 	default:
