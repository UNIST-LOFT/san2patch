diff --git a/valid.c b/valid.c
index 9b2df56a..41cf7ed3 100644
--- a/valid.c
+++ b/valid.c
@@ -1148,17 +1148,98 @@ xmlFreeElementContent(xmlElementContentPtr cur) {
 
 #ifdef LIBXML_OUTPUT_ENABLED
 /**
+ /*
  * xmlDumpElementContent:
  * @buf:  An XML buffer
  * @content:  An element table
  * @glob: 1 if one must print the englobing parenthesis, 0 otherwise
  *
  * This will dump the content of the element table as an XML DTD definition
+ *
+ * Rationale for changes:
+ * The original code dereferenced content->c1 and content->c2 without
+ * verifying they were non-NULL, which could lead to SEGVs when malformed
+ * element content structures are encountered. The sanitizer output showed a
+ * read at address 0x0 inside this function. To fix this we add defensive
+ * NULL checks before accessing c1/c2 and only emit separators ("," or "|")
+ * when appropriate. In one variant we instead report an internal error if
+ * a required child is missing. Multiple implementation variants are
+ * provided below via preprocessor conditionals; the active variant (#if 1)
+ * performs graceful skipping of missing children while preserving output
+ * semantics for well-formed inputs.
  */
 static void
 xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {
     if (content == NULL) return;
 
+#if 1
+    /* Variant 1: defensive NULL checks and graceful skipping. */
+    if (glob) xmlBufferWriteChar(buf, "(");
+    switch (content->type) {
+        case XML_ELEMENT_CONTENT_PCDATA:
+            xmlBufferWriteChar(buf, "#PCDATA");
+	    break;
+	case XML_ELEMENT_CONTENT_ELEMENT:
+	    if (content->prefix != NULL) {
+		xmlBufferWriteCHAR(buf, content->prefix);
+		xmlBufferWriteChar(buf, ":");
+	    }
+	    if (content->name != NULL)
+		xmlBufferWriteCHAR(buf, content->name);
+	    break;
+	case XML_ELEMENT_CONTENT_SEQ:
+	    /* c1 may be NULL in malformed inputs, guard accesses */
+	    if (content->c1 != NULL) {
+		if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, content->c1, 1);
+		else
+		    xmlDumpElementContent(buf, content->c1, 0);
+	    }
+	    /* Only write separator if both sides exist (or at least the right exists) */
+	    if (content->c2 != NULL) {
+		if (content->c1 != NULL)
+		    xmlBufferWriteChar(buf, " , ");
+		if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
+		    ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
+		     (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, content->c2, 1);
+		else
+		    xmlDumpElementContent(buf, content->c2, 0);
+	    }
+	    break;
+	case XML_ELEMENT_CONTENT_OR:
+	    if (content->c1 != NULL) {
+		if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, content->c1, 1);
+		else
+		    xmlDumpElementContent(buf, content->c1, 0);
+	    }
+	    if (content->c2 != NULL) {
+		if (content->c1 != NULL)
+		    xmlBufferWriteChar(buf, " | ");
+		if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
+		    ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
+		     (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, content->c2, 1);
+		else
+		    xmlDumpElementContent(buf, content->c2, 0);
+	    }
+	    break;
+	default:
+	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+	            "Internal: ELEMENT content corrupted invalid type\n",
+	            NULL);
+    }
+    if (glob)
+        xmlBufferWriteChar(buf, ")");
+    switch (content->ocur) {
+        case XML_ELEMENT_CONTENT_ONCE:
+	    break;
+
+#elif 0
+    /* Variant 2: treat missing children as internal error and report it. */
     if (glob) xmlBufferWriteChar(buf, "(");
     switch (content->type) {
         case XML_ELEMENT_CONTENT_PCDATA:
@@ -1169,15 +1250,22 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
 		xmlBufferWriteCHAR(buf, content->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, content->name);
+	    if (content->name != NULL)
+		xmlBufferWriteCHAR(buf, content->name);
 	    break;
 	case XML_ELEMENT_CONTENT_SEQ:
+	    if ((content->c1 == NULL) || (content->c2 == NULL)) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing child\n",
+			NULL);
+		break;
+	    }
 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
 	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
 		xmlDumpElementContent(buf, content->c1, 1);
 	    else
 		xmlDumpElementContent(buf, content->c1, 0);
-            xmlBufferWriteChar(buf, " , ");
+	    xmlBufferWriteChar(buf, " , ");
 	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
 	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
 		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
@@ -1186,12 +1274,18 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
 		xmlDumpElementContent(buf, content->c2, 0);
 	    break;
 	case XML_ELEMENT_CONTENT_OR:
+	    if ((content->c1 == NULL) || (content->c2 == NULL)) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing child\n",
+			NULL);
+		break;
+	    }
 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
 	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
 		xmlDumpElementContent(buf, content->c1, 1);
 	    else
 		xmlDumpElementContent(buf, content->c1, 0);
-            xmlBufferWriteChar(buf, " | ");
+	    xmlBufferWriteChar(buf, " | ");
 	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
 	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
 		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
@@ -1201,14 +1295,89 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
 	    break;
 	default:
 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
-		    "Internal: ELEMENT content corrupted invalid type\n",
-		    NULL);
+	            "Internal: ELEMENT content corrupted invalid type\n",
+	            NULL);
+    }
+    if (glob)
+        xmlBufferWriteChar(buf, ")");
+    switch (content->ocur) {
+        case XML_ELEMENT_CONTENT_ONCE:
+	    break;
+
+#else
+    /* Variant 3: treat NULL children as empty elements (print nothing but still
+     * keep separators only if both sides exist) - similar to Variant 1 but
+     * uses helper booleans for clarity.
+     */
+    if (glob) xmlBufferWriteChar(buf, "(");
+    switch (content->type) {
+        case XML_ELEMENT_CONTENT_PCDATA:
+            xmlBufferWriteChar(buf, "#PCDATA");
+	    break;
+	case XML_ELEMENT_CONTENT_ELEMENT:
+	    if (content->prefix != NULL) {
+		xmlBufferWriteCHAR(buf, content->prefix);
+		xmlBufferWriteChar(buf, ":");
+	    }
+	    if (content->name != NULL)
+		xmlBufferWriteCHAR(buf, content->name);
+	    break;
+	case XML_ELEMENT_CONTENT_SEQ: {
+	    int has_c1 = (content->c1 != NULL);
+	    int has_c2 = (content->c2 != NULL);
+	    if (has_c1) {
+		if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, content->c1, 1);
+		else
+		    xmlDumpElementContent(buf, content->c1, 0);
+	    }
+	    if (has_c2) {
+		if (has_c1)
+		    xmlBufferWriteChar(buf, " , ");
+		if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
+		    ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
+		     (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, content->c2, 1);
+		else
+		    xmlDumpElementContent(buf, content->c2, 0);
+	    }
+	    break;
+	}
+	case XML_ELEMENT_CONTENT_OR: {
+	    int has_c1 = (content->c1 != NULL);
+	    int has_c2 = (content->c2 != NULL);
+	    if (has_c1) {
+		if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
+		    xmlDumpElementContent(buf, content->c1, 1);
+		else
+		    xmlDumpElementContent(buf, content->c1, 0);
+	    }
+	    if (has_c2) {
+		if (has_c1)
+		    xmlBufferWriteChar(buf, " | ");
+		if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
+		    ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
+		     (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+		    xmlDumpElementContent(buf, content->c2, 1);
+		else
+		    xmlDumpElementContent(buf, content->c2, 0);
+	    }
+	    break;
+	}
+	default:
+	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+	            "Internal: ELEMENT content corrupted invalid type\n",
+	            NULL);
     }
     if (glob)
         xmlBufferWriteChar(buf, ")");
     switch (content->ocur) {
         case XML_ELEMENT_CONTENT_ONCE:
 	    break;
+#endif
+
         case XML_ELEMENT_CONTENT_OPT:
 	    xmlBufferWriteChar(buf, "?");
 	    break;
