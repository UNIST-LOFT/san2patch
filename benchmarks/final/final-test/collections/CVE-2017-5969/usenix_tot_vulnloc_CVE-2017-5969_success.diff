diff --git a/valid.c b/valid.c
index 9b2df56a..49e5c419 100644
--- a/valid.c
+++ b/valid.c
@@ -1160,7 +1160,13 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
     if (content == NULL) return;
 
     if (glob) xmlBufferWriteChar(buf, "(");
-    switch (content->type) {
+    /* Rationale:
+ * More tolerant handling: when a child pointer or name/prefix is missing,
+ * emit a conservative placeholder (" EMPTY" or "(malformed)") and record
+ * the condition via xmlErrValid. This avoids recursive calls on NULL and
+ * prevents crashes while giving a readable output for malformed DTDs.
+ */
+switch (content->type) {
         case XML_ELEMENT_CONTENT_PCDATA:
             xmlBufferWriteChar(buf, "#PCDATA");
 	    break;
@@ -1169,35 +1175,73 @@ xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob)
 		xmlBufferWriteCHAR(buf, content->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, content->name);
+	    if (content->name == NULL) {
+		/* Emit EMPTY as a conservative fallback and report */
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing name\n",
+			NULL);
+		xmlBufferWriteChar(buf, " EMPTY");
+	    } else {
+		xmlBufferWriteCHAR(buf, content->name);
+	    }
 	    break;
 	case XML_ELEMENT_CONTENT_SEQ:
-	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
-	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
-		xmlDumpElementContent(buf, content->c1, 1);
-	    else
-		xmlDumpElementContent(buf, content->c1, 0);
+	    if (content->c1 == NULL) {
+		/* Write placeholder for missing first element */
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing c1\n",
+			NULL);
+		xmlBufferWriteChar(buf, "(malformed)");
+	    } else {
+		if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
+			xmlDumpElementContent(buf, content->c1, 1);
+		else
+			xmlDumpElementContent(buf, content->c1, 0);
+	    }
             xmlBufferWriteChar(buf, " , ");
-	    if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
-	        ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
-		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
-		xmlDumpElementContent(buf, content->c2, 1);
-	    else
-		xmlDumpElementContent(buf, content->c2, 0);
+	    if (content->c2 == NULL) {
+		/* Write placeholder for missing second element */
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing c2\n",
+			NULL);
+		xmlBufferWriteChar(buf, "(malformed)");
+	    } else {
+		if ((content->c2->type == XML_ELEMENT_CONTENT_OR) ||
+		    ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) &&
+		     (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+			xmlDumpElementContent(buf, content->c2, 1);
+		else
+			xmlDumpElementContent(buf, content->c2, 0);
+	    }
 	    break;
 	case XML_ELEMENT_CONTENT_OR:
-	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
-	        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
-		xmlDumpElementContent(buf, content->c1, 1);
-	    else
-		xmlDumpElementContent(buf, content->c1, 0);
+	    if (content->c1 == NULL) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing c1\n",
+			NULL);
+		xmlBufferWriteChar(buf, "(malformed)");
+	    } else {
+		if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||
+		    (content->c1->type == XML_ELEMENT_CONTENT_SEQ))
+			xmlDumpElementContent(buf, content->c1, 1);
+		else
+			xmlDumpElementContent(buf, content->c1, 0);
+	    }
             xmlBufferWriteChar(buf, " | ");
-	    if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
-	        ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
-		 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
-		xmlDumpElementContent(buf, content->c2, 1);
-	    else
-		xmlDumpElementContent(buf, content->c2, 0);
+	    if (content->c2 == NULL) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content corrupted missing c2\n",
+			NULL);
+		xmlBufferWriteChar(buf, "(malformed)");
+	    } else {
+		if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||
+		    ((content->c2->type == XML_ELEMENT_CONTENT_OR) &&
+		     (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))
+			xmlDumpElementContent(buf, content->c2, 1);
+		else
+			xmlDumpElementContent(buf, content->c2, 0);
+	    }
 	    break;
 	default:
 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
@@ -1668,13 +1712,25 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
     if ((buf == NULL) || (elem == NULL))
         return;
     switch (elem->etype) {
+	/* Rationale: Add defensive checks and choose a conservative fallback
+	 * when the content model is missing. In this variant we treat a missing
+	 * content model as EMPTY to keep output compact and compatible, while
+	 * still reporting the problem via xmlErrValid.
+	 */
 	case XML_ELEMENT_TYPE_EMPTY:
 	    xmlBufferWriteChar(buf, "<!ELEMENT ");
 	    if (elem->prefix != NULL) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
+	    if (elem->name != NULL)
+		xmlBufferWriteCHAR(buf, elem->name);
+	    else {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT struct missing name\n",
+			NULL);
+		xmlBufferWriteCHAR(buf, "(null)");
+	    }
 	    xmlBufferWriteChar(buf, " EMPTY>\n");
 	    break;
 	case XML_ELEMENT_TYPE_ANY:
@@ -1683,7 +1739,14 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
+	    if (elem->name != NULL)
+		xmlBufferWriteCHAR(buf, elem->name);
+	    else {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT struct missing name\n",
+			NULL);
+		xmlBufferWriteCHAR(buf, "(null)");
+	    }
 	    xmlBufferWriteChar(buf, " ANY>\n");
 	    break;
 	case XML_ELEMENT_TYPE_MIXED:
@@ -1692,10 +1755,25 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
+	    if (elem->name != NULL)
+		xmlBufferWriteCHAR(buf, elem->name);
+	    else {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT struct missing name\n",
+			NULL);
+		xmlBufferWriteCHAR(buf, "(null)");
+	    }
 	    xmlBufferWriteChar(buf, " ");
-	    xmlDumpElementContent(buf, elem->content, 1);
-	    xmlBufferWriteChar(buf, ">\n");
+	    /* If content is missing treat conservatively as EMPTY but log error */
+	    if (elem->content == NULL) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content model missing, assuming EMPTY\n",
+			NULL);
+		xmlBufferWriteChar(buf, "EMPTY>\n");
+	    } else {
+		xmlDumpElementContent(buf, elem->content, 1);
+		xmlBufferWriteChar(buf, ">\n");
+	    }
 	    break;
 	case XML_ELEMENT_TYPE_ELEMENT:
 	    xmlBufferWriteChar(buf, "<!ELEMENT ");
@@ -1703,10 +1781,24 @@ xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 		xmlBufferWriteCHAR(buf, elem->prefix);
 		xmlBufferWriteChar(buf, ":");
 	    }
-	    xmlBufferWriteCHAR(buf, elem->name);
+	    if (elem->name != NULL)
+		xmlBufferWriteCHAR(buf, elem->name);
+	    else {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT struct missing name\n",
+			NULL);
+		xmlBufferWriteCHAR(buf, "(null)");
+	    }
 	    xmlBufferWriteChar(buf, " ");
-	    xmlDumpElementContent(buf, elem->content, 1);
-	    xmlBufferWriteChar(buf, ">\n");
+	    if (elem->content == NULL) {
+		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
+			"Internal: ELEMENT content model missing, assuming EMPTY\n",
+			NULL);
+		xmlBufferWriteChar(buf, "EMPTY>\n");
+	    } else {
+		xmlDumpElementContent(buf, elem->content, 1);
+		xmlBufferWriteChar(buf, ">\n");
+	    }
 	    break;
 	default:
 	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
