diff --git a/tools/tiff2ps.c b/tools/tiff2ps.c
index ae296e91..c7bc2a77 100644
--- a/tools/tiff2ps.c
+++ b/tools/tiff2ps.c
@@ -2424,9 +2424,9 @@ PSColorSeparatePreamble(FILE* fd, uint32 w, uint32 h, int nc)
 }
 
 #define	DOBREAK(len, howmany, fd) \
-	if (((len) -= (howmany)) <= 0) {	\
-		putc('\n', fd);			\
-		(len) = MAXLINE-(howmany);	\
+	if (((len) -= (howmany)) <= 0) {\
+		putc('\n', fd);\
+		(len) = MAXLINE-(howmany);\
 	}
 #define	PUTHEX(c,fd)	putc(hex[((c)>>4)&0xf],fd); putc(hex[(c)&0xf],fd)
 
@@ -2438,13 +2438,46 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 	tsize_t cc;
 	unsigned char *tf_buf;
 	unsigned char *cp, c;
-
+	// FIXME: Crash CWE-125: Out-of-bounds Read
+	
 	(void) w;
+	/*
+	 * SAFETY FIX (Candidate 3 - minimal & defensive): Keep using tf_bytesperrow
+	 * but validate it's large enough for at least 'samplesperpixel' bytes per pixel
+	 * and ensure loop bounds prevent any index from reaching tf_bytesperrow.
+	 * This adds explicit checks before any byte read, preventing the 1-byte OOB.
+	 */
+	
+	/* Basic sanity checks to avoid under-allocation or zero-size issues */
+	if (samplesperpixel <= 0) {
+		TIFFError(filename, "Invalid samples per pixel: %d", samplesperpixel);
+		return;
+	}
+	if (bitspersample <= 0) {
+		TIFFError(filename, "Invalid bits per sample: %d", bitspersample);
+		return;
+	}
+
+	/* Ensure tf_bytesperrow is not smaller than one sample per pixel (best-effort) */
+	if (tf_bytesperrow < (tsize_t)samplesperpixel) {
+		/* try to recover by computing a safe minimum using bits-per-sample */
+		tsize_t bytes_per_sample = (bitspersample + 7) / 8;
+		tsize_t min_required = bytes_per_sample * (tsize_t)samplesperpixel;
+		if (tf_bytesperrow < (tsize_t)min_required)
+		{
+			TIFFError(filename, "Scanline buffer too small (have %ld, need %ld)",
+			    (long)tf_bytesperrow, (long)min_required);
+			return;
+		}
+	}
+
+	/* allocate buffer and check result */
 	tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);
 	if (tf_buf == NULL) {
 		TIFFError(filename, "No space for scanline buffer");
 		return;
 	}
+
 	for (row = 0; row < h; row++) {
 		if (TIFFReadScanline(tif, tf_buf, row, 0) < 0)
 			break;
@@ -2459,18 +2492,23 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 		if (alpha) {
 			int adjust;
 			cc = 0;
-			for (; cc < tf_bytesperrow; cc += samplesperpixel) {
+			/*
+			 * iterate while ensuring that any access cp[nc] is strictly inside
+			 * the allocated buffer. Use cc + samplesperpixel <= tf_bytesperrow - 1
+			 * to guarantee cp[nc] will not read past the end. This fixes the
+			 * reported 1-byte read past allocation.
+			 */
+			for (; cc + (tsize_t)samplesperpixel <= tf_bytesperrow - 1; cc += samplesperpixel) {
 				DOBREAK(breaklen, nc, fd);
-				/*
-				 * For images with alpha, matte against
-				 * a white background; i.e.
-				 *    Cback * (1 - Aimage)
-				 * where Cback = 1.
-				 */
+				/* safety: ensure cp + nc is within buffer */
+				if (cc + (tsize_t)nc >= (tsize_t)tf_bytesperrow)
+					break;
+				cp = tf_buf + cc;
 				adjust = 255 - cp[nc];
 				switch (nc) {
 				case 4: c = *cp++ + adjust; PUTHEX(c,fd);
 				case 3: c = *cp++ + adjust; PUTHEX(c,fd);
+
 				case 2: c = *cp++ + adjust; PUTHEX(c,fd);
 				case 1: c = *cp++ + adjust; PUTHEX(c,fd);
 				}
