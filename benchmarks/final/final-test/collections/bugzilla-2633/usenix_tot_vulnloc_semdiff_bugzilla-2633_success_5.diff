diff --git a/tools/tiff2ps.c b/tools/tiff2ps.c
index ae296e91..bfa93c2e 100644
--- a/tools/tiff2ps.c
+++ b/tools/tiff2ps.c
@@ -2440,7 +2440,34 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 	unsigned char *cp, c;
 
 	(void) w;
-	tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);
+	/*
+	 * Rationale: compute the actual number of bytes required for a scanline
+	 * based on width, samples per pixel and bits per sample and allocate
+	 * that many bytes (with overflow checks). This prevents reads past the
+	 * allocated buffer in the loops below.
+	 */
+	{
+		size_t bytes_per_sample = (bitspersample + 7) / 8;
+		size_t spp = (size_t)samplesperpixel;
+		size_t scanline_bytes = 0;
+		/* check for multiplication overflow: w * spp * bytes_per_sample */
+		if (bytes_per_sample != 0 && spp != 0) {
+			/* Use (size_t)-1 as the maximum value instead of SIZE_MAX to
+			   avoid relying on SIZE_MAX being defined in the build
+			   environment. */
+			if ((size_t)w > ((size_t)-1) / spp / bytes_per_sample) {
+				TIFFError(filename, "scanline width too large");
+				return;
+			}
+			scanline_bytes = (size_t)w * spp * bytes_per_sample;
+		}
+		/* fallback to tf_bytesperrow if computed size is 0 (defensive) */
+		if (scanline_bytes == 0)
+			scanline_bytes = (size_t)tf_bytesperrow;
+
+		/* allocate the computed required size */
+		tf_buf = (unsigned char *) _TIFFmalloc((tsize_t)scanline_bytes);
+	}
 	if (tf_buf == NULL) {
 		TIFFError(filename, "No space for scanline buffer");
 		return;
@@ -2459,7 +2486,7 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 		if (alpha) {
 			int adjust;
 			cc = 0;
-			for (; cc < tf_bytesperrow; cc += samplesperpixel) {
+			for (; cc < (tsize_t)(size_t)tf_bytesperrow && cc < (tsize_t)((size_t)w * (size_t)samplesperpixel * ((bitspersample + 7)/8)); cc += samplesperpixel) {
 				DOBREAK(breaklen, nc, fd);
 				/*
 				 * For images with alpha, matte against
@@ -2467,6 +2494,9 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 				 *    Cback * (1 - Aimage)
 				 * where Cback = 1.
 				 */
+				/* ensure we don't read past the buffer */
+				if ((size_t)cc + (size_t)nc >= (size_t)tf_bytesperrow)
+					break;
 				adjust = 255 - cp[nc];
 				switch (nc) {
 				case 4: c = *cp++ + adjust; PUTHEX(c,fd);
@@ -2478,8 +2508,11 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 			}
 		} else {
 			cc = 0;
-			for (; cc < tf_bytesperrow; cc += samplesperpixel) {
+			for (; cc < (tsize_t)(size_t)tf_bytesperrow && cc < (tsize_t)((size_t)w * (size_t)samplesperpixel * ((bitspersample + 7)/8)); cc += samplesperpixel) {
 				DOBREAK(breaklen, nc, fd);
+				/* ensure we don't read past the buffer */
+				if ((size_t)cc + (size_t)samplesperpixel > (size_t)tf_bytesperrow)
+					break;
 				switch (nc) {
 				case 4: c = *cp++; PUTHEX(c,fd);
 				case 3: c = *cp++; PUTHEX(c,fd);
@@ -2493,6 +2526,7 @@ PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 	_TIFFfree((char *) tf_buf);
 }
 
+
 void
 PSDataColorSeparate(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
 {
