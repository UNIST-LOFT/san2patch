diff --git a/HTMLparser.c b/HTMLparser.c
index 69eed2bd..ff486fab 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2501,19 +2501,31 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
     }
 
     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
-	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
-            (c == '.') || (c == '-') ||
-	    (c == '_') || (c == ':') ||
-	    (IS_COMBINING(c)) ||
-	    (IS_EXTENDER(c)))) {
-	if (count++ > 100) {
-	    count = 0;
-	    GROW;
-	}
-	len += l;
-	NEXTL(l);
-	c = CUR_CHAR(l);
+   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
+    (c == '.') || (c == '-') ||
+    (c == '_') || (c == ':') ||
+    (IS_COMBINING(c)) ||
+    (IS_EXTENDER(c)))) {
+    /* Enforce a maximum name/entity length to avoid unbounded growth
+       that could cause later out-of-bounds reads when the parser
+       or dictionary routines assume a larger buffer. */
+    if (len + l > HTML_MAX_NAMELEN) {
+        return(NULL);
+    }
+    if (count++ > 100) {
+        count = 0;
+        GROW;
+        /* After attempting to grow, ensure there are at least 'l' bytes
+           available before accessing CUR_CHAR or NEXTL. If not, fail. */
+        if ((ctxt->input->cur + l) >= ctxt->input->end) {
+            return(NULL);
+        }
     }
+    len += l;
+    NEXTL(l);
+    c = CUR_CHAR(l);
+}
+
     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 }
 
