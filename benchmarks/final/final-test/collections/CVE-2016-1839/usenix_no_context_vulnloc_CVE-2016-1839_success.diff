diff --git a/HTMLparser.c b/HTMLparser.c
index 69eed2bd..badd8c7a 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2506,7 +2506,8 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 	    (c == '_') || (c == ':') ||
 	    (IS_COMBINING(c)) ||
 	    (IS_EXTENDER(c)))) {
-	if (count++ > 100) {
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 	if (count++ > 100) {
 	    count = 0;
 	    GROW;
 	}
@@ -2514,10 +2515,29 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 	NEXTL(l);
 	c = CUR_CHAR(l);
     }
+
+    /*
+     * Rationale:
+     * Place an application-level cap on name length to avoid excessive
+     * scanning and the risk of out-of-bounds accesses. After capping,
+     * ensure the capped length does not exceed the available buffer
+     * bytes. This provides robust protection against malformed or
+     * deliberately oversized inputs.
+     */
+    {
+        const int MAX_NAME_LEN = 8192; /* defensive maximum */
+        if (len > MAX_NAME_LEN) len = MAX_NAME_LEN;
+
+        const xmlChar *start = ctxt->input->cur - len;
+        ptrdiff_t avail = ctxt->input->end - start;
+        if (avail <= 0) return(NULL);
+        if ((ptrdiff_t)len > avail) len = (int)avail;
+    }
     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 }
 
 
+
 /**
  * htmlParseHTMLAttribute:
  * @ctxt:  an HTML parser context
diff --git a/dict.c b/dict.c
index c0585fe2..51488c81 100644
--- a/dict.c
+++ b/dict.c
@@ -267,6 +267,11 @@ xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
 	else size *= 4; /* exponential growth */
         if (size < 4 * namelen)
 	    size = 4 * namelen; /* just in case ! */
+	/* Prevent potential overflow when computing requested size */
+	if ((size_t)namelen > ((size_t)-1) / 4) {
+	    /* name too large to safely allocate a pool entry */
+	    return(NULL);
+	}
 	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
 	if (pool == NULL)
 	    return(NULL);
@@ -280,8 +285,48 @@ xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
         fprintf(stderr, "+");
 #endif
     }
-found_pool:
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ found_pool:
     ret = pool->free;
+    /*
+     * Rationale:
+     * Perform explicit bounds checks and integer-overflow-safe computations
+     * before copying. If the current pool lacks the required space, allocate
+     * a new pool block of an appropriate safe size and switch to it. This
+     * prevents memcpy from reading outside the allocated region.
+     */
+    {
+        size_t avail = (size_t)(pool->end - pool->free);
+        size_t need = (size_t)namelen + 1U; /* include terminating NUL */
+        if (need == 0U) /* overflow guard */
+            return(NULL);
+        if (avail < need) {
+            /* compute a safe new pool size without overflow */
+            size_t max_quarter = ((size_t)-1) / 4U;
+            size_t newsize = pool->size ? pool->size * 4U : need;
+            if (pool->size > max_quarter)
+                newsize = need; /* avoid overflow */
+            else if (newsize < 4U * (size_t)namelen)
+                newsize = 4U * (size_t)namelen;
+            if (newsize < need)
+                newsize = need;
+            /* final sanity check */
+            if (newsize < need)
+                return(NULL);
+            xmlDictStringsPtr newpool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + newsize);
+            if (newpool == NULL)
+                return(NULL);
+            newpool->size = newsize;
+            newpool->nbStrings = 0;
+            newpool->free = &newpool->array[0];
+            newpool->end = &newpool->array[newsize];
+            newpool->next = dict->strings;
+            dict->strings = newpool;
+            pool = newpool;
+            ret = pool->free;
+        }
+    }
+    /* safe to copy now */
     memcpy(pool->free, name, namelen);
     pool->free += namelen;
     *(pool->free++) = 0;
@@ -289,6 +334,7 @@ found_pool:
     return(ret);
 }
 
+
 /*
  * xmlDictAddQString:
  * @dict: the dictionary
