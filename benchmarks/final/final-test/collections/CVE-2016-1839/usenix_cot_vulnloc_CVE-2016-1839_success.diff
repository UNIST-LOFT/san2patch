diff --git a/HTMLparser.c b/HTMLparser.c
index 69eed2bd..b2ec7c04 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2500,21 +2500,94 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 	return(NULL);
     }
 
+    /*
+     * Rationale for patch:
+     * Prevent len from growing beyond the available data in the input
+     * buffer which would lead to an out-of-bounds read when calling
+     * xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len).
+     * We compute the available bytes between cur and base and ensure
+     * that adding the next character length (l) does not exceed it.
+     * If it's about to exceed, we attempt a GROW and re-evaluate;
+     * if still insufficient we clamp the added length or break the
+     * loop to avoid an OOB read. This also guards against integer
+     * overflow in the len accumulation by doing comparisons in size_t.
+     */
     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
 	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
             (c == '.') || (c == '-') ||
 	    (c == '_') || (c == ':') ||
 	    (IS_COMBINING(c)) ||
 	    (IS_EXTENDER(c)))) {
-	if (count++ > 100) {
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 	if (count++ > 100) {
 	    count = 0;
 	    GROW;
 	}
+
+	/* safety: ensure l is positive */
+	if (l <= 0)
+	    break;
+
+	/* compute available bytes in input buffer */
+	size_t avail = 0;
+	if (ctxt->input != NULL) {
+	    const xmlChar *curp = ctxt->input->cur;
+	    const xmlChar *basep = ctxt->input->base;
+	    if ((curp != NULL) && (basep != NULL) && (curp >= basep))
+		avail = (size_t)(curp - basep);
+	}
+
+	/* check whether adding l would exceed available data */
+	size_t tmplen = (size_t)len + (size_t)l;
+	if (tmplen > avail) {
+	    /* try to grow the input buffer and recompute availability */
+	    GROW;
+	    if (ctxt->input != NULL) {
+		const xmlChar *curp = ctxt->input->cur;
+		const xmlChar *basep = ctxt->input->base;
+		if ((curp != NULL) && (basep != NULL) && (curp >= basep))
+		    avail = (size_t)(curp - basep);
+		else
+		    avail = 0;
+	    }
+	    tmplen = (size_t)len + (size_t)l;
+	    if (tmplen > avail) {
+		/* clamp l to the remaining available bytes if possible, else stop */
+		if (avail > (size_t)len) {
+		    int newl = (int)(avail - (size_t)len);
+		    if (newl > 0)
+			l = newl;
+		    else
+			break;
+		} else {
+		    break;
+		}
+	    }
+	}
+
 	len += l;
 	NEXTL(l);
 	c = CUR_CHAR(l);
     }
-    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
+
+    if (len <= 0)
+	return(NULL);
+
+    /* Ensure the start pointer and len are within the buffer bounds. */
+    if ((ctxt->input != NULL) && (ctxt->input->cur != NULL) && (ctxt->input->base != NULL)) {
+	const xmlChar *start = ctxt->input->cur - len;
+	if (start < ctxt->input->base) {
+	    /* clamp to base */
+	    len = (int)(ctxt->input->cur - ctxt->input->base);
+	    if (len <= 0)
+		return(NULL);
+	    start = ctxt->input->base;
+	}
+	return(xmlDictLookup(ctxt->dict, start, len));
+    }
+
+    /* Fallback: if input pointers are not available, be conservative */
+    return(NULL);
 }
 
 
@@ -2539,6 +2612,7 @@ htmlParseHTMLAttribute(htmlParserCtxtPtr ctxt, const xmlChar stop) {
     const htmlEntityDesc * ent;
 
     /*
+
      * allocate a translation buffer.
      */
     buffer_size = HTML_PARSER_BUFFER_SIZE;
diff --git a/dict.c b/dict.c
index c0585fe2..48d5c8c2 100644
--- a/dict.c
+++ b/dict.c
@@ -280,8 +280,56 @@ xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
         fprintf(stderr, "+");
 #endif
     }
-found_pool:
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ found_pool:
     ret = pool->free;
+
+    /*
+     * Rationale for modification:
+     * Prevent an out-of-bounds read/write when copying 'name' into the
+     * current pool. The original code assumed there was always enough
+     * space in 'pool' for 'namelen + 1' bytes. If not, memcpy would
+     * overflow the allocation leading to ASan-reported heap-buffer-overflow.
+     *
+     * Fix: Check the available space (pool->end - pool->free) and if it's
+     * insufficient, allocate a new pool sized to hold the name (using the
+     * same growth heuristics as the initial allocation). Also enforce the
+     * dict->limit check before allocating to prevent unbounded growth.
+     */
+    {
+        size_t avail = (size_t)(pool->end - pool->free);
+        size_t need = (size_t)namelen + 1U;
+        if (need > avail) {
+            /* Ensure we don't exceed the dictionary global limit */
+            if ((dict->limit > 0) && ((limit + need) > dict->limit)) {
+                return(NULL);
+            }
+
+            /* Choose a new pool size following the existing policy */
+            size_t new_size = size;
+            if (new_size == 0) new_size = 1000;
+            else new_size *= 4; /* exponential growth */
+            if (new_size < 4U * (size_t)namelen)
+                new_size = 4U * (size_t)namelen; /* just in case ! */
+
+            xmlDictStringsPtr new_pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + new_size);
+            if (new_pool == NULL)
+                return(NULL);
+            new_pool->size = new_size;
+            new_pool->nbStrings = 0;
+            new_pool->free = &new_pool->array[0];
+            new_pool->end = &new_pool->array[new_size];
+            new_pool->next = dict->strings;
+            dict->strings = new_pool;
+#ifdef DICT_DEBUG_PATTERNS
+            fprintf(stderr, "+");
+#endif
+            /* Use the newly allocated pool for insertion */
+            pool = new_pool;
+            ret = pool->free;
+        }
+    }
+
     memcpy(pool->free, name, namelen);
     pool->free += namelen;
     *(pool->free++) = 0;
@@ -313,6 +361,7 @@ xmlDictAddQString(xmlDictPtr dict, const xmlChar *prefix, unsigned int plen,
     if (prefix == NULL) return(xmlDictAddString(dict, name, namelen));
 
 #ifdef DICT_DEBUG_PATTERNS
+
     fprintf(stderr, "=");
 #endif
     pool = dict->strings;
