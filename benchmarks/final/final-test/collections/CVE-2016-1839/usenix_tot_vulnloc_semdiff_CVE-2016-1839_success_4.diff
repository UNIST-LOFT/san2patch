diff --git a/HTMLparser.c b/HTMLparser.c
index 69eed2bd..f9a825ed 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2501,19 +2501,38 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
     }
 
     while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
-	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
-            (c == '.') || (c == '-') ||
-	    (c == '_') || (c == ':') ||
-	    (IS_COMBINING(c)) ||
-	    (IS_EXTENDER(c)))) {
-	if (count++ > 100) {
-	    count = 0;
-	    GROW;
-	}
-	len += l;
-	NEXTL(l);
-	c = CUR_CHAR(l);
+       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
+        (c == '.') || (c == '-') ||
+        (c == '_') || (c == ':') ||
+        (IS_COMBINING(c)) ||
+        (IS_EXTENDER(c)))) {
+    if (count++ > 100) {
+        count = 0;
+        GROW;
+    }
+    len += l;
+
+    /* Rationale: Do not rely on internals of xmlParserInputBuffer (e.g. a
+     * 'use' field that may not exist). Instead validate the accumulated
+     * length against the xmlParserInput's base/end pointers which indicate
+     * the available data in the input buffer. This avoids referencing
+     * non-portable/internal members and prevents out-of-bounds reads.
+     */
+    if ((ctxt == NULL) || (ctxt->input == NULL) ||
+        (ctxt->input->base == NULL) || (ctxt->input->end == NULL))
+        return(NULL);
+
+    /* compute available bytes from base..end and compare safely */
+    if (len > (int)(ctxt->input->end - ctxt->input->base)) {
+        /* attempt to grow the buffer; if still insufficient, abort */
+        GROW;
+        if (len > (int)(ctxt->input->end - ctxt->input->base))
+            return(NULL);
     }
+
+    NEXTL(l);
+    c = CUR_CHAR(l);
+}
     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 }
 
