diff --git a/HTMLparser.c b/HTMLparser.c
index 69eed2bd..8ee7eda8 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -2485,8 +2485,16 @@ htmlParseName(htmlParserCtxtPtr ctxt) {
 
 static const xmlChar *
 htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
-    int len = 0, l;
-    int c;
+    /* Rationale:
+     * Use a size_t accumulator for the name length to avoid integer overflow
+     * and validate computed lengths against the available bytes in the input
+     * buffer before calling xmlDictLookup. If the computed length exceeds the
+     * available bytes try to GROW once and fail safely if still too large.
+     */
+    size_t len = 0;
+    int l;
+// FIXME: Crash CWE-125: Out-of-bounds Read
+     int c;
     int count = 0;
 
     /*
@@ -2510,14 +2518,39 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 	    count = 0;
 	    GROW;
 	}
-	len += l;
+	/* Check for overflow before adding l to len */
+	if ((size_t)l > ((size_t)-1 - len)) {
+	    /* too large, reject */
+	    return(NULL);
+	}
+	len += (size_t)l;
 	NEXTL(l);
 	c = CUR_CHAR(l);
     }
+
+    /* Validate that len does not extend past the input buffer end */
+    {
+	const xmlChar *start = ctxt->input->cur - len;
+	/* ensure we don't point before the buffer base */
+	if (start < ctxt->input->base) {
+	    return(NULL);
+	}
+	size_t available = (size_t)(ctxt->input->end - start);
+	if (len > available) {
+	    /* try to grow once more and recheck */
+	    GROW;
+	    start = ctxt->input->cur - len;
+	    if (start < ctxt->input->base) return(NULL);
+	    available = (size_t)(ctxt->input->end - start);
+	    if (len > available) return(NULL);
+	}
+    }
+
     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 }
 
 
+
 /**
  * htmlParseHTMLAttribute:
  * @ctxt:  an HTML parser context
diff --git a/dict.c b/dict.c
index c0585fe2..f2f2d5bf 100644
--- a/dict.c
+++ b/dict.c
@@ -921,6 +921,23 @@ xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
 #endif
 	}
 	key = okey % dict->size;
+// FIXME: Crash CWE-125: Out-of-bounds Read
+     }
+
+    /*
+     * Rationale:
+     * Guard against callers passing an excessively large 'l' value that
+     * may point past the actual allocated buffer for 'name'. If 'l' is
+     * negative or exceeds a safe threshold, reject the lookup to avoid
+     * any out-of-bounds reads in xmlDictAddString (which will read 'l'
+     * bytes from 'name'). This follows the mitigation guideline of
+     * rejecting overly large entity/name lengths at parser/dictionary
+     * boundaries.
+     */
+    {
+	const size_t safe_max_len = 65535U;
+	if ((l < 0) || ((size_t)l > safe_max_len))
+	    return(NULL);
     }
 
     ret = xmlDictAddString(dict, name, l);
