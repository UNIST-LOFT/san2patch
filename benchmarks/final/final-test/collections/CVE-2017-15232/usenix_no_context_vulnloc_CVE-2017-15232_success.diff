diff --git a/jdapistd.c b/jdapistd.c
index 37afc844..eee6346d 100644
--- a/jdapistd.c
+++ b/jdapistd.c
@@ -312,8 +312,35 @@ read_and_discard_scanlines (j_decompress_ptr cinfo, JDIMENSION num_lines)
   color_convert = cinfo->cconvert->color_convert;
   cinfo->cconvert->color_convert = noop_convert;
 
-  for (n = 0; n < num_lines; n++)
-    jpeg_read_scanlines(cinfo, NULL, 1);
+  /*
+   * Prefer a small stack buffer when possible to avoid heap allocations.
+   * If the required row size is larger than our small buffer, fall back to
+   * heap allocation. This guarantees a non-NULL buffer is passed to
+   * jpeg_read_scanlines(), preventing downstream NULL dereferences.
+   */
+  {
+    size_t row_samples = (size_t) cinfo->output_width * cinfo->output_components;
+    JSAMPROW tmp_row_ptr = NULL;
+    JSAMPARRAY tmp_buf = &tmp_row_ptr;
+    JSAMPROW heap_buf = NULL;
+    /* Small stack buffer (sized conservatively) */
+    unsigned char small_buf[4096];
+
+    if (row_samples * sizeof(JSAMPLE) <= sizeof(small_buf)) {
+      tmp_row_ptr = (JSAMPROW) small_buf;
+    } else {
+      heap_buf = (JSAMPROW) malloc(row_samples * sizeof(JSAMPLE));
+      if (heap_buf == NULL)
+        ERREXIT(cinfo, JERR_OUT_OF_MEMORY);
+      tmp_row_ptr = heap_buf;
+    }
+
+    for (n = 0; n < num_lines; n++)
+      jpeg_read_scanlines(cinfo, tmp_buf, 1);
+
+    if (heap_buf)
+      free(heap_buf);
+  }
 
   cinfo->cconvert->color_convert = color_convert;
 }
@@ -342,6 +369,7 @@ increment_simple_rowgroup_ctr (j_decompress_ptr cinfo, JDIMENSION rows)
   read_and_discard_scanlines(cinfo, rows_left);
 }
 
+
 /*
  * Skips some scanlines of data from the JPEG decompressor.
  *
diff --git a/jquant1.c b/jquant1.c
index e7814815..3fedf062 100644
--- a/jquant1.c
+++ b/jquant1.c
@@ -519,6 +519,13 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                      JSAMPARRAY output_buf, int num_rows)
 /* General case, with ordered dithering */
 {
+  /* Rationale:
+   * Defensive per-use NULL checks: rather than assuming all tables/buffers
+   * are present, check before each dereference. If a per-component table
+   * is missing, we simply skip that component's contribution (leaving the
+   * output for those pixels unchanged from the zero initialization), which
+   * avoids crashes while retaining as much valid output as possible.
+   */
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register JSAMPROW input_ptr;
   register JSAMPROW output_ptr;
@@ -531,25 +538,59 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   JDIMENSION col;
   JDIMENSION width = cinfo->output_width;
 
+  /* If essential globals are missing, abort via error handler. */
+  if (cquantize == NULL || input_buf == NULL || output_buf == NULL) {
+    if (cinfo->err && cinfo->err->error_exit)
+      (*cinfo->err->error_exit) ((j_common_ptr) cinfo);
+    return;
+  }
+
   for (row = 0; row < num_rows; row++) {
+    /* Ensure row buffers exist before accessing them */
+    if (output_buf[row] == NULL) {
+      /* Can't write to output; skip row to avoid crash. */
+      continue;
+    }
+
     /* Initialize output values to 0 so can process components separately */
     jzero_far((void *) output_buf[row], (size_t) (width * sizeof(JSAMPLE)));
+
+    if (input_buf[row] == NULL) {
+      /* No input; leave row zeroed */
+      row_index = (cquantize->row_index + 1) & ODITHER_MASK;
+      cquantize->row_index = row_index;
+      continue;
+    }
+
     row_index = cquantize->row_index;
+
     for (ci = 0; ci < nc; ci++) {
-      input_ptr = input_buf[row] + ci;
-      output_ptr = output_buf[row];
+      /* Get per-component pointers but guard each one. If missing, skip this component. */
+      if (cquantize->colorindex == NULL || cquantize->odither == NULL) {
+        /* No global tables; skip all components. */
+        break;
+      }
       colorindex_ci = cquantize->colorindex[ci];
+      if (colorindex_ci == NULL) {
+        /* Missing colorindex for this component; skip it. */
+        continue;
+      }
+      if (cquantize->odither[ci] == NULL) {
+        /* Missing odither array for this component; skip it. */
+        continue;
+      }
       dither = cquantize->odither[ci][row_index];
+      if (dither == NULL) {
+        /* Missing dither row; skip this component. */
+        continue;
+      }
+
+      input_ptr = input_buf[row] + ci;
+      output_ptr = output_buf[row];
       col_index = 0;
 
       for (col = width; col > 0; col--) {
-        /* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
-         * select output value, accumulate into output code for this pixel.
-         * Range-limiting need not be done explicitly, as we have extended
-         * the colorindex table to produce the right answers for out-of-range
-         * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
-         * required amount of padding.
-         */
+        /* Safe to use colorindex_ci and dither as we verified non-NULL above */
         *output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
         input_ptr += nc;
         output_ptr++;
@@ -563,6 +604,7 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
 }
 
 
+
 METHODDEF(void)
 quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                       JSAMPARRAY output_buf, int num_rows)
