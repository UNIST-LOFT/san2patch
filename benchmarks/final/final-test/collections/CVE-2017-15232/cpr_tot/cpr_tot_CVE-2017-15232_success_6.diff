diff --git a/jquant1.c b/jquant1.c
index e7814815..15b81129 100644
--- a/jquant1.c
+++ b/jquant1.c
@@ -529,9 +529,9 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   int ci;
   int row;
   JDIMENSION col;
-  JDIMENSION width = cinfo->output_width;
+  JDIMENSION width = cinfo->output_width; 
 
-  for (row = 0; row < num_rows; row++) {
+  if (cquantize == NULL || cquantize->colorindex == NULL || cquantize->odither == NULL) ERREXIT(cinfo, JERR_BAD_STATE); for (row = 0; row < num_rows; row++) {
     /* Initialize output values to 0 so can process components separately */
     jzero_far((void *) output_buf[row], (size_t) (width * sizeof(JSAMPLE)));
     row_index = cquantize->row_index;
@@ -562,6 +562,13 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   }
 }
 
+/* Rationale:
+   This minimal change defends against NULL dereferences by checking that
+   the cquantize pointer and the two primary data arrays (colorindex and
+   odither) are non-NULL before proceeding. If any required state is
+   missing the function aborts with JERR_BAD_STATE, preventing a read at
+   address 0x0. This is a small, localized guard different from other
+   candidates because it checks the top-level arrays only. */
 
 METHODDEF(void)
 quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
