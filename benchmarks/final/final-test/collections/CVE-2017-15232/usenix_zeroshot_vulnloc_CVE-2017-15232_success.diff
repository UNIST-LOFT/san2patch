diff --git a/jquant1.c b/jquant1.c
index e7814815..f2af4ccb 100644
--- a/jquant1.c
+++ b/jquant1.c
@@ -513,12 +513,22 @@ color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   }
 }
 
-
 METHODDEF(void)
 quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                      JSAMPARRAY output_buf, int num_rows)
 /* General case, with ordered dithering */
 {
+  /*
+   * Rationale:
+   * AddressSanitizer reported a NULL read in this function. The crash can
+   * occur if cinfo, cquantize, input_buf, output_buf, or individual row
+   * pointers are NULL, or if internal tables (colorindex or odither) are
+   * NULL for a component. To avoid dereferencing NULL pointers we add
+   * defensive checks and safely skip processing when data is missing.
+   * Skipping is safe because the output row is zeroed (jzero_far) before
+   * per-component accumulation; leaving it zero yields a valid result and
+   * avoids a crash.
+   */
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register JSAMPROW input_ptr;
   register JSAMPROW output_ptr;
@@ -531,15 +541,38 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   JDIMENSION col;
   JDIMENSION width = cinfo->output_width;
 
+  /* Basic sanity checks to avoid NULL dereferences */
+  if (cinfo == NULL || cquantize == NULL || input_buf == NULL || output_buf == NULL)
+    return;
+  if (nc <= 0 || width == 0 || num_rows <= 0)
+    return;
+
   for (row = 0; row < num_rows; row++) {
+    /* If a row pointer is NULL, skip processing this row to avoid crash. */
+    if (input_buf[row] == NULL || output_buf[row] == NULL) {
+      /* Ensure we do not reference a NULL output -- nothing to do for this row */
+      continue;
+    }
+
     /* Initialize output values to 0 so can process components separately */
     jzero_far((void *) output_buf[row], (size_t) (width * sizeof(JSAMPLE)));
     row_index = cquantize->row_index;
     for (ci = 0; ci < nc; ci++) {
       input_ptr = input_buf[row] + ci;
       output_ptr = output_buf[row];
+
+      /* Defensive checks: if colorindex or dither table is missing, skip component */
       colorindex_ci = cquantize->colorindex[ci];
+      if (colorindex_ci == NULL)
+        continue;
+      /* odither may be NULL for a component or for this row_index */
+      if (cquantize->odither == NULL || cquantize->odither[ci] == NULL) {
+        continue;
+      }
       dither = cquantize->odither[ci][row_index];
+      if (dither == NULL)
+        continue;
+
       col_index = 0;
 
       for (col = width; col > 0; col--) {
@@ -562,8 +595,8 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   }
 }
 
-
 METHODDEF(void)
+
 quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                       JSAMPARRAY output_buf, int num_rows)
 /* Fast path for out_color_components==3, with ordered dithering */
