diff --git a/jdpostct.c b/jdpostct.c
index 601fc2a7..66438a4c 100644
--- a/jdpostct.c
+++ b/jdpostct.c
@@ -129,8 +129,22 @@ post_process_1pass (j_decompress_ptr cinfo,
                     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
                     JDIMENSION out_rows_avail)
 {
-  my_post_ptr post = (my_post_ptr) cinfo->post;
   JDIMENSION num_rows, max_rows;
+  my_post_ptr post;
+
+  /* Minimal, C89-friendly defensive checks inserted before any deref. */
+  if (cinfo == NULL)
+    return;
+  if (cinfo->post == NULL)
+    return;
+  post = (my_post_ptr) cinfo->post;
+
+  if (cinfo->upsample == NULL || cinfo->upsample->upsample == NULL)
+    return;
+  if (post->buffer == NULL)
+    return;
+  if (cinfo->cquantize == NULL || cinfo->cquantize->color_quantize == NULL)
+    return;
 
   /* Fill the buffer, but not more than what we can dump out in one go. */
   /* Note we rely on the upsampler to detect bottom of image. */
@@ -141,13 +155,19 @@ post_process_1pass (j_decompress_ptr cinfo,
   (*cinfo->upsample->upsample) (cinfo,
                 input_buf, in_row_group_ctr, in_row_groups_avail,
                 post->buffer, &num_rows, max_rows);
-  /* Quantize and emit data. */
-  (*cinfo->cquantize->color_quantize) (cinfo,
-                post->buffer, output_buf + *out_row_ctr, (int) num_rows);
-  *out_row_ctr += num_rows;
+
+  /* Quantize and emit data only if upsampler produced rows. */
+  if (num_rows > 0) {
+    if (output_buf == NULL)
+      return;
+    (*cinfo->cquantize->color_quantize) (cinfo,
+                  post->buffer, output_buf + *out_row_ctr, (int) num_rows);
+    *out_row_ctr += num_rows;
+  }
 }
 
 
+
 #ifdef QUANT_2PASS_SUPPORTED
 
 /*
diff --git a/jquant1.c b/jquant1.c
index e7814815..8ae214a2 100644
--- a/jquant1.c
+++ b/jquant1.c
@@ -533,33 +533,60 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
 
   for (row = 0; row < num_rows; row++) {
     /* Initialize output values to 0 so can process components separately */
+    /* Ensure an output row exists before zeroing/processing it. */
+    if (output_buf == NULL || output_buf[row] == NULL) {
+      /* Nothing to write to; skip processing this row */
+      continue;
+    }
     jzero_far((void *) output_buf[row], (size_t) (width * sizeof(JSAMPLE)));
+
+    /* If quantizer state is missing, leave the row zeroed and continue. */
+    if (cquantize == NULL) {
+      continue;
+    }
+
+    /* Validate row_index; use stored value from quantizer. */
     row_index = cquantize->row_index;
+
     for (ci = 0; ci < nc; ci++) {
+      /* Ensure input row exists before reading from it */
+      if (input_buf == NULL || input_buf[row] == NULL) {
+        /* No input for this row; leave output zeroed */
+        break;
+      }
+
       input_ptr = input_buf[row] + ci;
       output_ptr = output_buf[row];
+
+      /* Validate colorindex and dither tables before use */
+      if (cquantize->colorindex == NULL)
+        break;
       colorindex_ci = cquantize->colorindex[ci];
+      if (colorindex_ci == NULL)
+        continue;
+
+      if (cquantize->odither == NULL || cquantize->odither[ci] == NULL)
+        continue;
       dither = cquantize->odither[ci][row_index];
+      if (dither == NULL)
+        continue;
+
       col_index = 0;
 
       for (col = width; col > 0; col--) {
-        /* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
-         * select output value, accumulate into output code for this pixel.
-         * Range-limiting need not be done explicitly, as we have extended
-         * the colorindex table to produce the right answers for out-of-range
-         * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
-         * required amount of padding.
-         */
-        *output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
+        /* Read/write guarded by earlier checks; perform mapping. */
+        *output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr) + dither[col_index]];
         input_ptr += nc;
         output_ptr++;
         col_index = (col_index + 1) & ODITHER_MASK;
       }
     }
+
     /* Advance row index for next row */
     row_index = (row_index + 1) & ODITHER_MASK;
     cquantize->row_index = row_index;
   }
+
 }
 
 
