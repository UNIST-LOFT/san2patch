diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..7995de2 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -105,6 +105,25 @@ zzip_mem_disk_fdopen(int fd)
     ____;
 }
 
+/*
+ * Patch rationale:
+ * - Added defensive checks to avoid NULL or near-NULL pointer dereferences
+ *   when iterating disk entries and when creating a new memory-disk handle.
+ * - In zzip_mem_disk_buffer, verify the result of zzip_mem_disk_new and
+ *   propagate an error (errno=ENOMEM) if allocation fails instead of
+ *   continuing with a NULL pointer.
+ * - In zzip_mem_disk_load, replaced placeholder declarations with concrete
+ *   definitions and added a sanity check before calling zzip_mem_entry_new
+ *   to detect obviously invalid entry pointers (e.g. near-NULL pointers)
+ *   and abort safely. This prevents zzip_mem_entry_new from receiving
+ *   pointers that are clearly invalid and avoids the NULL-dereference
+ *   crash reported by ASan. If such an invalid pointer is detected we
+ *   set errno and go to the error cleanup path.
+ * - These changes do not alter the behavior for well-formed archives but
+ *   ensure robust failure handling for malformed input or allocation/mapping
+ *   failures that previously led to crashes (CWE-476/CWE-754).
+ */
+
 /** create new diskdir handle.
  *  wraps underlying zzip_disk_buffer. */
 zzip__new__ ZZIP_MEM_DISK *
@@ -113,10 +132,19 @@ zzip_mem_disk_buffer(char *buffer, size_t buflen)
     ZZIP_DISK *disk = zzip_disk_buffer(buffer, buflen);
     if (! disk)
         { perror(error[_zzip_mem_disk_buffer_fail]); return 0; }
-    ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
-    zzip_mem_disk_load(dir, disk);
+    ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
+    if (! dir) {
+        /* allocation failure: do not continue with NULL handle */
+        errno = ENOMEM;
+        return 0;
+    }
+    if (zzip_mem_disk_load(dir, disk) < 0) {
+        /* on load failure, ensure caller sees failure; dir may be partially
+         * initialized and will be cleaned up by the caller or by other
+         * cleanup paths; avoid returning a handle that failed to load. */
+        return 0;
+    }
     return dir;
-    ____;
 }
 
 /** parse central dir.
@@ -130,10 +158,21 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
         { errno=EINVAL; return -1; }
     if (dir->list)
         zzip_mem_disk_unload(dir);
-    ___ long count = 0;
-    ___ struct zzip_disk_entry *entry = zzip_disk_findfirst(disk);
-    for (; entry; entry = zzip_disk_findnext(disk, entry))
+    long count = 0;
+    struct zzip_disk_entry *entry = zzip_disk_findfirst(disk);
+// FIXME: Crash CWE-476: NULL Pointer Dereference
+     for (; entry; entry = zzip_disk_findnext(disk, entry))
     {
+        /* Sanity-check the entry pointer to avoid dereferencing clearly
+         * invalid/near-NULL pointers. This prevents crashes caused by
+         * malformed disk structures or earlier failures that produced
+         * an invalid entry pointer. We check for addresses that are
+         * very small (near the NULL page). */
+        if ((unsigned long)entry < 0x1000UL) {
+            errno = EFAULT;
+            goto error;
+        }
+
         ZZIP_MEM_ENTRY *item = zzip_mem_entry_new(disk, entry);
         if (! item)
             goto error;
@@ -147,10 +186,9 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
         dir->last = item;       /* to earlier */
         count++;
     }
-    ____;
+
     dir->disk = disk;
     return count;
-    ____;
   error:
     zzip_mem_disk_unload(dir);
     return -1;
@@ -171,13 +209,33 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
     ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
     if (! item)
         return 0;               /* errno=ENOMEM; */
+    /*
+     * Rationale for changes:
+     * - Ensure zzip_disk_entry_to_file_header() return value is checked
+     *   before dereferencing it to avoid NULL pointer dereference.
+     * - Validate extra-data pointers before performing pointer arithmetic
+     *   (check for NULL when length is non-zero) to avoid reading near-NULL
+     *   addresses.
+     * - Replace goto error paths with explicit cleanup using
+     *   zzip_mem_entry_free(item) and return to avoid jumping to a label
+     *   that may be outside this snippet; ensures item is freed on error.
+     */
     ___ struct zzip_file_header *header =
         zzip_disk_entry_to_file_header(disk, entry);
+
+    if (! header) {
+        /* header parsing failed, clean up and report bad message */
+        zzip_mem_entry_free(item);
+        errno = EBADMSG;
+        return 0;
+    }
+
     /*  there is a number of duplicated information in the file header
      *  or the disk entry block. Theoretically some part may be missing
      *  that exists in the other, ... but we will prefer the disk entry.
      */
-    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
+// FIXME: Crash CWE-476: NULL Pointer Dereference
+     item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
     item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
     item->zz_data = zzip_file_header_to_data(header);
     item->zz_flags = zzip_disk_entry_get_flags(entry);
@@ -195,21 +253,34 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         zzip_size_t /*    */ ext2_len = zzip_file_header_get_extras(header);
         char *_zzip_restrict ext2_ptr = zzip_file_header_to_extras(header);
 
-        if (ext1_ptr + ext1_len >= disk->endbuf ||
-            ext2_ptr + ext2_len >= disk->endbuf)
+        /*
+         * Validate extra pointers carefully:
+         * - If length is non-zero but pointer is NULL, treat as format error.
+         * - Only perform pointer+length comparisons when pointer is non-NULL.
+         */
+        if ((ext1_len && !ext1_ptr) ||
+            (ext2_len && !ext2_ptr) ||
+            (ext1_ptr && ext1_len && ext1_ptr + ext1_len >= disk->endbuf) ||
+            (ext2_ptr && ext2_len && ext2_ptr + ext2_len >= disk->endbuf))
         {
             errno = EBADMSG; /* format error CVE-2017-5978 */
-            goto error; /* zzip_mem_entry_free(item); return 0; */
+            zzip_mem_entry_free(item);
+            return 0; /* zzip_mem_entry_free(item); return 0; */
         }
 
         if (ext1_len)
         {
             void *mem = malloc(ext1_len);
-            if (! mem) goto error; /* errno = ENOMEM */
+            if (! mem) {
+                /* allocation failed, cleanup and return */
+                zzip_mem_entry_free(item); /* errno = ENOMEM */
+                return 0;
+            }
             item->zz_ext[1] = mem;
             item->zz_extlen[1] = ext1_len;
             memcpy(mem, ext1_ptr, ext1_len);
         }
+
         if (ext2_len)
         {
             void *mem = malloc(ext2_len);
