diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..2cb7564 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -166,6 +166,18 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
 zzip__new__ ZZIP_MEM_ENTRY *
 zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
 {
+    /* Rationale for changes:
+     * The original code dereferenced/used header and entry-derived pointers
+     * (name, comment, extras, data) without validating that the converted
+     * file-header or the extra pointers are sane. This could lead to
+     * reads from invalid addresses and crashes (as seen in ASan output).
+     * To prevent this we:
+     *  - check that the conversion to a file header succeeded
+     *  - delay strdup()/data extraction until after basic validation
+     *  - validate extra pointers together with their lengths before using
+     *  - check allocation results and treat malformed inputs as EBADMSG
+     */
+
     if (! disk || ! entry)
         { errno=EINVAL; return 0; }
     ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
@@ -173,12 +185,20 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         return 0;               /* errno=ENOMEM; */
     ___ struct zzip_file_header *header =
         zzip_disk_entry_to_file_header(disk, entry);
+
+    /* validate header conversion */
+    if (!header) {
+        errno = EBADMSG;
+        free(item);
+        return 0;
+    }
+
     /*  there is a number of duplicated information in the file header
      *  or the disk entry block. Theoretically some part may be missing
      *  that exists in the other, ... but we will prefer the disk entry.
      */
-    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
-    item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
+// FIXME: Crash
+    /* Defer strdup/name/comment until after validating extras and header */
     item->zz_data = zzip_file_header_to_data(header);
     item->zz_flags = zzip_disk_entry_get_flags(entry);
     item->zz_compr = zzip_disk_entry_get_compr(entry);
@@ -195,6 +215,14 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         zzip_size_t /*    */ ext2_len = zzip_file_header_get_extras(header);
         char *_zzip_restrict ext2_ptr = zzip_file_header_to_extras(header);
 
+        /* Basic sanity checks: if an extra length is non-zero we need a
+         * non-NULL pointer and the data must lie within disk->endbuf.
+         */
+        if ((ext1_len && !ext1_ptr) || (ext2_len && !ext2_ptr)) {
+            errno = EBADMSG;
+            goto error; /* zzip_mem_entry_free(item); return 0; */
+        }
+
         if (ext1_ptr + ext1_len >= disk->endbuf ||
             ext2_ptr + ext2_len >= disk->endbuf)
         {
@@ -210,6 +238,34 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
             item->zz_extlen[1] = ext1_len;
             memcpy(mem, ext1_ptr, ext1_len);
         }
+
+        if (ext2_len)
+        {
+            void *mem = malloc(ext2_len);
+            if (! mem) goto error; /* errno = ENOMEM */
+            item->zz_ext[2] = mem;
+            item->zz_extlen[2] = ext2_len;
+            memcpy(mem, ext2_ptr, ext2_len);
+        }
+    }
+
+    /* now safe to strdup name/comment as header and extras were validated */
+    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
+    if (!item->zz_comment && (errno != ENOMEM)) {
+        /* treat missing/invalid comment as format error */
+        errno = EBADMSG;
+        goto error;
+    }
+
+    item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
+    if (!item->zz_name) {
+        /* name is required: either OOM or bad format */
+        if (errno != ENOMEM) errno = EBADMSG;
+        goto error;
+    }
+
+    return item;
+}
         if (ext2_len)
         {
             void *mem = malloc(ext2_len);
