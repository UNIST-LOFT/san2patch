diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..3d0f671 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -114,6 +114,18 @@ zzip_mem_disk_buffer(char *buffer, size_t buflen)
     if (! disk)
         { perror(error[_zzip_mem_disk_buffer_fail]); return 0; }
     ___ ZZIP_MEM_DISK *dir = zzip_mem_disk_new();
+    /* Rationale:
+     * Defensive check: zzip_mem_disk_new may fail and return NULL.
+     * Calling zzip_mem_disk_load with a NULL 'dir' can lead to a
+     * NULL-pointer dereference further down. Fail early and return
+     * a NULL pointer to the caller in that case. Avoid dereferencing
+     * a NULL 'dir'.
+     */
+    if (! dir) {
+        errno = ENOMEM;
+        /* avoid calling zzip_mem_disk_load when allocation failed */
+        return 0;
+    }
     zzip_mem_disk_load(dir, disk);
     return dir;
     ____;
@@ -132,8 +144,19 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
         zzip_mem_disk_unload(dir);
     ___ long count = 0;
     ___ struct zzip_disk_entry *entry = zzip_disk_findfirst(disk);
-    for (; entry; entry = zzip_disk_findnext(disk, entry))
+// FIXME: Crash CWE-690: Unchecked Return Value to NULL Pointer Dereference (results in CWE-476: NULL Pointer Dereference)
+     for (; entry; entry = zzip_disk_findnext(disk, entry))
     {
+        /* Rationale:
+         * Ensure 'disk' and 'entry' are valid before calling
+         * zzip_mem_entry_new. Some upstream operations may return
+         * NULL for disk or entry fields; avoid passing NULL to
+         * zzip_mem_entry_new which expects valid pointers.
+         */
+        if (!disk || !entry) {
+            errno = EINVAL;
+            goto error;
+        }
         ZZIP_MEM_ENTRY *item = zzip_mem_entry_new(disk, entry);
         if (! item)
             goto error;
@@ -165,7 +188,14 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
  */
 zzip__new__ ZZIP_MEM_ENTRY *
 zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
+
 {
+    /* Rationale:
+     * Defensive NULL checks for all return values that may be NULL.
+     * Allocate temporary pointers first, validate them, free partial
+     * allocations on error and set errno appropriately to avoid
+     * dereferencing NULL pointers (CWE-690/CWE-476).
+     */
     if (! disk || ! entry)
         { errno=EINVAL; return 0; }
     ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
@@ -173,13 +203,52 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         return 0;               /* errno=ENOMEM; */
     ___ struct zzip_file_header *header =
         zzip_disk_entry_to_file_header(disk, entry);
+    if (!header) {
+        errno = EBADMSG; /* malformed archive */
+        free(item);
+        return 0;
+    }
     /*  there is a number of duplicated information in the file header
      *  or the disk entry block. Theoretically some part may be missing
      *  that exists in the other, ... but we will prefer the disk entry.
      */
-    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
-    item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
-    item->zz_data = zzip_file_header_to_data(header);
+// FIXME: Crash CWE-690: Unchecked Return Value to NULL Pointer Dereference (results in CWE-476: NULL Pointer Dereference)
+    /* obtain comment/name/data into temporaries so we can verify success
+     * before storing into item and proceeding.
+     */
+     char *tmp_comment = zzip_disk_entry_strdup_comment(disk, entry);
+    char *tmp_name = zzip_disk_entry_strdup_name(disk, entry);
+    void *tmp_data = zzip_file_header_to_data(header);
+
+    if (!tmp_comment && !tmp_name && !tmp_data) {
+        /* nothing allocated/available -> treat as malformed archive */
+        errno = EBADMSG;
+        free(tmp_comment);
+        free(tmp_name);
+        free(item);
+        return 0;
+    }
+    /* If any of the allocations failed, free partial ones and return ENOMEM
+     * Note: tmp_data may be NULL for malformed headers; treat that as EBADMSG
+     */
+    if (!tmp_name || !tmp_comment) {
+        errno = ENOMEM;
+        free(tmp_comment);
+        free(tmp_name);
+        free(item);
+        return 0;
+    }
+    if (!tmp_data) {
+        errno = EBADMSG;
+        free(tmp_comment);
+        free(tmp_name);
+        free(item);
+        return 0;
+    }
+
+    item->zz_comment = tmp_comment;
+    item->zz_name = tmp_name;
+    item->zz_data = tmp_data;
     item->zz_flags = zzip_disk_entry_get_flags(entry);
     item->zz_compr = zzip_disk_entry_get_compr(entry);
     item->zz_mktime = zzip_disk_entry_get_mktime(entry);
@@ -199,17 +268,28 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
             ext2_ptr + ext2_len >= disk->endbuf)
         {
             errno = EBADMSG; /* format error CVE-2017-5978 */
-            goto error; /* zzip_mem_entry_free(item); return 0; */
+            /* cleanup allocated members */
+            free(item->zz_comment);
+            free(item->zz_name);
+            free(item);
+            return 0; /* zzip_mem_entry_free(item); return 0; */
         }
 
         if (ext1_len)
         {
             void *mem = malloc(ext1_len);
-            if (! mem) goto error; /* errno = ENOMEM */
+            if (! mem) {
+                /* cleanup and return */
+                free(item->zz_comment);
+                free(item->zz_name);
+                free(item);
+                return 0; /* errno = ENOMEM */
+            }
             item->zz_ext[1] = mem;
             item->zz_extlen[1] = ext1_len;
             memcpy(mem, ext1_ptr, ext1_len);
         }
+
         if (ext2_len)
         {
             void *mem = malloc(ext2_len);
