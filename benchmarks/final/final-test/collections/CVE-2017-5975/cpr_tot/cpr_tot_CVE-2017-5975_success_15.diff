diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..bbc7438 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -177,8 +177,8 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
      *  or the disk entry block. Theoretically some part may be missing
      *  that exists in the other, ... but we will prefer the disk entry.
      */
-    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
-    item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
+    item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry); 
+    item->zz_name = zzip_disk_entry_strdup_name(disk, entry); if (((!item->zz_name || !header) && (zzip_mem_entry_free(item), 1))) return 0;
     item->zz_data = zzip_file_header_to_data(header);
     item->zz_flags = zzip_disk_entry_get_flags(entry);
     item->zz_compr = zzip_disk_entry_get_compr(entry);
@@ -244,7 +244,16 @@ error:
 }
 
 /* find an extra block for the given datatype code.
- * The returned EXTRA_BLOCK is still in disk-encoding but
+
+Rationale: This minimal change adds an explicit null-check for both the
+parsed header and the duplicated name. If either header or item->zz_name
+is missing, the expression calls zzip_mem_entry_free(item) to release
+allocated resources and then returns NULL. The use of the && and the
+comma operator ensures free() is only invoked when the condition is
+true. This prevents the previously observed NULL dereference while
+avoiding control-flow restructuring. This candidate differs from other
+variants by performing the free without changing errno or checking
+'entry'. * The returned EXTRA_BLOCK is still in disk-encoding but
  * already a pointer into an allocated heap space block.
  */
 ZZIP_EXTRA_BLOCK *
