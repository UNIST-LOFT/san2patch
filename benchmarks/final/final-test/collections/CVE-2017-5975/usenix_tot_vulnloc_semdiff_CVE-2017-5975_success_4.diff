diff --git a/zzip/memdisk.c b/zzip/memdisk.c
index 007e7ce..13cf75a 100644
--- a/zzip/memdisk.c
+++ b/zzip/memdisk.c
@@ -166,6 +166,11 @@ zzip_mem_disk_load(ZZIP_MEM_DISK * dir, ZZIP_DISK * disk)
 zzip__new__ ZZIP_MEM_ENTRY *
 zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
 {
+    /* Rationale: Defensive checks added to avoid dereferencing NULL pointers.
+     * Ensure header and all pointer-returning helpers are validated and
+     * on any failure clean up and return NULL. This prevents the NULL
+     * pointer dereference observed by sanitizers.
+     */
     if (! disk || ! entry)
         { errno=EINVAL; return 0; }
     ___ ZZIP_MEM_ENTRY *item = calloc(1, sizeof(*item));
@@ -173,13 +178,22 @@ zzip_mem_entry_new(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
         return 0;               /* errno=ENOMEM; */
     ___ struct zzip_file_header *header =
         zzip_disk_entry_to_file_header(disk, entry);
+    if (! header)
+        { errno = EBADMSG; goto error; }
     /*  there is a number of duplicated information in the file header
      *  or the disk entry block. Theoretically some part may be missing
      *  that exists in the other, ... but we will prefer the disk entry.
-     */
+// FIXME: Crash CWE-476: NULL Pointer Dereference
+      */
     item->zz_comment = zzip_disk_entry_strdup_comment(disk, entry);
+    if (!item->zz_comment)
+        goto error;
     item->zz_name = zzip_disk_entry_strdup_name(disk, entry);
+    if (!item->zz_name)
+        goto error;
     item->zz_data = zzip_file_header_to_data(header);
+    if (!item->zz_data)
+        goto error;
     item->zz_flags = zzip_disk_entry_get_flags(entry);
     item->zz_compr = zzip_disk_entry_get_compr(entry);
     item->zz_mktime = zzip_disk_entry_get_mktime(entry);
@@ -243,6 +257,7 @@ error:
     ____;
 }
 
+
 /* find an extra block for the given datatype code.
  * The returned EXTRA_BLOCK is still in disk-encoding but
  * already a pointer into an allocated heap space block.
