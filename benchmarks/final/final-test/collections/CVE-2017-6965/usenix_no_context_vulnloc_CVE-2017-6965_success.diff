diff --git a/binutils/elfcomm.c b/binutils/elfcomm.c
index 0db89487750..6fc0388bb09 100644
--- a/binutils/elfcomm.c
+++ b/binutils/elfcomm.c
@@ -63,6 +63,55 @@ void (*byte_put) (unsigned char *, elf_vma, int);
 void
 byte_put_little_endian (unsigned char * field, elf_vma value, int size)
 {
+  /* Rationale:
+     Enforce robust parameter validation and detect integer overflow when
+     computing write lengths. Use __builtin_object_size when available and
+     fail fast (report and abort) if the write would exceed the known
+     destination size. This is the strictest safe behavior and prevents any
+     out-of-bounds writes even when callers do not supply explicit sizes.
+  */
+  size_t write_len;
+  size_t obj_size;
+
+  /* Validate 'size' is within expected bounds.  */
+  if (size <= 0)
+    {
+      error (_("Invalid data length: %d\n"), size);
+      abort ();
+    }
+
+  if (size > 8)
+    {
+      error (_("Unhandled data length: %d\n"), size);
+      abort ();
+    }
+
+  write_len = (size_t) size;
+
+  /* Check for potential overflow computing end = offset + write_len.
+     Here we only need to ensure write_len is sane; callers must ensure
+     the buffer is large enough. Use builtin object size when possible.  */
+  obj_size = __builtin_object_size (field, 0);
+  if (obj_size != (size_t) -1)
+    {
+      if (write_len > obj_size)
+        {
+          error (_("Attempt to write %zu bytes into a buffer of size %zu\n"),
+                 write_len, obj_size);
+          abort ();
+        }
+    }
+  else
+    {
+      /* If object size is unknown we conservatively abort. This avoids
+         performing potentially unsafe writes. Callers that rely on the
+         previous behavior should be updated to provide size information
+         or use an alternative API that accepts a buffer length.  */
+      error (_("Destination object size unknown; refusing to write %zu bytes\n"),
+             write_len);
+      abort ();
+    }
+
   switch (size)
     {
     case 8:
@@ -70,7 +119,8 @@ byte_put_little_endian (unsigned char * field, elf_vma value, int size)
       field[6] = ((value >> 24) >> 24) & 0xff;
       field[5] = ((value >> 24) >> 16) & 0xff;
       field[4] = ((value >> 24) >> 8) & 0xff;
-      /* Fall through.  */
+// FIXME: Crash CWE-787: Out-of-bounds Write
+       /* Fall through.  */
     case 4:
       field[3] = (value >> 24) & 0xff;
       /* Fall through.  */
diff --git a/binutils/readelf.c b/binutils/readelf.c
index b4887143afe..78a9cdb8dea 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -12338,7 +12338,8 @@ apply_relocations (void *                     file,
 	  unsigned char * rloc;
 	  unsigned long   sym_index;
 
-	  reloc_type = get_reloc_type (rp->r_info);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 	  reloc_type = get_reloc_type (rp->r_info);
 
 	  if (target_specific_reloc_handling (rp, start, symtab))
 	    continue;
@@ -12364,6 +12365,53 @@ apply_relocations (void *                     file,
 	      continue;
 	    }
 
+	  /* Rationale:
+	     Minimize changes by ensuring the offset is within the section and
+	     that there is enough room for reloc_size bytes. This uses a
+	     subtraction-based check (sect_size - reloc_size) to avoid a
+	     temporary sum that could overflow. */
+	  {
+	    size_t offset = (size_t) rp->r_offset;
+	    size_t sect_size = (size_t) (end - start);
+
+	    if (reloc_size == 0)
+	      {
+		warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
+		      (unsigned long) rp->r_offset,
+		      printable_section_name (section));
+		continue;
+	      }
+
+	    /* If sect_size < reloc_size then there is no room at all. */
+	    if (sect_size < (size_t) reloc_size)
+	      {
+		warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
+		      (unsigned long) rp->r_offset,
+		      printable_section_name (section));
+		continue;
+	      }
+
+	    /* Now safe to check offset <= sect_size - reloc_size without overflow. */
+	    if (offset > sect_size - (size_t) reloc_size)
+	      {
+		warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
+		      (unsigned long) rp->r_offset,
+		      printable_section_name (section));
+		continue;
+	      }
+
+	    /* Safe to form pointer now */
+	    rloc = start + offset;
+	  }
+	  if ((rloc + reloc_size) > end || (rloc < start))
+	    {
+	      warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
+		    (unsigned long) rp->r_offset,
+		    printable_section_name (section));
+	      continue;
+	    }
+
+
 	  rloc = start + rp->r_offset;
 	  if ((rloc + reloc_size) > end || (rloc < start))
 	    {
