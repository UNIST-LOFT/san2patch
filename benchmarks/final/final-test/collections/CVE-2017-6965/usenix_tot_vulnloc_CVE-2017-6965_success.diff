diff --git a/binutils/elfcomm.c b/binutils/elfcomm.c
index 0db89487750..eaa9bc256a1 100644
--- a/binutils/elfcomm.c
+++ b/binutils/elfcomm.c
@@ -65,26 +65,28 @@ byte_put_little_endian (unsigned char * field, elf_vma value, int size)
 {
   switch (size)
     {
-    case 8:
-      field[7] = (((value >> 24) >> 24) >> 8) & 0xff;
-      field[6] = ((value >> 24) >> 24) & 0xff;
-      field[5] = ((value >> 24) >> 16) & 0xff;
-      field[4] = ((value >> 24) >> 8) & 0xff;
-      /* Fall through.  */
-    case 4:
-      field[3] = (value >> 24) & 0xff;
-      /* Fall through.  */
-    case 3:
-      field[2] = (value >> 16) & 0xff;
-      /* Fall through.  */
-    case 2:
-      field[1] = (value >> 8) & 0xff;
-      /* Fall through.  */
-    case 1:
-      field[0] = value & 0xff;
-      break;
+    /* Rationale: make the writer defensive by validating the requested number
+       of bytes and using a simple, well-defined loop to produce little-endian
+       bytes. This avoids complex fall-through semantics and centralizes the
+       bounds check on `size`. We cannot obtain the caller's buffer length
+       here (function signature not changed), so we enforce the valid range of
+       sizes (1..8). Callers should ensure the buffer is large enough; at
+       least this prevents accidental misuse with out-of-range sizes. */
+    {
+      int i;
+      if (size < 1 || size > 8)
+        {
+          error (_("Unhandled data length: %d\n"), size);
+          abort ();
+        }
+
+      for (i = 0; i < size; ++i)
+        field[i] = (value >> (8 * i)) & 0xff;
+    }
 
     default:
+      /* This default will never be reached because we handled valid sizes
+         above and aborted on invalid ones, but keep it for safety. */
       error (_("Unhandled data length: %d\n"), size);
       abort ();
     }
diff --git a/binutils/readelf.c b/binutils/readelf.c
index b4887143afe..8340c25b19a 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -12286,7 +12286,8 @@ apply_relocations (void *                     file,
 
   /* Find the reloc section associated with the section.  */
   for (relsec = section_headers;
-       relsec < section_headers + elf_header.e_shnum;
+// FIXME: Crash CWE-787: Out-of-bounds Write
+        relsec < section_headers + elf_header.e_shnum;
        ++relsec)
     {
       bfd_boolean is_rela;
@@ -12298,8 +12299,27 @@ apply_relocations (void *                     file,
       unsigned long num_syms;
       Elf_Internal_Sym * sym;
 
-      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
-	  || relsec->sh_info >= elf_header.e_shnum
+      /* Rationale:
+       * Prevent out-of-bounds writes caused by malformed relocation sections.
+       * Perform lightweight validation of relocation section metadata before
+       * any pointer arithmetic or interpretation of relocation entries.
+       * If the metadata looks suspicious (zero sizes, invalid section index,
+       * or integer wrap in offset+size), skip this relocation section.
+       */
+      if (relsec->sh_size == 0 || relsec->sh_entsize == 0)
+        continue;
+
+      /* Ensure the relocation section's sh_info (target section index) is
+         within the valid range of section headers. */
+      if (relsec->sh_info >= elf_header.e_shnum)
+        continue;
+
+      /* Detect potential integer wrap for sh_offset + sh_size.  If wrap is
+         detected, treat the relocation section as malformed and skip it. */
+      if (relsec->sh_offset + relsec->sh_size < relsec->sh_offset)
+        continue;
+
+      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)	  || relsec->sh_info >= elf_header.e_shnum
 	  || section_headers + relsec->sh_info != section
 	  || relsec->sh_size == 0
 	  || relsec->sh_link >= elf_header.e_shnum)
