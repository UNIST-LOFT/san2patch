diff --git a/tools/tiffcp.c b/tools/tiffcp.c
index bdf754c3..1d5a2f21 100644
--- a/tools/tiffcp.c
+++ b/tools/tiffcp.c
@@ -1068,45 +1068,100 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 	uint32 row;
 	tsample_t s;
 
-	inbuf = _TIFFmalloc(scanlinesizein);
-	outbuf = _TIFFmalloc(scanlinesizeout);
-	if (!inbuf || !outbuf)
-		goto bad;
-	_TIFFmemset(inbuf, 0, scanlinesizein);
-	_TIFFmemset(outbuf, 0, scanlinesizeout);
-	/* unpack channels */
-	for (s = 0; s < spp; s++) {
-		for (row = 0; row < imagelength; row++) {
-			if (TIFFReadScanline(in, inbuf, row, 0) < 0
-			    && !ignore) {
-				TIFFError(TIFFFileName(in),
-				    "Error, can't read scanline %lu",
-				    (unsigned long) row);
-				goto bad;
-			}
-			inp = ((uint8*)inbuf) + s;
-			outp = (uint8*)outbuf;
-			for (n = imagewidth; n-- > 0;) {
-				*outp++ = *inp;
-				inp += spp;
-			}
-			if (TIFFWriteScanline(out, outbuf, row, s) < 0) {
-				TIFFError(TIFFFileName(out),
-				    "Error, can't write scanline %lu",
-				    (unsigned long) row);
-				goto bad;
+	/* Rationale: Fix CWE-125 by computing required per-row buffer sizes from image
+	   metadata (BitsPerSample, SamplesPerPixel, ImageWidth) with overflow
+	   protection, allocating buffers of the correct size, checking allocation
+	   success, and performing copies using bytes-per-sample to avoid any
+	   out-of-bounds reads when samples are wider than a single byte. */
+	{
+		uint16 bps = 0;
+		/* Get bits-per-sample if available; default to 8 if not provided. */
+		(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
+		if (bps == 0)
+			bps = 8; /* defensive fallback */
+
+		/* Compute bytes per sample with overflow safety. */
+		size_t bytes_per_sample = (size_t)((bps + 7) / 8);
+		if (bytes_per_sample == 0)
+			return 0;
+
+		/* Validate imagewidth and spp (samples per pixel). */
+		if (imagewidth == 0 || imagelength == 0 || spp == 0)
+			return 0;
+
+		/* tmp = spp * bytes_per_sample, check overflow */
+		size_t tmp = (size_t)spp * bytes_per_sample;
+		/* Use (size_t)-1 as the maximum instead of SIZE_MAX to avoid dependency
+		   on that macro being available. */
+		if (tmp == 0 || (size_t)imagewidth > ((size_t)-1) / tmp)
+			return 0;
+
+		/* inbuf_size = imagewidth * spp * bytes_per_sample */
+		size_t inbuf_size = tmp * (size_t)imagewidth;
+		if (inbuf_size == 0)
+			return 0;
+
+		/* outbuf_size = imagewidth * bytes_per_sample (planar) */
+		if ((size_t)imagewidth > ((size_t)-1) / bytes_per_sample)
+			return 0;
+		size_t outbuf_size = (size_t)imagewidth * bytes_per_sample;
+
+		/* Allocate buffers using computed safe sizes */
+		inbuf = _TIFFmalloc(inbuf_size);
+		outbuf = _TIFFmalloc(outbuf_size);
+		if (!inbuf || !outbuf) {
+			if (inbuf) _TIFFfree(inbuf);
+			if (outbuf) _TIFFfree(outbuf);
+			return 0;
+		}
+		_TIFFmemset(inbuf, 0, inbuf_size);
+		_TIFFmemset(outbuf, 0, outbuf_size);
+
+		/* unpack channels. Copy bytes_per_sample bytes per sample. */
+		for (s = 0; s < spp; s++) {
+			for (row = 0; row < imagelength; row++) {
+				if (TIFFReadScanline(in, inbuf, row, 0) < 0
+				    && !ignore) {
+					TIFFError(TIFFFileName(in),
+					    "Error, can't read scanline %lu",
+					    (unsigned long) row);
+					goto bad;
+				}
+
+				/* Prepare pointers: start at sample 's' within the first pixel */
+				inp = (uint8*)inbuf + (size_t)s * bytes_per_sample;
+				outp = (uint8*)outbuf;
+
+				/* step between successive samples of the same component */
+				size_t instep = (size_t)spp * bytes_per_sample;
+
+				for (n = imagewidth; n-- > 0; ) {
+					/* Copy bytes_per_sample bytes for this sample */
+					memcpy(outp, inp, bytes_per_sample);
+					outp += bytes_per_sample;
+					inp += instep;
+				}
+
+				if (TIFFWriteScanline(out, outbuf, row, s) < 0) {
+					TIFFError(TIFFFileName(out),
+					    "Error, can't write scanline %lu",
+					    (unsigned long) row);
+					goto bad;
+				}
 			}
 		}
+
+		if (inbuf) _TIFFfree(inbuf);
+		if (outbuf) _TIFFfree(outbuf);
+		return 1;
 	}
-	if (inbuf) _TIFFfree(inbuf);
-	if (outbuf) _TIFFfree(outbuf);
-	return 1;
 bad:
 	if (inbuf) _TIFFfree(inbuf);
 	if (outbuf) _TIFFfree(outbuf);
 	return 0;
 }
 
+
 /*
  * Separate -> contig by row.
  */
