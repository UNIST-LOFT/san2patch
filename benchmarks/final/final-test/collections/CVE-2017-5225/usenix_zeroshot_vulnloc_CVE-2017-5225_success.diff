diff --git a/tools/tiffcp.c b/tools/tiffcp.c
index bdf754c3..91488e87 100644
--- a/tools/tiffcp.c
+++ b/tools/tiffcp.c
@@ -1059,14 +1059,18 @@ bad:
  */
 DECLAREcpFunc(cpContig2SeparateByRow)
 {
-	tsize_t scanlinesizein = TIFFScanlineSize(in);
-	tsize_t scanlinesizeout = TIFFScanlineSize(out);
+	size_t scanlinesizein = TIFFScanlineSize(in);
+	size_t scanlinesizeout = TIFFScanlineSize(out);
 	tdata_t inbuf;
 	tdata_t outbuf;
 	register uint8 *inp, *outp;
 	register uint32 n;
 	uint32 row;
 	tsample_t s;
+	uint16 bitspersample = 0;
+	int bytes_per_sample = 1;
+	size_t required_in = 0;
+	size_t required_out = 0;
 
 	inbuf = _TIFFmalloc(scanlinesizein);
 	outbuf = _TIFFmalloc(scanlinesizeout);
@@ -1074,6 +1078,32 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 		goto bad;
 	_TIFFmemset(inbuf, 0, scanlinesizein);
 	_TIFFmemset(outbuf, 0, scanlinesizeout);
+
+	/* Rationale:
+	   The original code assumed one byte per sample and advanced the input
+	   pointer by 'spp' on each pixel, which causes out-of-bounds reads when
+	   BitsPerSample != 8 (samples occupy more or fewer than one byte).
+	   To prevent heap-buffer-overflow we compute the actual number of bytes
+	   per sample, verify that the allocated scanline buffers are large
+	   enough for the expected data, and then copy the sample data using
+	   the correct stride (spp * bytes_per_sample). For the common
+	   case of 1 byte per sample the fast path keeps the original behavior.
+	*/
+	/* Get bits per sample and compute bytes per sample */
+	if (!TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample))
+		bitspersample = 8; /* conservative default */
+	bytes_per_sample = (bitspersample + 7) / 8;
+
+	/* Compute required sizes to safely index into buffers */
+	required_in = (size_t)imagewidth * (size_t)spp * (size_t)bytes_per_sample;
+	required_out = (size_t)imagewidth * (size_t)bytes_per_sample;
+	if (scanlinesizein < required_in || scanlinesizeout < required_out) {
+		TIFFError(TIFFFileName(in),
+		    "Error, scanline buffer too small (in: %zu, out: %zu), need in: %zu out: %zu",
+		    scanlinesizein, scanlinesizeout, required_in, required_out);
+		goto bad;
+	}
+
 	/* unpack channels */
 	for (s = 0; s < spp; s++) {
 		for (row = 0; row < imagelength; row++) {
@@ -1084,11 +1114,19 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 				    (unsigned long) row);
 				goto bad;
 			}
-			inp = ((uint8*)inbuf) + s;
+			inp = ((uint8*)inbuf) + (size_t)s * (size_t)bytes_per_sample;
 			outp = (uint8*)outbuf;
 			for (n = imagewidth; n-- > 0;) {
-				*outp++ = *inp;
-				inp += spp;
+				if (bytes_per_sample == 1) {
+					/* fast path for common 8-bit samples */
+					*outp++ = *inp;
+					inp += spp;
+				} else {
+					/* copy multi-byte samples */
+					_TIFFmemcpy(outp, inp, (tsize_t)bytes_per_sample);
+					outp += bytes_per_sample;
+					inp += (size_t)spp * (size_t)bytes_per_sample;
+				}
 			}
 			if (TIFFWriteScanline(out, outbuf, row, s) < 0) {
 				TIFFError(TIFFFileName(out),
@@ -1112,8 +1150,8 @@ bad:
  */
 DECLAREcpFunc(cpSeparate2ContigByRow)
 {
-	tsize_t scanlinesizein = TIFFScanlineSize(in);
-	tsize_t scanlinesizeout = TIFFScanlineSize(out);
+	size_t scanlinesizein = TIFFScanlineSize(in);
+	size_t scanlinesizeout = TIFFScanlineSize(out);
 	tdata_t inbuf;
 	tdata_t outbuf;
 	register uint8 *inp, *outp;
