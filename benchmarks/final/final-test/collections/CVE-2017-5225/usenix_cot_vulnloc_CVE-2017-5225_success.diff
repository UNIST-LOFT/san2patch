diff --git a/tools/tiffcp.c b/tools/tiffcp.c
index bdf754c3..93c29995 100644
--- a/tools/tiffcp.c
+++ b/tools/tiffcp.c
@@ -1039,14 +1039,14 @@ DECLAREcpFunc(cpSeparate2SeparateByRow)
 				    (unsigned long) row);
 				goto bad;
 			}
-			if (TIFFWriteScanline(out, buf, row, s) < 0) {
-				TIFFError(TIFFFileName(out),
-				    "Error, can't write scanline %lu",
-				    (unsigned long) row);
-				goto bad;
-			}
+		if (TIFFWriteScanline(out, buf, row, s) < 0) {
+			TIFFError(TIFFFileName(out),
+			    "Error, can't write scanline %lu",
+			    (unsigned long) row);
+			goto bad;
 		}
 	}
+	}
 	_TIFFfree(buf);
 	return 1;
 bad:
@@ -1059,6 +1059,8 @@ bad:
  */
 DECLAREcpFunc(cpContig2SeparateByRow)
 {
+	size_t req_inbuf; /* rationale: compute required minimum input buffer size in bytes */
+	size_t req_outbuf; /* rationale: compute required minimum output buffer size in bytes */
 	tsize_t scanlinesizein = TIFFScanlineSize(in);
 	tsize_t scanlinesizeout = TIFFScanlineSize(out);
 	tdata_t inbuf;
@@ -1066,7 +1068,8 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 	register uint8 *inp, *outp;
 	register uint32 n;
 	uint32 row;
-	tsample_t s;
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 	tsample_t s;
 
 	inbuf = _TIFFmalloc(scanlinesizein);
 	outbuf = _TIFFmalloc(scanlinesizeout);
@@ -1074,6 +1077,44 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 		goto bad;
 	_TIFFmemset(inbuf, 0, scanlinesizein);
 	_TIFFmemset(outbuf, 0, scanlinesizeout);
+
+	/*
+	 * Rationale for changes:
+	 * The original code assumed the input and output scanline buffers
+	 * were large enough for the per-sample extraction loop. A crafted
+	 * TIFF could lead to scanlinesizein/scanlinesizeout being smaller
+	 * than required, causing reads/writes past the allocated buffers.
+	 * To prevent out-of-bounds reads (CWE-125), compute conservative
+	 * required sizes and validate them before the per-row loops.
+	 */
+
+	/* compute conservative required sizes to perform the separation:
+	 * Each extracted sample loop reads bytes at offsets: s + k * spp for
+	 * k in [0, imagewidth-1]. Therefore the highest byte offset needed is
+	 * s + (imagewidth-1)*spp which for the maximum s (spp-1) gives
+	 * (spp-1) + (imagewidth-1)*spp = imagewidth*spp + (spp-1) - spp =
+	 * imagewidth*spp + (spp-1) - spp = imagewidth*spp - 1 + (spp-1) - (spp-1)
+	 * Simpler conservative bound: imagewidth*spp + (spp-1)
+	 */
+	req_inbuf = (size_t)imagewidth * (size_t)spp + (size_t)(spp ? (spp - 1) : 0);
+	/* For output, we write imagewidth bytes per sample plane (one byte per pixel/sample)
+	 * so require at least imagewidth bytes in the output scanline buffer.
+	 */
+	req_outbuf = (size_t)imagewidth;
+
+	if ((size_t)scanlinesizein < req_inbuf) {
+		TIFFError(TIFFFileName(in),
+		    "Error, input scanline size too small (%lu < %zu)",
+		    (unsigned long) scanlinesizein, req_inbuf);
+		goto bad;
+	}
+	if ((size_t)scanlinesizeout < req_outbuf) {
+		TIFFError(TIFFFileName(out),
+		    "Error, output scanline size too small (%lu < %zu)",
+		    (unsigned long) scanlinesizeout, req_outbuf);
+		goto bad;
+	}
+
 	/* unpack channels */
 	for (s = 0; s < spp; s++) {
 		for (row = 0; row < imagelength; row++) {
@@ -1084,9 +1125,22 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 				    (unsigned long) row);
 				goto bad;
 			}
+			/*
+			 * Compute pointer and ensure inner loop won't read beyond inbuf.
+			 * Use the conservative checks above so the per-iteration checks
+			 * are not needed; keep loop simple and efficient.
+			 */
 			inp = ((uint8*)inbuf) + s;
 			outp = (uint8*)outbuf;
 			for (n = imagewidth; n-- > 0;) {
+				/* additional safety: check the next read offset is within bounds */
+				size_t offset = (size_t)(inp - (uint8*)inbuf);
+				if (offset >= (size_t)scanlinesizein) {
+					TIFFError(TIFFFileName(in),
+					    "Error, input scanline data too small at row %lu, sample %u",
+					    (unsigned long)row, (unsigned int)s);
+					goto bad;
+				}
 				*outp++ = *inp;
 				inp += spp;
 			}
@@ -1099,6 +1153,7 @@ DECLAREcpFunc(cpContig2SeparateByRow)
 		}
 	}
 	if (inbuf) _TIFFfree(inbuf);
+
 	if (outbuf) _TIFFfree(outbuf);
 	return 1;
 bad:
