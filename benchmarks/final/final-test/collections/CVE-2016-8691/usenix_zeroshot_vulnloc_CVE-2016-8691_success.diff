diff --git a/src/libjasper/jpc/jpc_dec.c b/src/libjasper/jpc/jpc_dec.c
index 7b6e1c2..8f88c52 100644
--- a/src/libjasper/jpc/jpc_dec.c
+++ b/src/libjasper/jpc/jpc_dec.c
@@ -1189,8 +1189,25 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 	  ++cmpt) {
 		cmpt->prec = siz->comps[compno].prec;
 		cmpt->sgnd = siz->comps[compno].sgnd;
-		cmpt->hstep = siz->comps[compno].hsamp;
-		cmpt->vstep = siz->comps[compno].vsamp;
+// FIXME: Crash
+		/* Rationale: Prevent division by zero in JPC_CEILDIV() below when
+		   component sampling factors (hsamp/vsamp) are malformed (zero).
+		   Instead of returning an error here (which would require cleaning
+		   up previously allocated structures), treat a zero sampling factor
+		   as 1 so the subsequent calculations are safe and behavior is
+		   well-defined. This is a minimal, localized fix that preserves
+		   existing functionality for valid inputs while avoiding a crash
+		   for malformed inputs. */
+		if (siz->comps[compno].hsamp == 0) {
+			cmpt->hstep = 1;
+		} else {
+			cmpt->hstep = siz->comps[compno].hsamp;
+		}
+		if (siz->comps[compno].vsamp == 0) {
+			cmpt->vstep = 1;
+		} else {
+			cmpt->vstep = siz->comps[compno].vsamp;
+		}
 		cmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -
 		  JPC_CEILDIV(dec->xstart, cmpt->hstep);
 		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -
@@ -1222,6 +1239,7 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 		  dec->tilewidth, dec->xend);
 		tile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *
 		  dec->tileheight, dec->yend);
+
 		tile->numparts = 0;
 		tile->partno = 0;
 		tile->pkthdrstream = 0;
diff --git a/src/libjasper/mif/mif_cod.c b/src/libjasper/mif/mif_cod.c
index 0b867f3..d747987 100644
--- a/src/libjasper/mif/mif_cod.c
+++ b/src/libjasper/mif/mif_cod.c
@@ -389,9 +389,15 @@ int mif_validate(jas_stream_t *in)
 	if (n < MIF_MAGICLEN) {
 		return -1;
 	}
-
+// FIXME: Crash
+ 
 	/* Compute the signature value. */
-	magic = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+	/* Rationale: buf[] has type uchar which is promoted to (signed) int
+	   when used in expressions. Shifting values that, when promoted to
+	   signed int, set the sign bit leads to undefined behavior. Cast
+	   each byte to an unsigned 32-bit type before shifting to ensure
+	   well-defined behavior and avoid left-shift of negative ints. */
+	magic = ((uint_fast32_t)buf[0] << 24) | ((uint_fast32_t)buf[1] << 16) | ((uint_fast32_t)buf[2] << 8) | (uint_fast32_t)buf[3];
 
 	/* Ensure that the signature is correct for this format. */
 	if (magic != MIF_MAGIC) {
diff --git a/src/libjasper/ras/ras_dec.c b/src/libjasper/ras/ras_dec.c
index a53da8b..e6dfa64 100644
--- a/src/libjasper/ras/ras_dec.c
+++ b/src/libjasper/ras/ras_dec.c
@@ -207,9 +207,28 @@ int ras_validate(jas_stream_t *in)
 	/* Did we read enough data? */
 	if (n < RAS_MAGICLEN) {
 		return -1;
-	}
-
-	magic = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+// FIXME: Crash
+ 	}
+
+	/*
+	 * Construct the magic value using unsigned promotions to avoid
+	 * undefined behavior when left-shifting values that would be
+	 * sign-extended if treated as signed ints (for example, 0xFF).
+	 *
+	 * Rationale: In the original code, buf[] (of type uchar) is
+	 * promoted to signed int before shifting. Shifting values with
+	 * the high bit set (>= 0x80) into the sign bit of a signed int
+	 * is undefined. Casting each byte to an unsigned 32-bit type
+	 * before shifting ensures well-defined behavior on all
+	 * platforms.
+	 *
+	 * Alternatives (not used here):
+	 *  - memcpy into a uint32_t and use ntohl() if endianness
+	 *    conversion is desired/necessary.
+	 *  - Build using (uint32_t) casts instead of uint_fast32_t.
+	 */
+	magic = ((uint_fast32_t)buf[0] << 24) | ((uint_fast32_t)buf[1] << 16) |
+		 ((uint_fast32_t)buf[2] << 8) | (uint_fast32_t)buf[3];
 
 	/* Is the signature correct for the Sun Rasterfile format? */
 	if (magic != RAS_MAGIC) {
@@ -240,6 +259,7 @@ static int ras_getdata(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,
 	return ret;
 }
 
+
 static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,
   jas_image_t *image)
 {
