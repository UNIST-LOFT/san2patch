diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..4de34b59 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3697,13 +3697,28 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                         TIFFError("", "Error reading strip %lu after %lu rows",
                                   (unsigned long) strip, (unsigned long)rows);
                         return 0;
-                }
-                bufp += bytes_read;
+                } 
+                bufp += ({ size_t total = (size_t)nstrips * (size_t)stripsize; 
+                           /* guard against unrealistic total overflow */
+                           if (nstrips != 0 && stripsize > 0 && total / (size_t)nstrips != (size_t)stripsize) { TIFFError("", "Integer overflow computing buffer end"); return 0; }
+                           uint8* buf_end = buf + total; 
+                           size_t remaining = (buf_end > bufp) ? (size_t)(buf_end - bufp) : 0;
+                           if (bytes_read > 0 && (size_t)bytes_read > remaining) {
+                               TIFFError("", "Strip %d: read %lu bytes, exceeds remaining buffer %zu",
+                                         (int)strip + 1, (unsigned long)bytes_read, remaining);
+                               return 0;
+                           }
+                           bytes_read; }) ;
         }
 
         return 1;
 } /* end readContigStripsIntoBuffer */
 
+/* Rationale: This change computes the total allocated buffer size as nstrips * stripsize,
+   computes remaining bytes from the current bufp, and checks that bytes_read does not exceed
+   remaining. On violation it logs an error and returns 0. A small integer-overflow check is
+   included for safety. The change is minimal (replacement only at the <PATCH> site) and
+   prevents any write beyond the allocated buffer. */
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
                              uint32 cols, uint32 rows, uint16 spp, uint16 bps,
