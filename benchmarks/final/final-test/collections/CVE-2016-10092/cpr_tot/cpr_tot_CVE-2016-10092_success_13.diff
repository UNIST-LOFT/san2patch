diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..690bb694 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,38 +3672,39 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
-        uint8* bufp = buf;
-        int32  bytes_read = 0;
-        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
-        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
-        tsize_t scanline_size = TIFFScanlineSize(in);
-
-        if (scanline_size == 0) {
-                TIFFError("", "TIFF scanline size is zero!");    
-                return 0;
-        }
+	    uint8* bufp = buf;
+	    int32  bytes_read = 0;
+	    uint32 strip, nstrips   = TIFFNumberOfStrips(in);
+	    uint32 stripsize = TIFFStripSize(in);
+	    uint32 rows = 0;
+	    uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
+	    tsize_t scanline_size = TIFFScanlineSize(in);
+
+	    if (scanline_size == 0) {
+		        TIFFError("", "TIFF scanline size is zero!");    
+		        return 0;
+	    }
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
-                bufp += bytes_read;
-        }
+	    for (strip = 0; strip < nstrips; strip++) {
+		        bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+		        rows = bytes_read / scanline_size;
+		        if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+		                TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+		                          (int)strip + 1, (unsigned long) bytes_read,
+		                          (unsigned long)stripsize);
+
+		        if (bytes_read < 0 && !ignore) {
+		                TIFFError("", "Error reading strip %lu after %lu rows",
+		                          (unsigned long) strip, (unsigned long)rows);
+		                return 0;
+		        } 
+		        bufp += (bytes_read > 0) ? (((size_t)bytes_read > ((size_t)stripsize * (size_t)nstrips - (size_t)(bufp - buf))) ? ((size_t)stripsize * (size_t)nstrips - (size_t)(bufp - buf)) : (size_t)bytes_read) : 0;
+	    }
 
-        return 1;
+	    return 1;
 } /* end readContigStripsIntoBuffer */
 
+Rationale: This minimal change clamps advancement of bufp so it can never move past the total expected buffer capacity (computed as stripsize * nstrips). The inline expression computes remaining space and advances by the smaller of bytes_read and remaining. This prevents writing beyond the allocated buffer (the ASan one-byte-before allocation issue) without restructuring the function. This patch is distinct because it enforces a global (total) buffer bound check rather than a per-strip check and does not log/abort â€” it conservatively truncates advancement to avoid overflow.
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
                              uint32 cols, uint32 rows, uint16 spp, uint16 bps,
