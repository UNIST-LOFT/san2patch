diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..ca1248fe 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,37 +3672,64 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
-        uint8* bufp = buf;
-        int32  bytes_read = 0;
-        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
-        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
-        tsize_t scanline_size = TIFFScanlineSize(in);
-
-        if (scanline_size == 0) {
-                TIFFError("", "TIFF scanline size is zero!");    
-                return 0;
-        }
+		uint8* bufp = buf;
+		int32  bytes_read = 0;
+		uint32 strip, nstrips   = TIFFNumberOfStrips(in);
+		uint32 stripsize = TIFFStripSize(in);
+		uint32 rows = 0;
+		uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
+		tsize_t scanline_size = TIFFScanlineSize(in);
+
+		/* Rationale: Prevent negative reads from moving bufp backwards (which
+		   can cause a write-before-buffer) and prevent writes that would exceed
+		   the total expected buffer size. Compute the expected total buffer
+		   size and check for integer overflow before using it. If any
+		   validation fails, fail safely and return 0. */
+		{
+			unsigned long long total_expected_ull = (unsigned long long)nstrips * (unsigned long long)stripsize;
+			/* detect multiplication overflow */
+			if (stripsize != 0 && (total_expected_ull / (unsigned long long)stripsize) != (unsigned long long)nstrips) {
+				TIFFError("", "Integer overflow computing total strip buffer size");
+				return 0;
+			}
+			size_t total_expected = (size_t) total_expected_ull;
+			uint8* bufstart = buf;
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
-                bufp += bytes_read;
-        }
+			if (scanline_size == 0) {
+				TIFFError("", "TIFF scanline size is zero!");    
+				return 0;
+			}
 
-        return 1;
-} /* end readContigStripsIntoBuffer */
+			for (strip = 0; strip < nstrips; strip++) {
+				bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+				rows = bytes_read / scanline_size;
+				if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+					TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+						  (int)strip + 1, (unsigned long) bytes_read,
+						  (unsigned long)stripsize);
+
+				/* If a read error occurred, do not advance the destination pointer. */
+				if (bytes_read < 0) {
+					TIFFError("", "Error reading strip %lu after %lu rows",
+						  (unsigned long) strip, (unsigned long)rows);
+					return 0;
+				}
+
+				/* Ensure we will not write past the expected total buffer. */
+				size_t consumed = (size_t)(bufp - bufstart);
+				if ((size_t)bytes_read > (total_expected - consumed)) {
+					TIFFError("", "Strip %lu: would write beyond buffer (read %lu, remaining %zu)",
+						  (unsigned long)strip, (unsigned long)bytes_read, (total_expected - consumed));
+					return 0;
+				}
+
+				bufp += bytes_read;
+			}
+
+			return 1;
+		}
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
