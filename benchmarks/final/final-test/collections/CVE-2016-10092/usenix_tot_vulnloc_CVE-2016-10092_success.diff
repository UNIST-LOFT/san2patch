diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..c85fee35 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,37 +3672,81 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
-        uint8* bufp = buf;
-        int32  bytes_read = 0;
-        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
-        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
-        tsize_t scanline_size = TIFFScanlineSize(in);
-
-        if (scanline_size == 0) {
-                TIFFError("", "TIFF scanline size is zero!");    
-                return 0;
-        }
+	uint8* bufp = buf;
+	int32  bytes_read = 0;
+	uint32 strip, nstrips   = TIFFNumberOfStrips(in);
+	uint32 stripsize = TIFFStripSize(in);
+	uint32 rows = 0;
+	uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
+	tsize_t scanline_size = TIFFScanlineSize(in);
+
+	if (scanline_size == 0) {
+		TIFFError("", "TIFF scanline size is zero!");    
+		return 0;
+	}
+// Rationale:
+// - Compute the total buffer size expected for all strips in a way that detects
+//   overflow. Use an unsigned wide type for the multiplication and ensure the
+//   resulting total fits in size_t. Initialize a "read_base" and "remaining"
+//   variables and enforce strict bounds checks before calling TIFFReadEncodedStrip
+//   and before advancing bufp. Reject/abort when decoder returns more bytes
+//   than remaining or when integer overflow is detected.
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
-                bufp += bytes_read;
-        }
+	{
+		/* Compute total expected buffer size and initialize remaining. */
+		unsigned long long total_size_ull = (unsigned long long)stripsize * (unsigned long long)nstrips;
+		if (nstrips != 0 && total_size_ull > (unsigned long long)((size_t)-1)) {
+			TIFFError("", "Image is too large to process (integer overflow)");
+			return 0;
+		}
+		size_t remaining = (size_t)total_size_ull;
+		uint8* read_base = buf;
+
+		for (strip = 0; strip < nstrips; strip++) {
+			if (remaining == 0) {
+				/* No more space available for further strips. */
+				TIFFError("", "Not enough buffer space for strip %lu", (unsigned long)strip);
+				return 0;
+			}
 
-        return 1;
-} /* end readContigStripsIntoBuffer */
+			bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+
+			/* Validate bytes_read before using it. */
+			if (bytes_read < 0) {
+				if (!ignore) {
+					rows = bytes_read / scanline_size;
+					TIFFError("", "Error reading strip %lu after %lu rows",
+						(unsigned long) strip, (unsigned long)rows);
+					return 0;
+				} else {
+					/* If errors are being ignored, do not advance the buffer by a
+					 * negative value. Treat as zero bytes read to avoid moving
+					 * bufp backwards which can cause out-of-bounds writes. */
+					bytes_read = 0;
+				}
+			}
+
+			/* Now safe to cast bytes_read to size_t because it's non-negative. */
+			if ((size_t)bytes_read > remaining) {
+				TIFFError("", "Strip %d: decoder returned %ld bytes which exceeds remaining buffer %zu",
+					(int)strip, (long)bytes_read, remaining);
+				return 0;
+			}
+
+			rows = bytes_read / scanline_size;
+			if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+				TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+					(int)strip + 1, (unsigned long) bytes_read,
+					(unsigned long)stripsize);
+
+			bufp += bytes_read;
+			remaining -= (size_t)bytes_read;
+		}
+	}
+
+	return 1;
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6116,33 +6160,61 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */
   /* outside buffer */
   if (!read_buff)
-  {
-    if( buffsize > 0xFFFFFFFFU - 3 )
+{
+    /* Rationale:
+     * 1) Ensure we do not overflow size computations when adding the extra 3 bytes.
+     * 2) Use SIZE_MAX-based check which is portable for size_t rather than assuming 32-bit.
+     * 3) Check the return value of _TIFFmalloc and report failure immediately.
+     * This defends against integer wraparound/overflow that could cause undersized
+     * allocations and subsequent out-of-bounds writes. It preserves the original
+     * behaviour (allocation of buffsize+3 bytes) but makes the allocation logic
+     * robust to extreme/malicious buffsize values.
+     */
+    if (buffsize > (size_t)SIZE_MAX - 3)
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+         return (-1);
     }
-    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
-  }
-  else
+    read_buff = (unsigned char *)_TIFFmalloc(buffsize + 3);
+    if (!read_buff)
     {
+        TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+        return (-1);
+    }
+}
+else
+{
     if (prev_readsize < buffsize)
     {
-      if( buffsize > 0xFFFFFFFFU - 3 )
+      /* Rationale:
+       * Same protections for realloc path: ensure the total size (buffsize+3)
+       * cannot overflow, and ensure realloc result is validated. If realloc
+       * fails we try a fresh allocation and validate that too. This avoids
+       * proceeding with a NULL or partially valid buffer which could lead to
+       * writes out of bounds later in decoding.
+       */
+      if (buffsize > (size_t)SIZE_MAX - 3)
       {
           TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
           return (-1);
       }
-      new_buff = _TIFFrealloc(read_buff, buffsize+3);
+      new_buff = (unsigned char *)_TIFFrealloc(read_buff, buffsize + 3);
       if (!new_buff)
         {
-	free (read_buff);
-        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        /* _TIFFrealloc failed; free the old buffer and try a fresh allocation. */
+        _TIFFfree(read_buff);
+        read_buff = (unsigned char *)_TIFFmalloc(buffsize + 3);
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+            return (-1);
+        }
         }
       else
         read_buff = new_buff;
       }
-    }
+}
+
   if (!read_buff)
     {
     TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
