diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..c4571319 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,37 +3672,75 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
-        uint8* bufp = buf;
-        int32  bytes_read = 0;
-        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
-        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
-        tsize_t scanline_size = TIFFScanlineSize(in);
-
-        if (scanline_size == 0) {
-                TIFFError("", "TIFF scanline size is zero!");    
-                return 0;
-        }
+	/* Rationale: Prevent out-of-bounds writes by bounding each read to the remaining
+	   space in the destination buffer. Compute the total expected allocation safely
+	   and pass a bounded size to TIFFReadEncodedStrip instead of -1. After each
+	   read clamp the advance by the actual bytes available. This avoids writing
+	   before buf or past the end even if the strip decoder attempts to produce
+	   more data than expected. */
+	uint8* bufp = buf;
+	int32  bytes_read = 0;
+	uint32 strip, nstrips   = TIFFNumberOfStrips(in);
+	uint32 stripsize = TIFFStripSize(in);
+	uint32 rows = 0;
+	uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
+	tsize_t scanline_size = TIFFScanlineSize(in);
+
+	if (scanline_size == 0) {
+		TIFFError("", "TIFF scanline size is zero!");    
+		return 0;
+	}
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
-                bufp += bytes_read;
-        }
+	/* Compute total allocated size for the buffer and guard against overflow */
+	{
+		size_t total_alloc;
+		if (stripsize == 0 || nstrips > (uint32)(SIZE_MAX / (size_t)stripsize)) {
+			/* overflow or zero strip size - fail safe */
+			TIFFError("", "Invalid strip size/number, potential overflow");
+			return 0;
+		}
+		total_alloc = (size_t)nstrips * (size_t)stripsize;
+
+		/* bytes_left tracks how many bytes remain to be written into buf */
+		size_t bytes_left = total_alloc;
+
+		for (strip = 0; strip < nstrips; strip++) {
+			if (bytes_left == 0) /* nothing left to read into */
+				break;
+
+			/* Call the decoder with a bounded size to avoid overruns */
+			bytes_read = TIFFReadEncodedStrip (in, strip, bufp, (tsize_t)bytes_left);
+			rows = (bytes_read > 0) ? (bytes_read / scanline_size) : 0;
+			if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+				TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+					  (int)strip + 1, (unsigned long) bytes_read,
+					  (unsigned long)stripsize);
+
+			if (bytes_read < 0 && !ignore) {
+				TIFFError("", "Error reading strip %lu after %lu rows",
+					  (unsigned long) strip, (unsigned long)rows);
+				return 0;
+			}
 
-        return 1;
-} /* end readContigStripsIntoBuffer */
+			/* bytes_read is non-negative here; clamp to remaining space */
+			{
+				size_t r = (size_t)bytes_read;
+				if (r > bytes_left) {
+					TIFFError("", "Strip %d: decoded %zu bytes exceeds remaining buffer (%zu); truncating",
+						  (int)strip + 1, r, bytes_left);
+					r = bytes_left;
+				}
+				bufp += r;
+				bytes_left -= r;
+				if (bytes_left == 0)
+					break;
+			}
+		}
+	}
+
+	return 1;
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
