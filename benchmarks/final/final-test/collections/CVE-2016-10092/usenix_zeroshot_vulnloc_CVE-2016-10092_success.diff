diff --git a/libtiff/tif_unix.c b/libtiff/tif_unix.c
index 7c7bc961..7ad0cb58 100644
--- a/libtiff/tif_unix.c
+++ b/libtiff/tif_unix.c
@@ -335,9 +335,28 @@ _TIFFmemset(void* p, int v, tmsize_t c)
 }
 
 void
-_TIFFmemcpy(void* d, const void* s, tmsize_t c)
+// FIXME: Crash
+ _TIFFmemcpy(void* d, const void* s, tmsize_t c)
 {
-	memcpy(d, s, (size_t) c);
+	/* Rationale for the change:
+	   The original implementation directly cast the signed tmsize_t 'c' to
+	   size_t and called memcpy. If 'c' is negative (or zero), casting to
+	   size_t produces a very large unsigned value which can lead to
+	   heap-buffer-overflow when passed to memcpy. Additionally, overlapping
+	   source and destination regions may cause undefined behavior with
+	   memcpy. To mitigate these issues we:
+	   - reject non-positive copy lengths (c <= 0) so negative sizes are not
+	     converted to huge size_t values.
+	   - guard against NULL pointers for source/destination.
+	   - use memmove instead of memcpy to safely handle overlapping ranges.
+	   These changes are minimal, preserve the function's semantics for
+	   valid inputs, and prevent the overflow observed by AddressSanitizer.
+	*/
+	if (c <= 0)
+		return;
+	if (d == NULL || s == NULL)
+		return;
+	memmove(d, s, (size_t) c);
 }
 
 int
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..16f8af85 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3670,6 +3670,18 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
   return (0);
   } /* end extractContigSamplesToTileBuffer */
 
+/* Rationale:
+ * The original readContigStripsIntoBuffer did not verify that the
+ * total bytes read from strips would fit into the buffer provided by
+ * the caller. TIFFReadEncodedStrip can potentially return a value
+ * larger than expected (or cause unexpected sizes), which could lead
+ * to bufp advancing past the end of the allocated buffer and cause a
+ * heap-buffer-overflow. To mitigate this we compute the maximum
+ * expected buffer size (stripsize * nstrips) and check before
+ * advancing bufp. If a strip read would overflow the buffer we report
+ * an error and abort reading. We also check for negative reads early
+ * and validate scanline_size.
+ */
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
         uint8* bufp = buf;
@@ -3684,21 +3696,45 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
+// FIXME: Crash
+
+        /* compute the maximum buffer size we expect to fill: stripsize * nstrips
+         * Use 64-bit arithmetic to avoid overflow for large images. If stripsize
+         * or nstrips are zero this results in maxbuf==0 and reads will be rejected.
+         */
+        {
+                uint64_t maxbuf = (uint64_t)stripsize * (uint64_t)nstrips;
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
+                for (strip = 0; strip < nstrips; strip++) {
+                        bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+
+                        /* Check for error first */
+                        if (bytes_read < 0 && !ignore) {
+                                rows = (uint32)((bufp - buf) / (scanline_size ? scanline_size : 1));
+                                TIFFError("", "Error reading strip %lu after %lu rows",
+                                          (unsigned long) strip, (unsigned long)rows);
+                                return 0;
+                        }
+
+                        rows = (bytes_read > 0 && scanline_size) ? (bytes_read / scanline_size) : 0;
+
+                        if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+                                TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+                                          (int)strip + 1, (unsigned long) bytes_read,
+                                          (unsigned long)stripsize);
+
+                        /* Prevent buffer overflow: ensure we don't advance bufp past maxbuf */
+                        if (bytes_read > 0) {
+                                uint64_t used = (uint64_t)(bufp - buf);
+                                if (maxbuf < used || (uint64_t)bytes_read > (maxbuf - used)) {
+                                        TIFFError("", "Strip %d: read %lu bytes would overflow buffer (max %lu, used %lu)",
+                                                  (int)strip + 1, (unsigned long) bytes_read,
+                                                  (unsigned long) maxbuf, (unsigned long) used);
+                                        return 0;
+                                }
+                                bufp += bytes_read;
+                        }
                 }
-                bufp += bytes_read;
         }
 
         return 1;
@@ -6101,7 +6137,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if (input_photometric == PHOTOMETRIC_YCBCR)
       {
       TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
- 		           &subsampling_horiz, &subsampling_vert);
+ 		   &subsampling_horiz, &subsampling_vert);
       if (subsampling_horiz != 1 || subsampling_vert != 1)
         {
 	TIFFError("loadImage", 
@@ -6115,18 +6151,39 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   read_buff = *read_ptr;
   /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */
   /* outside buffer */
+  /* Rationale:
+     AddressSanitizer reported a heap-buffer-overflow when writing the 3
+     guard bytes at read_buff[buffsize..buffsize+2]. The root cause is that
+     the code assumed the existing buffer (when read_buff != NULL) had at
+     least 'buffsize' bytes available, but did not ensure there were
+     additional 3 guard bytes. To prevent out-of-bounds writes we must
+     guarantee the allocated buffer size is at least (buffsize + 3).
+
+     Fix strategy applied here:
+     - When allocating or (re)allocating, always request buffsize+3 bytes.
+     - When an existing buffer is present, require its recorded size
+       (prev_readsize) to be at least buffsize+3; otherwise reallocate.
+     - Update prev_readsize after successful (re)allocation so subsequent
+       code knows the actual allocated space.
+     - Check for allocation failures consistently and avoid writing guard
+       bytes unless the buffer is confirmed large enough.
+  */
   if (!read_buff)
   {
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    if (read_buff)
+      prev_readsize = buffsize + 3;
   }
   else
     {
-    if (prev_readsize < buffsize)
+    /* Ensure existing buffer has space for the requested data plus 3 guard bytes */
+    if (prev_readsize < (buffsize + 3))
     {
       if( buffsize > 0xFFFFFFFFU - 3 )
       {
@@ -6136,11 +6193,14 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
       new_buff = _TIFFrealloc(read_buff, buffsize+3);
       if (!new_buff)
         {
+	/* If realloc fails, try allocating a fresh buffer of the required size. */
 	free (read_buff);
         read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
         }
       else
         read_buff = new_buff;
+      if (read_buff)
+        prev_readsize = buffsize + 3;
       }
     }
   if (!read_buff)
@@ -6149,6 +6209,13 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     return (-1);
     }
 
+  /* Final sanity: ensure we actually have room for the guard bytes. */
+  if (prev_readsize < (buffsize + 3))
+  {
+    TIFFError("loadImage", "Internal error: insufficient read buffer size");
+    return (-1);
+  }
+
   read_buff[buffsize] = 0;
   read_buff[buffsize+1] = 0;
   read_buff[buffsize+2] = 0;
