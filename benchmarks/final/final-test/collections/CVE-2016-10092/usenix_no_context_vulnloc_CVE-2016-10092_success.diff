diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..412aa4a9 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -6031,6 +6031,25 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if (buffsize < (uint32)(ntiles * tl * tile_rowsize))
       {
       buffsize = ntiles * tl * tile_rowsize;
+/* Rationale: introduce defensive validation and sanitization of computed sizes.
+   Use 64-bit intermediates to detect overflow and reject inputs that would
+   cause buffer allocations or copies to exceed addressable limits. Also
+   normalize buffsize to a safe maximum if needed to avoid later out-of-bounds
+   behavior. */
+{
+    uint64_t total = (uint64_t)ntiles * (uint64_t)tl * (uint64_t)tile_rowsize;
+    if (total == 0 && (ntiles != 0 && tl != 0 && tile_rowsize != 0)) {
+        /* overflowed to zero (unlikely in 64-bit) or unexpected; treat as error */
+        TIFFError("loadImage", "Integer overflow when calculating buffer size (tiles)");
+        exit(-1);
+    }
+    if (total > (uint64_t)SIZE_MAX) {
+        TIFFError("loadImage", "Requested buffer size too large");
+        exit(-1);
+    }
+    /* Assign the safe validated value */
+    buffsize = (size_t)total;
+}
       if (ntiles != (buffsize / tl / tile_rowsize))
       {
 	TIFFError("loadImage", "Integer overflow when calculating buffer size");
@@ -6058,17 +6077,44 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     nstrips = TIFFNumberOfStrips(in);
     if (nstrips == 0 || stsize == 0)
     {
-	TIFFError("loadImage", "File appears to be striped, but the number of stipes or stripe size is zero.");
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 	TIFFError("loadImage", "File appears to be striped, but the number of stipes or stripe size is zero.");
 	exit(-1);
     }
 
-    buffsize = stsize * nstrips;
+    /* Validate strip totals in 64-bit and ensure we do not exceed SIZE_MAX. */
+    {
+        uint64_t total = (uint64_t)stsize * (uint64_t)nstrips;
+        if (total == 0 && (stsize != 0 && nstrips != 0)) {
+            TIFFError("loadImage", "Integer overflow when calculating buffer size (strips)");
+            exit(-1);
+        }
+        if (total > (uint64_t)SIZE_MAX) {
+            TIFFError("loadImage", "Requested strip buffer too large");
+            exit(-1);
+        }
+        buffsize = (size_t)total;
+    }
     if (stsize != (buffsize / nstrips))
     {
 	TIFFError("loadImage", "Integer overflow when calculating buffer size");
 	exit(-1);
     }
-    buffsize_check = ((length * width * spp * bps) + 7);
+    /* Compute expected image byte size using 64-bit arithmetic and validate. */
+    {
+        uint64_t expected_bits = (uint64_t)length * (uint64_t)width * (uint64_t)spp * (uint64_t)bps;
+        uint64_t expected_bytes = (expected_bits + 7) / 8;
+        if (expected_bits / (uint64_t)bps != (uint64_t)length * (uint64_t)width * (uint64_t)spp) {
+            /* overflow detected in bits calculation */
+            TIFFError("loadImage", "Integer overflow detected.");
+            exit(-1);
+        }
+        if (expected_bytes > (uint64_t)UINT32_MAX) {
+            TIFFError("loadImage", "Image size too large");
+            exit(-1);
+        }
+        buffsize_check = (uint32) (expected_bytes * 8 + 7);
+    }
     if (length != ((buffsize_check - 7) / width / spp / bps))
     {
 	TIFFError("loadImage", "Integer overflow detected.");
@@ -6087,10 +6133,11 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if (dump->infile != NULL)
       dump_info (dump->infile, dump->format, "",
                  "Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u",
-		 stsize, nstrips, rowsperstrip, scanlinesize);
+	     stsize, nstrips, rowsperstrip, scanlinesize);
     }
   
   if (input_compression == COMPRESSION_JPEG)
+
     {  /* Force conversion to RGB */
     jpegcolormode = JPEGCOLORMODE_RGB;
     TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
