diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..c6df6823 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,6 +3672,12 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
+        /* Rationale: validate computed buffer boundaries and guard against
+         * negative/oversized read results. Compute the total expected buffer
+         * size from strip count and strip size, check for multiplication
+         * overflow, and ensure each strip's bytes_read does not move bufp
+         * before buf or past the allocated buffer. On any inconsistency
+         * return an error rather than permitting out-of-bounds writes. */
         uint8* bufp = buf;
         int32  bytes_read = 0;
         uint32 strip, nstrips   = TIFFNumberOfStrips(in);
@@ -3684,21 +3690,53 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
-
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+        /* compute total buffer size and check for overflow */
+        {
+                size_t total_size = (size_t)nstrips * (size_t)stripsize;
+                if (stripsize != 0 && total_size / (size_t)stripsize != (size_t)nstrips) {
+                        TIFFError("", "Integer overflow computing buffer size");
+                        return 0;
+                }
+                if (buf == NULL) {
+                        TIFFError("", "NULL destination buffer");
                         return 0;
                 }
-                bufp += bytes_read;
+
+                for (strip = 0; strip < nstrips; strip++) {
+                        bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+                        rows = bytes_read / scanline_size;
+                        if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+                                TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+                                          (int)strip + 1, (unsigned long) bytes_read,
+                                          (unsigned long)stripsize);
+
+                        if (bytes_read < 0 && !ignore) {
+                                TIFFError("", "Error reading strip %lu after %lu rows",
+                                          (unsigned long) strip, (unsigned long)rows);
+                                return 0;
+                        }
+
+                        /* Validate that advancing bufp by bytes_read stays within total_size */
+                        {
+                                size_t dest_off = (size_t)(bufp - buf);
+                                if (bytes_read < 0) {
+                                        /* If caller chose to ignore errors, do not allow
+                                         * a negative advance which would move bufp before
+                                         * the buffer start. Fail instead. */
+                                        TIFFError("", "Negative read size (%d) for strip %lu",
+                                                  bytes_read, (unsigned long)strip);
+                                        return 0;
+                                }
+                                if ((size_t)bytes_read > total_size - dest_off) {
+                                        TIFFError("", "Strip %lu would overflow destination buffer (%zu + %d > %zu)",
+                                                  (unsigned long)strip, dest_off, bytes_read, total_size);
+                                        return 0;
+                                }
+                        }
+
+                        bufp += bytes_read;
+                }
         }
 
         return 1;
@@ -6115,20 +6153,30 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   read_buff = *read_ptr;
   /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */
   /* outside buffer */
-  if (!read_buff)
+  /* Rationale: Prevent integer overflow when computing buffsize+3 by using SIZE_MAX
+   and ensure allocation succeeded before continuing. This avoids proceeding with a
+   NULL read_buff and ensures the size check is correct on platforms where
+   size_t is wider than 32-bit. */
+if (!read_buff)
   {
-    if( buffsize > 0xFFFFFFFFU - 3 )
+    if( buffsize > SIZE_MAX - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    if (!read_buff)
+    {
+        TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+        return (-1);
+    }
   }
   else
     {
     if (prev_readsize < buffsize)
     {
-      if( buffsize > 0xFFFFFFFFU - 3 )
+      if( buffsize > SIZE_MAX - 3 )
       {
           TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
           return (-1);
@@ -6138,11 +6186,17 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
         {
 	free (read_buff);
         read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+            return (-1);
+        }
         }
       else
         read_buff = new_buff;
       }
     }
+
   if (!read_buff)
     {
     TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
