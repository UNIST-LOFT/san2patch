diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..9e5fa67c 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3684,7 +3684,9 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
-
+/* Rationale: Minimal defensive checks placed before advancing the buffer
+   pointer: validate bytes_read and remaining buffer space. On any
+   violation return an error rather than performing an unchecked advance. */
         for (strip = 0; strip < nstrips; strip++) {
                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                 rows = bytes_read / scanline_size;
@@ -3698,11 +3700,29 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                                   (unsigned long) strip, (unsigned long)rows);
                         return 0;
                 }
+
+                /* Basic sanity checks to avoid buf overflow */
+                if (bytes_read != 0) {
+                        /* Ensure bytes_read is non-negative and not absurdly large */
+                        if (bytes_read < 0 || (uint32)bytes_read > stripsize) {
+                                TIFFError("", "Strip %lu: invalid bytes_read %d", (unsigned long)strip, bytes_read);
+                                return 0;
+                        }
+                        /* Ensure we won't advance before buf or past a conservative total */
+                        unsigned long long used = (unsigned long long)(bufp - buf);
+                        unsigned long long total = (unsigned long long)nstrips * (unsigned long long)stripsize;
+                        if (used + (unsigned long long)bytes_read > total) {
+                                TIFFError("", "Strip %lu: would exceed allocated buffer (used %llu need %d total %llu)",
+                                          (unsigned long)strip, used, bytes_read, total);
+                                return 0;
+                        }
+                }
                 bufp += bytes_read;
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6117,12 +6137,28 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   /* outside buffer */
   if (!read_buff)
   {
+    /* Rationale: perform an explicit size sanity check and refuse to proceed
+       if buffsize is zero or extremely large. This prevents subsequent
+       operations from using an invalid or too-small buffer. */
+    if (buffsize == 0) {
+        TIFFError("loadImage", "Invalid read buffer size (0)");
+        return (-1);
+    }
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    if (!read_buff)
+    {
+        TIFFError("loadImage", "Memory allocation failed for read buffer");
+        return (-1);
+    }
+    /* Clear the buffer to avoid leaving uninitialized memory; this also
+       initializes the sentinel bytes at the tail. */
+    memset(read_buff, 0, (size_t)(buffsize+3));
   }
   else
     {
@@ -6136,8 +6172,16 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
       new_buff = _TIFFrealloc(read_buff, buffsize+3);
       if (!new_buff)
         {
+	/* If realloc fails, do not proceed with a NULL buffer. Attempt to
+	   allocate a fresh buffer and ensure it is initialized before use. */
 	free (read_buff);
         read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Memory allocation failed for read buffer");
+            return (-1);
+        }
+        memset(read_buff, 0, (size_t)(buffsize+3));
         }
       else
         read_buff = new_buff;
