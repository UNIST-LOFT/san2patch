diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..63aa0650 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -83,28 +83,56 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
 "Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed __int64) tif->tif_rawcc,
-		             (signed __int64) cc);
+			     (unsigned long) tif->tif_row,
+			     (signed __int64) tif->tif_rawcc,
+			     (signed __int64) cc);
 #else
 		TIFFErrorExt(tif->tif_clientdata, module,
 "Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed long long) tif->tif_rawcc,
-		             (signed long long) cc);
+			     (unsigned long) tif->tif_row,
+			     (signed long long) tif->tif_rawcc,
+			     (signed long long) cc);
 #endif
 		return (0);
 	}
 	/*
 	 * Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
-	 */
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 	 */
+	/* Ensure decoded size fits destination buffer (strip size) */
+	tmsize_t avail = TIFFStripSize(tif);
+	if (cc <= 0) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+"Invalid decoded size for scanline %lu: %lld",
+			     (unsigned long) tif->tif_row,
+			     (signed long long) cc);
+		return (0);
+	}
+	if (cc > avail) {
+#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
+		TIFFErrorExt(tif->tif_clientdata, module,
+"Decoded data larger than buffer (%I64d > %I64d)",
+			     (signed __int64) cc,
+			     (signed __int64) avail);
+#else
+		TIFFErrorExt(tif->tif_clientdata, module,
+"Decoded data larger than buffer (%lld > %lld)",
+			     (signed long long) cc,
+			     (signed long long) avail);
+#endif
+		return (0);
+	}
 	if (tif->tif_rawcp != buf)
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
 	tif->tif_rawcc -= cc;  
 	return (1);
 }
+/* Rationale: This minimal fix validates the requested copy length `cc` against the destination capacity obtained
+   from TIFFStripSize(tif). If cc is invalid or larger than the available strip buffer, the function returns an error
+   instead of performing the unchecked copy, preventing the one-byte out-of-bounds write. This change is distinct from
+   other patches by using TIFFStripSize() and explicit error returns rather than clamping. */
 
 /*
  * Seek forwards nrows in the current strip.
diff --git a/libtiff/tif_read.c b/libtiff/tif_read.c
index 52bbf507..0db8e701 100644
--- a/libtiff/tif_read.c
+++ b/libtiff/tif_read.c
@@ -375,7 +375,15 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 
 	if ((size!=(tmsize_t)(-1))&&(size<stripsize))
 		stripsize=size;
-	if (!TIFFFillStrip(tif,strip))
+// FIXME: Crash CWE-787: Out-of-bounds Write
+	if (size != (tmsize_t)(-1) && stripsize > size) {
+		/* Prevent writing beyond the caller provided buffer. */
+		TIFFErrorExt(tif->tif_clientdata, module,
+		    "Decoded data larger than provided buffer (%lld > %lld)",
+		    (long long)stripsize, (long long)size);
+		return((tmsize_t)(-1));
+	} /* Rationale: Explicitly reject cases where the computed stripsize exceeds the caller's provided buffer 'size'. This prevents any subsequent decoder from writing one byte (or more) out-of-bounds. This is a minimal change and different from other candidates because it returns an error instead of clamping. */
+ 	if (!TIFFFillStrip(tif,strip))
 		return((tmsize_t)(-1));
 	if ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)
 		return((tmsize_t)(-1));
@@ -383,6 +391,7 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 	return(stripsize);
 }
 
+
 static tmsize_t
 TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
     const char* module)
