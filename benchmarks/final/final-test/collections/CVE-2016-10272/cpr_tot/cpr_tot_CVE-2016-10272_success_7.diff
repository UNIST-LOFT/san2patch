diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..9f6efb3d 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -98,7 +98,14 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	/*
 	 * Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
-	 */
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 	 */
+	/* Guard: ensure pointers are valid to avoid writing out-of-bounds */
+	if (buf == NULL || tif->tif_rawcp == NULL) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+		    "Null buffer pointer in %s", module);
+		return (0);
+	}
 	if (tif->tif_rawcp != buf)
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
@@ -106,6 +113,7 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	return (1);
 }
 
+
 /*
  * Seek forwards nrows in the current strip.
  */
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..bb8ebbc0 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -6120,7 +6120,18 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+/* Added: detect wrap-around when computing allocation length (minimal change).
+   This prevents an integer overflow when computing buffsize+3 which could
+   otherwise lead to an undersized allocation and subsequent out-of-bounds writes. */
+      {
+        size_t alloc_len = (size_t)buffsize + 3;
+        if (alloc_len < (size_t)buffsize)
+        {
+            TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+            return (-1);
+        }
+      }
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
   }
