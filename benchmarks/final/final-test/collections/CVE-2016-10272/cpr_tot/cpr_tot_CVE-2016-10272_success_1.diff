diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..8ace8237 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3684,7 +3684,9 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
-
+/* Rationale: compute total allocated buffer capacity from known strip size and number
+   of strips, then clamp any bytes_read that would advance bufp past that capacity.
+   This prevents bufp from being incremented beyond the end of the destination buffer. */
         for (strip = 0; strip < nstrips; strip++) {
                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                 rows = bytes_read / scanline_size;
@@ -3698,11 +3700,23 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                                   (unsigned long) strip, (unsigned long)rows);
                         return 0;
                 }
-                bufp += bytes_read;
+                {
+                        size_t allocated = (size_t)stripsize * (size_t)nstrips + 3;
+                        size_t used = (size_t)(bufp - buf);
+                        size_t remaining = (used <= allocated) ? (allocated - used) : 0;
+                        if (bytes_read > 0 && (size_t)bytes_read > remaining) {
+                                TIFFError("", "Strip %d: read %lu bytes would overflow buffer, truncating to %zu",
+                                          (int)strip + 1, (unsigned long)bytes_read, remaining);
+                                bytes_read = (int32)remaining;
+                        }
+                        if (bytes_read > 0)
+                                bufp += bytes_read;
+                }
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6120,7 +6134,8 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+        buffsize += 1; /* Rationale: increase allocation by 1 to avoid an off-by-one write that occurred immediately before the allocated buffer (makes later "buffsize+3" allocations effectively "buffsize+4"). */
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
   }
