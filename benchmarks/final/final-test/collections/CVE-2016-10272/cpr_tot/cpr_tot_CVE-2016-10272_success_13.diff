diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..4aa529a1 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -83,22 +83,44 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
 "Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed __int64) tif->tif_rawcc,
-		             (signed __int64) cc);
+				 (unsigned long) tif->tif_row,
+				 (signed __int64) tif->tif_rawcc,
+				 (signed __int64) cc);
 #else
 		TIFFErrorExt(tif->tif_clientdata, module,
 "Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed long long) tif->tif_rawcc,
-		             (signed long long) cc);
+				 (unsigned long) tif->tif_row,
+				 (signed long long) tif->tif_rawcc,
+				 (signed long long) cc);
 #endif
 		return (0);
 	}
 	/*
 	 * Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
+	 * Rationale: perform bounds and overflow-safe checks before copying
+	 * to prevent a 1-byte write before the allocated buffer.
 	 */
+	if (cc <= 0) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+		             "invalid copy length %lld", (long long) cc);
+		return (0);
+	}
+	if (tif->tif_rawdata == NULL) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+		             "missing raw buffer");
+		return (0);
+	}
+	{
+		/* compute source offset in an overflow-safe way and validate */
+		ptrdiff_t src_off = tif->tif_rawcp - tif->tif_rawdata;
+		if (src_off < 0 || (uint64_t)src_off + (uint64_t)cc > (uint64_t)tif->tif_rawcc) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+			             "source raw buffer overrun (off=%td, len=%lld, rawcc=%u)",
+			             src_off, (long long)cc, (unsigned)tif->tif_rawcc);
+			return (0);
+		}
+	}
 	if (tif->tif_rawcp != buf)
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
@@ -106,6 +128,7 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	return (1);
 }
 
+
 /*
  * Seek forwards nrows in the current strip.
  */
