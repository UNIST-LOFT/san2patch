diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..90dcb699 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -83,22 +83,37 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
 "Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed __int64) tif->tif_rawcc,
-		             (signed __int64) cc);
+	             (unsigned long) tif->tif_row,
+	             (signed __int64) tif->tif_rawcc,
+	             (signed __int64) cc);
 #else
 		TIFFErrorExt(tif->tif_clientdata, module,
 "Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed long long) tif->tif_rawcc,
-		             (signed long long) cc);
+	             (unsigned long) tif->tif_row,
+	             (signed long long) tif->tif_rawcc,
+	             (signed long long) cc);
 #endif
 		return (0);
 	}
 	/*
 	 * Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
-	 */
+/* Validate source and destination before copying to avoid OOB */
+if (cc < 0) {
+	TIFFErrorExt(tif->tif_clientdata, module, "Negative copy size requested");
+	return (0);
+}
+if (tif->tif_rawdata == NULL || tif->tif_rawdatasize <= 0) {
+	TIFFErrorExt(tif->tif_clientdata, module, "Missing raw data buffer");
+	return (0);
+}
+/* ensure tif->tif_rawcp lies within tif->tif_rawdata..tif->tif_rawdata+tif->tif_rawdatasize */
+if (tif->tif_rawcp < tif->tif_rawdata ||
+    (size_t)(tif->tif_rawcp - tif->tif_rawdata) + (size_t)cc > (size_t)tif->tif_rawdatasize) {
+	TIFFErrorExt(tif->tif_clientdata, module, "Raw data bounds error");
+	return (0);
+}
+ 	*/
 	if (tif->tif_rawcp != buf)
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
@@ -106,6 +121,7 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	return (1);
 }
 
+
 /*
  * Seek forwards nrows in the current strip.
  */
