diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..b1cd3e17 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -99,6 +99,28 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	 * Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
 	 */
+	/*
+	 * Rationale: validate source pointer and requested length before copying.
+	 * Ensure tif->tif_rawcp lies within tif->tif_rawdata .. tif->tif_rawdata + tif->tif_rawcc
+	 * and that cc is non-negative and does not exceed remaining raw bytes.
+	 */
+	if (cc < 0 || tif->tif_rawcp < tif->tif_rawdata ||
+	    (size_t)((tif->tif_rawdata + tif->tif_rawcc) - tif->tif_rawcp) < (size_t)cc) {
+#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
+		TIFFErrorExt(tif->tif_clientdata, module,
+"Corrupt/insufficient raw data for scanline %lu: available %I64d, requested %I64d",
+		             (unsigned long) tif->tif_row,
+		             (signed __int64)(tif->tif_rawcc - (tmsize_t)(tif->tif_rawcp - tif->tif_rawdata)),
+		             (signed __int64) cc);
+#else
+		TIFFErrorExt(tif->tif_clientdata, module,
+"Corrupt/insufficient raw data for scanline %lu: available %lld, requested %lld",
+		             (unsigned long) tif->tif_row,
+		             (signed long long)(tif->tif_rawcc - (tmsize_t)(tif->tif_rawcp - tif->tif_rawdata)),
+		             (signed long long) cc);
+#endif
+		return (0);
+	}
 	if (tif->tif_rawcp != buf)
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
@@ -106,6 +128,7 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	return (1);
 }
 
+
 /*
  * Seek forwards nrows in the current strip.
  */
diff --git a/libtiff/tif_read.c b/libtiff/tif_read.c
index 52bbf507..8228a8f0 100644
--- a/libtiff/tif_read.c
+++ b/libtiff/tif_read.c
@@ -375,6 +375,16 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 
 	if ((size!=(tmsize_t)(-1))&&(size<stripsize))
 		stripsize=size;
+// FIXME: Crash CWE-787: Out-of-bounds Write
+	/* Basic defensive checks: ensure pointers/sizes look sane before decoding. */
+	if (buf == NULL) {
+		TIFFErrorExt(tif->tif_clientdata, module, "Null buffer passed to TIFFReadEncodedStrip");
+		return((tmsize_t)(-1));
+	}
+	if (stripsize < 0) {
+		TIFFErrorExt(tif->tif_clientdata, module, "Negative strip size computed");
+		return((tmsize_t)(-1));
+	}
 	if (!TIFFFillStrip(tif,strip))
 		return((tmsize_t)(-1));
 	if ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)
@@ -383,6 +393,7 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 	return(stripsize);
 }
 
+
 static tmsize_t
 TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
     const char* module)
