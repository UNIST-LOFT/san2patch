diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..4c82c17c 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -98,14 +98,33 @@ DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 	/*
 	 * Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
-	 */
-	if (tif->tif_rawcp != buf)
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 	 */
+	/* Patch: Validate requested copy length before copying to avoid
+	   writing before the destination buffer (out-of-bounds). */
+	if (cc <= 0) {
+		/* Nothing to copy or invalid length */
+		cc = 0;
+	} else if ((tmsize_t)cc > tif->tif_rawcc) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+"Invalid copy length: requested %lld bytes, only %u raw bytes available",
+				 (long long)cc, (unsigned)tif->tif_rawcc);
+		return (0);
+	}
+	if (tif->tif_rawcp != buf && cc > 0)
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
 	tif->tif_rawcc -= cc;  
 	return (1);
 }
 
+/* Rationale: This minimal change checks that 'cc' is positive and does not
+   exceed tif->tif_rawcc before performing the memcpy. If the length is
+   invalid, an error is reported and the function returns failure. This
+   prevents the observed 1-byte write before the heap buffer. This patch
+   is distinct from other variants because it rejects invalid lengths
+   (returns error) rather than clamping them. */
+
 /*
  * Seek forwards nrows in the current strip.
  */
diff --git a/libtiff/tif_read.c b/libtiff/tif_read.c
index 52bbf507..323d2f03 100644
--- a/libtiff/tif_read.c
+++ b/libtiff/tif_read.c
@@ -375,6 +375,20 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 
 	if ((size!=(tmsize_t)(-1))&&(size<stripsize))
 		stripsize=size;
+// FIXME: Crash CWE-787: Out-of-bounds Write
+	/* Ensure stripsize is positive and that the raw buffer
+	 * contains at least stripsize bytes before attempting to
+	 * fill and decode. This prevents _TIFFmemcpy or similar
+	 * helpers from writing past the start/end of the heap
+	 * raw buffer when the strip metadata is malformed.
+	 */
+	if (stripsize <= 0)
+		return((tmsize_t)(-1));
+	if ((tmsize_t)tif->tif_rawcc < stripsize) {
+		TIFFErrorExt(tif->tif_clientdata,module,
+		    "invalid strip size: requested %td, only %u raw bytes available",(tmsize_t)stripsize,(unsigned)tif->tif_rawcc);
+		return((tmsize_t)(-1));
+	}
 	if (!TIFFFillStrip(tif,strip))
 		return((tmsize_t)(-1));
 	if ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)
@@ -383,6 +397,7 @@ TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
 	return(stripsize);
 }
 
+
 static tmsize_t
 TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,
     const char* module)
