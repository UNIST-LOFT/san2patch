diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..f2818fa6 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,37 +3672,58 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
-        uint8* bufp = buf;
-        int32  bytes_read = 0;
-        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
-        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
-        tsize_t scanline_size = TIFFScanlineSize(in);
-
-        if (scanline_size == 0) {
-                TIFFError("", "TIFF scanline size is zero!");    
-                return 0;
-        }
-
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
-                bufp += bytes_read;
-        }
+		uint8* bufp = buf;
+		int32  bytes_read = 0;
+		uint32 strip, nstrips   = TIFFNumberOfStrips(in);
+		uint32 stripsize = TIFFStripSize(in);
+		uint32 rows = 0;
+		uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
+		tsize_t scanline_size = TIFFScanlineSize(in);
+
+		if (scanline_size == 0) {
+				TIFFError("", "TIFF scanline size is zero!");    
+				return 0;
+		}
+// FIXME: Crash CWE-787: Out-of-bounds Write
+ 
+		for (strip = 0; strip < nstrips; strip++) {
+				bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+				/* Rationale: prevent use of a negative bytes_read in subsequent
+				   arithmetic (rows calculation) which could underflow/overflow
+				   when assigned to an unsigned variable and cause out-of-bounds
+				   writes. Handle error early and clamp if we are explicitly
+				   ignoring errors. */
+				if (bytes_read < 0) {
+					if (!ignore) {
+						TIFFError("", "Error reading strip %lu", (unsigned long) strip);
+						return 0;
+					}
+					/* If ignoring errors, treat as zero bytes read to avoid negative math */
+					bytes_read = 0;
+				}
+
+				/* Rationale: ensure the decoder did not return more bytes than a
+				   strip can hold. This defends against implementations that may
+				   write past the expected strip buffer size. */
+				if ((unsigned int)bytes_read > stripsize) {
+					TIFFError("", "Strip %d: read %lu bytes, exceeds strip size %lu",
+						  (int)strip + 1, (unsigned long) bytes_read,
+						  (unsigned long)stripsize);
+					return 0;
+				}
+
+				rows = bytes_read / scanline_size;
+				if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+						TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+							  (int)strip + 1, (unsigned long) bytes_read,
+							  (unsigned long)stripsize);
+
+				bufp += bytes_read;
+		}
 
-        return 1;
-} /* end readContigStripsIntoBuffer */
+		return 1;
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6117,27 +6138,31 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   /* outside buffer */
   if (!read_buff)
   {
-    if( buffsize > 0xFFFFFFFFU - 3 )
+    if( buffsize > SIZE_MAX - 4 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+/* Rationale: Prevent integer overflow when adding padding and allocate
+   one extra padding byte (changed +3 -> +4). This provides an additional
+   safety margin for potential off-by-one writes discovered by ASan.
+   Also use SIZE_MAX to correctly detect potential size_t overflow. */
+         return (-1);
     }
-    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    read_buff = (unsigned char *)_TIFFmalloc(buffsize+4);
   }
   else
     {
     if (prev_readsize < buffsize)
     {
-      if( buffsize > 0xFFFFFFFFU - 3 )
+      if( buffsize > SIZE_MAX - 4 )
       {
           TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
           return (-1);
       }
-      new_buff = _TIFFrealloc(read_buff, buffsize+3);
+      new_buff = _TIFFrealloc(read_buff, buffsize+4);
       if (!new_buff)
         {
 	free (read_buff);
-        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        read_buff = (unsigned char *)_TIFFmalloc(buffsize+4);
         }
       else
         read_buff = new_buff;
