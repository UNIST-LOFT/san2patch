diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..77b77d5c 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3684,25 +3684,65 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
+// FIXME: Crash CWE-787: Out-of-bounds Write
 
         for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+                /* Use a temporary buffer with one-byte left padding when calling
+                   the decoder. Some decoders/predictors may write a byte before
+                   the provided buffer (negative offset). Passing tmp+1 ensures
+                   that such writes do not corrupt the caller-supplied buffer. */
+                uint8 *tmp = (uint8*)_TIFFmalloc((tsize_t)stripsize + 1);
+                if (!tmp) {
+                        TIFFError("", "Memory allocation failed reading strip %u", strip);
+                        return 0;
+                }
+
+                /* Call decoder into tmp+1 so that any -1 write stays inside tmp. */
+                bytes_read = TIFFReadEncodedStrip (in, strip, tmp + 1, -1);
                 rows = bytes_read / scanline_size;
+
+                if (bytes_read < 0) {
+                        _TIFFfree(tmp);
+                        if (!ignore) {
+                                TIFFError("", "Error reading strip %lu after %lu rows",
+                                          (unsigned long) strip, (unsigned long)rows);
+                                return 0;
+                        }
+                        /* if ignoring errors, just continue but don't advance bufp */
+                        continue;
+                }
+
+                /* Validate returned size before copying into buf. */
+                if ((uint32)bytes_read > stripsize) {
+                        TIFFError("", "Strip %d: read %lu bytes, exceeds strip size %lu",
+                                  (int)strip + 1, (unsigned long) bytes_read,
+                                  (unsigned long)stripsize);
+                        _TIFFfree(tmp);
+                        return 0;
+                }
+                if ((uint32)rows * (uint32)scanline_size != (uint32)bytes_read) {
+                        TIFFError("", "Strip %d: read %lu bytes does not align to scanline size %lu",
+                                  (int)strip + 1, (unsigned long) bytes_read,
+                                  (unsigned long)scanline_size);
+                        _TIFFfree(tmp);
+                        return 0;
+                }
+
+                /* Copy decoded data into the destination buffer and free tmp. */
+                _TIFFmemcpy(bufp, tmp + 1, (size_t)bytes_read);
+                _TIFFfree(tmp);
+
                 if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
                         TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
                                   (int)strip + 1, (unsigned long) bytes_read,
                                   (unsigned long)stripsize);
 
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
                 bufp += bytes_read;
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6117,32 +6157,52 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   /* outside buffer */
   if (!read_buff)
   {
-    if( buffsize > 0xFFFFFFFFU - 3 )
+    /* Rationale: Prevent integer overflow and ensure a minimum margin of
+       extra space for legacy predictor logic that may reference bytes
+       immediately before the buffer. Adding one extra byte of safety
+       margin in the allocation reduces the chance of a single-byte
+       underflow write causing heap corruption. */
+    if( buffsize > 0xFFFFFFFFU - 4 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
+    }
+    /* allocate one extra leading byte (total +4 instead of +3) to give a
+       small safety margin for decoders that might write a single byte
+       before the nominal start. */
+    read_buff = (unsigned char *)_TIFFmalloc(buffsize+4);
+    if (!read_buff)
+    {
+        TIFFError("loadImage", "Memory allocation failed for read buffer");
         return (-1);
     }
-    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
   }
   else
     {
     if (prev_readsize < buffsize)
     {
-      if( buffsize > 0xFFFFFFFFU - 3 )
+      if( buffsize > 0xFFFFFFFFU - 4 )
       {
           TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
           return (-1);
       }
-      new_buff = _TIFFrealloc(read_buff, buffsize+3);
+      new_buff = _TIFFrealloc(read_buff, buffsize+4);
       if (!new_buff)
         {
 	free (read_buff);
-        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        read_buff = (unsigned char *)_TIFFmalloc(buffsize+4);
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Memory allocation failed for read buffer");
+            return (-1);
+        }
         }
       else
         read_buff = new_buff;
       }
     }
+
   if (!read_buff)
     {
     TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
