diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..3787f089 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,37 +3672,54 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
-        uint8* bufp = buf;
-        int32  bytes_read = 0;
-        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
-        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
-        tsize_t scanline_size = TIFFScanlineSize(in);
-
-        if (scanline_size == 0) {
-                TIFFError("", "TIFF scanline size is zero!");    
-                return 0;
-        }
+	    uint8* bufp = buf;
+	    int32  bytes_read = 0;
+	    uint32 strip, nstrips   = TIFFNumberOfStrips(in);
+	    uint32 stripsize = TIFFStripSize(in);
+	    uint32 rows = 0;
+	    uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
+	    tsize_t scanline_size = TIFFScanlineSize(in);
+
+	    if (scanline_size == 0) {
+		    TIFFError("", "TIFF scanline size is zero!");    
+		    return 0;
+	    }
+	// Rationale: Protect against negative/invalid bytes_read values and pointer-wrap
+	//             which can lead to bufp being advanced before the buffer start
+	//             or pointer arithmetic overflow. If a read returns a negative
+	//             value and errors are being ignored, treat it as zero bytes read
+	//             instead of advancing bufp by a negative amount.
+ 
+	    for (strip = 0; strip < nstrips; strip++) {
+		    bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+		    rows = bytes_read / scanline_size;
+		    if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+			    TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+				      (int)strip + 1, (unsigned long) bytes_read,
+				      (unsigned long)stripsize);
+
+		    if (bytes_read < 0) {
+			    if (!ignore) {
+				    TIFFError("", "Error reading strip %lu after %lu rows",
+					      (unsigned long) strip, (unsigned long)rows);
+				    return 0;
+			    }
+			    /* If errors are ignored, do not advance the buffer by a negative value. */
+			    bytes_read = 0;
+		    }
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
-                        return 0;
-                }
-                bufp += bytes_read;
-        }
+		    /* Ensure pointer arithmetic does not wrap. */
+		    if ((size_t)bufp + (size_t)bytes_read < (size_t)bufp) {
+			    TIFFError("", "Integer overflow while advancing buffer pointer");
+			    return 0;
+		    }
 
-        return 1;
-} /* end readContigStripsIntoBuffer */
+		    bufp += bytes_read;
+	    }
+
+	    return 1;
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6120,9 +6137,19 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    /* Rationale: Ensure malloc succeeded. A NULL read_buff left unchecked
+       can lead to later writes into an invalid pointer or to attempts to
+       realloc/free invalid memory. Fail early to avoid proceeding with
+       an invalid buffer which could cause out-of-bounds writes elsewhere. */
+    if (!read_buff)
+      {
+        TIFFError("loadImage", "Unable to allocate read buffer");
+        return (-1);
+      }
   }
   else
     {
@@ -6136,13 +6163,17 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
       new_buff = _TIFFrealloc(read_buff, buffsize+3);
       if (!new_buff)
         {
-	free (read_buff);
-        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+/* Rationale: On realloc failure do not free the existing buffer and then
+   continue using a now-missing buffer. Return an error instead to avoid
+   proceeding with an insufficient buffer which could cause OOB writes. */
+        TIFFError("loadImage", "Unable to reallocate read buffer");
+        return (-1);
         }
       else
         read_buff = new_buff;
       }
     }
+
   if (!read_buff)
     {
     TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
