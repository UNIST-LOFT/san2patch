diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..45566336 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3684,25 +3684,55 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
+// FIXME: Crash CWE-787: Out-of-bounds Write
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
+        /* Rationale: compute an upper bound for the total decoded data size (nstrips * stripsize)
+         * and maintain a "remaining" counter. Detect integer overflow of the multiplication and
+         * ensure that each bytes_read does not exceed the remaining buffer before advancing bufp.
+         */
+        {
+                size_t expected = (size_t)nstrips * (size_t)stripsize;
+                /* detect multiplication overflow */
+                if (stripsize != 0 && expected / stripsize != (size_t)nstrips) {
+                        TIFFError("", "Integer overflow computing expected buffer size");
                         return 0;
                 }
-                bufp += bytes_read;
+                size_t remaining = expected;
+
+                for (strip = 0; strip < nstrips; strip++) {
+                        bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+                        if (bytes_read < 0 && !ignore) {
+                                rows = (uint32)(((size_t)bytes_read) / (size_t)scanline_size);
+                                TIFFError("", "Error reading strip %lu after %lu rows",
+                                          (unsigned long) strip, (unsigned long)rows);
+                                return 0;
+                        }
+
+                        /* defensive bounds check: ensure the decoded data fits in the remaining buffer */
+                        if (bytes_read > 0) {
+                                if ((size_t)bytes_read > remaining) {
+                                        TIFFError("", "Strip %lu: decoded %ld bytes would overflow destination (remaining %zu)",
+                                                  (unsigned long)strip, (long)bytes_read, remaining);
+                                        return 0;
+                                }
+                        }
+
+                        rows = (uint32)(((size_t)bytes_read) / (size_t)scanline_size);
+                        if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+                                TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+                                          (int)strip + 1, (unsigned long) bytes_read,
+                                          (unsigned long)stripsize);
+
+                        if (bytes_read > 0) {
+                                bufp += bytes_read;
+                                remaining -= (size_t)bytes_read;
+                        }
+                }
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6117,27 +6147,41 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   /* outside buffer */
   if (!read_buff)
   {
-    if( buffsize > 0xFFFFFFFFU - 3 )
+    /* Rationale: Prevent integer overflow and ensure allocation success.
+       Allocate an extra byte (padding) and check for allocation failure
+       to avoid subsequent out-of-bounds writes. */
+    if( buffsize > 0xFFFFFFFFU - 4 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
+    }
+    read_buff = (unsigned char *)_TIFFmalloc(buffsize+4);
+    if (!read_buff)
+    {
+        TIFFError("loadImage", "Unable to allocate read buffer");
         return (-1);
     }
-    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
   }
   else
     {
     if (prev_readsize < buffsize)
     {
-      if( buffsize > 0xFFFFFFFFU - 3 )
+      if( buffsize > 0xFFFFFFFFU - 4 )
       {
           TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
           return (-1);
       }
-      new_buff = _TIFFrealloc(read_buff, buffsize+3);
+      new_buff = _TIFFrealloc(read_buff, buffsize+4);
       if (!new_buff)
         {
 	free (read_buff);
-        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        read_buff = (unsigned char *)_TIFFmalloc(buffsize+4);
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Unable to allocate read buffer");
+            return (-1);
+        }
         }
       else
         read_buff = new_buff;
