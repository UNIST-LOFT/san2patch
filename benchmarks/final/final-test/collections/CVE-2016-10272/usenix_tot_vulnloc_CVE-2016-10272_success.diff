diff --git a/libtiff/tif_dumpmode.c b/libtiff/tif_dumpmode.c
index d01295d4..eb86e18d 100644
--- a/libtiff/tif_dumpmode.c
+++ b/libtiff/tif_dumpmode.c
@@ -77,35 +77,69 @@ DumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
 static int
 DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 {
+	/* Rationale: when decoder-reported length (cc) exceeds available raw data,
+	   optionally clamp to the available bytes to avoid overflow instead of
+	   outright failing. We still log an error. Also perform integer-overflow
+	   checks for destination pointer arithmetic and use memmove semantics to be
+	   safe for overlapping memory. This variant favors graceful degradation by
+	   truncating rather than failing in some malformed-file scenarios. */
 	static const char module[] = "DumpModeDecode";
 	(void) s;
+	if (cc < 0) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+		"Invalid (negative) request for %lld bytes", (signed long long) cc);
+		return (0);
+	}
+	/* If there are fewer raw bytes than requested, clamp to available bytes but
+	   report the inconsistency. */
 	if (tif->tif_rawcc < cc) {
 #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
 		TIFFErrorExt(tif->tif_clientdata, module,
-"Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed __int64) tif->tif_rawcc,
-		             (signed __int64) cc);
+"Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes; truncating",
+			 (unsigned long) tif->tif_row,
+			 (signed __int64) tif->tif_rawcc,
+			 (signed __int64) cc);
 #else
 		TIFFErrorExt(tif->tif_clientdata, module,
-"Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes",
-		             (unsigned long) tif->tif_row,
-		             (signed long long) tif->tif_rawcc,
-		             (signed long long) cc);
+"Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes; truncating",
+			 (unsigned long) tif->tif_row,
+			 (signed long long) tif->tif_rawcc,
+			 (signed long long) cc);
 #endif
+		/* clamp cc to available bytes to avoid out-of-bounds copy */
+		cc = tif->tif_rawcc;
+	}
+	/* Protect against NULL destination and integer overflow on buf+cc. */
+	if (buf == NULL) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+			"Invalid (NULL) destination buffer");
 		return (0);
 	}
-	/*
-	 * Avoid copy if client has setup raw
+	{
+		/* Use size_t for pointer-sized arithmetic to avoid relying on uintptr_t
+		   availability in environments where stdint.h may not have been included
+		   in this translation unit. Casting the pointer to size_t and checking
+		   for wraparound detects overflow on addition. */
+		size_t dst = (size_t) buf;
+		size_t dst_end = dst + (size_t) cc;
+		if (dst_end < dst) {
+			TIFFErrorExt(tif->tif_clientdata, module,
+				"Internal error: destination size overflow");
+			return (0);
+		}
+	}
+	/* Avoid copy if client has setup raw
 	 * data buffer to avoid extra copy.
 	 */
 	if (tif->tif_rawcp != buf)
+		/* use memmove semantics to be safe for overlapping regions */
 		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
 	tif->tif_rawcp += cc;
 	tif->tif_rawcc -= cc;  
 	return (1);
 }
 
+
 /*
  * Seek forwards nrows in the current strip.
  */
