diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..9222bbf1 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3684,8 +3684,41 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
+// FIXME: Crash CWE-787: Out-of-bounds Write
+/* Rationale: Validate remaining destination capacity before each strip read.
+   Compute the total expected buffer size as nstrips * stripsize using
+   size_t arithmetic and check for multiplication overflow.  This prevents
+   TIFFReadEncodedStrip (which may write up to stripsize bytes) from
+   overflowing the destination buffer. */
 
         for (strip = 0; strip < nstrips; strip++) {
+                /* Check for integer overflow when computing total expected size */
+                size_t sz_nstrips = (size_t)nstrips;
+                size_t sz_stripsize = (size_t)stripsize;
+                size_t total_expected;
+
+                if (sz_stripsize != 0 && sz_nstrips > SIZE_MAX / sz_stripsize) {
+                        TIFFError("", "Integer overflow computing expected buffer size");
+                        return 0;
+                }
+                total_expected = sz_nstrips * sz_stripsize;
+
+                /* Compute already used bytes in the destination buffer */
+                size_t used = (size_t)(bufp - buf);
+                if (used > total_expected) {
+                        TIFFError("", "Internal error: buffer usage exceeds expected size");
+                        return 0;
+                }
+                size_t remaining = total_expected - used;
+
+                /* Ensure remaining capacity is enough for a full strip (worst-case)
+                   to avoid any out-of-bounds writes from the decoder. */
+                if (remaining < sz_stripsize) {
+                        TIFFError("", "Insufficient buffer for strip %u: need %zu, remain %zu",
+                                  (unsigned)strip, sz_stripsize, remaining);
+                        return 0;
+                }
+
                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                 rows = bytes_read / scanline_size;
                 if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
@@ -3702,7 +3735,8 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6120,9 +6154,19 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    /* RATIONALE: Ensure allocation succeeded before continuing. A NULL
+       read_buff would lead to uncontrolled behavior later; failing early
+       prevents subsequent writes (including potential out-of-bounds writes).
+    */
+    if (!read_buff)
+    {
+        TIFFError("loadImage", "Unable to allocate read buffer");
+        return (-1);
+    }
   }
   else
     {
@@ -6138,6 +6182,16 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
         {
 	free (read_buff);
         read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        /* RATIONALE: Check result of fallback allocation and fail early
+           if it fails. This prevents subsequent code from operating on a
+           NULL pointer or an undersized buffer which could allow out-of-bounds
+           writes.
+        */
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Unable to allocate read buffer");
+            return (-1);
+        }
         }
       else
         read_buff = new_buff;
