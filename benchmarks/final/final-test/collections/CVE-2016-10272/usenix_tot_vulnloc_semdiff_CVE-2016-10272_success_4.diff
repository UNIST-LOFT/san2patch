diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..2e18c72b 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3680,29 +3680,62 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
         tsize_t scanline_size = TIFFScanlineSize(in);
 
+        /* Rationale: Add explicit bounds/overflow checks for the destination
+           buffer before advancing bufp. Compute a conservative buffer size
+           (number_of_strips * strip_size) and verify no integer overflow
+           occurs. For each strip ensure (dest_offset + bytes_read) fits in
+           the allocated buffer. If not, fail gracefully to avoid OOB writes. */
+
         if (scanline_size == 0) {
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+        {
+                size_t buffsize;
+                /* check for overflow when computing total buffer size */
+                if (stripsize != 0 && (size_t)nstrips > (SIZE_MAX / (size_t)stripsize)) {
+                        TIFFError("loadImage", "Calculated buffer size would overflow");
                         return 0;
                 }
-                bufp += bytes_read;
+                buffsize = (size_t)nstrips * (size_t)stripsize;
+
+                for (strip = 0; strip < nstrips; strip++) {
+                        bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
+                        rows = bytes_read / scanline_size;
+                        if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+                                TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+                                          (int)strip + 1, (unsigned long) bytes_read,
+                                          (unsigned long)stripsize);
+
+                        if (bytes_read < 0 && !ignore) {
+                                TIFFError("", "Error reading strip %lu after %lu rows",
+                                          (unsigned long) strip, (unsigned long)rows);
+                                return 0;
+                        }
+
+                        /* bounds check before advancing buffer pointer */
+                        if (bytes_read < 0) {
+                                /* handled above; defensive check */
+                                return 0;
+                        }
+                        {
+                                size_t dest_offset = (size_t)(bufp - buf);
+                                size_t copy_len = (size_t)bytes_read;
+                                if (dest_offset > buffsize || copy_len > buffsize - dest_offset) {
+                                        TIFFError("loadImage", "Strip/scanline would overflow read buffer");
+                                        return 0;
+                                }
+                        }
+
+                        bufp += bytes_read;
+                }
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
