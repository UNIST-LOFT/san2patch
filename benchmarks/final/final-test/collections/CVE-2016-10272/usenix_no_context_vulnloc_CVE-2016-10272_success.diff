diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..30c22fcd 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3685,20 +3685,69 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 return 0;
         }
 
-        for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
-                if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
+        /* Rationale:
+         * More defensive approach: perform overflow-safe computation of the
+         * total buffer size using size_t, detect integer overflow, and
+         * strictly reject reads that would exceed the remaining buffer.
+         */
+        {
+                size_t n = (size_t)nstrips;
+                size_t s = (size_t)stripsize;
+                size_t buffsize;
+
+                /* Check for multiplication overflow when computing total buffer size. */
+                if (s != 0 && n > ((size_t)-1) / s) {
+                        TIFFError("", "Integer overflow computing total buffer size");
                         return 0;
                 }
-                bufp += bytes_read;
+                buffsize = n * s;
+
+                for (strip = 0; strip < nstrips; strip++) {
+                        size_t used = (size_t)(bufp - buf);
+                        if (used >= buffsize) {
+                                TIFFError("", "No space left for strip %lu (used %zu, total %zu)",
+                                          (unsigned long)strip, used, buffsize);
+                                return 0;
+                        }
+                        size_t remaining = buffsize - used;
+
+                        /*
+                         * Clamp the requested read to the maximum representable
+                         * tsize_t value. TSIZE_MAX is not portable/available on
+                         * all platforms; SSIZE_MAX is commonly available and is
+                         * suitable as the maximum signed size for request.
+                         */
+                        tsize_t request = (tsize_t)(remaining > (size_t)SSIZE_MAX ? (size_t)SSIZE_MAX : remaining);
+
+                        bytes_read = (int32)TIFFReadEncodedStrip (in, strip, bufp, request);
+
+                        if (bytes_read < 0 && !ignore) {
+                                TIFFError("", "Error reading strip %lu after %lu rows",
+                                          (unsigned long) strip, (unsigned long)rows);
+                                return 0;
+                        }
+
+                        /* Only compute rows when bytes_read is non-negative */
+                        if (bytes_read >= 0)
+                                rows = bytes_read / scanline_size;
+
+                        if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+                                TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+                                          (int)strip + 1, (unsigned long) bytes_read,
+                                          (unsigned long)stripsize);
+
+                        /* If the decoder somehow returns more than we allowed,
+                         * treat it as an error and fail instead of silently
+                         * clamping, to avoid potential silent data corruption.
+                         */
+                        if (bytes_read > (int32)request) {
+                                TIFFError("", "Decoder returned %ld bytes which exceeds allowed %ld; aborting",
+                                          (long)bytes_read, (long)request);
+                                return 0;
+                        }
+
+                        bufp += bytes_read;
+                }
         }
 
         return 1;
@@ -6101,7 +6150,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if (input_photometric == PHOTOMETRIC_YCBCR)
       {
       TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
- 		           &subsampling_horiz, &subsampling_vert);
+ 		   &subsampling_horiz, &subsampling_vert);
       if (subsampling_horiz != 1 || subsampling_vert != 1)
         {
 	TIFFError("loadImage", 
@@ -6120,7 +6169,8 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash CWE-787: Out-of-bounds Write
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
   }
@@ -6149,10 +6199,47 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     return (-1);
     }
 
+  /* RATIONALE: Safer allocation strategy: always ensure the buffer is exactly sized to
+     buffsize + 3 guard bytes by attempting a reallocation when the buffer exists. This
+     avoids relying on prev_readsize being correct. If reallocation fails, we fail back
+     to an error to avoid any possible out-of-bounds writes. */
+  {
+    size_t needed = (size_t)buffsize + 3U;
+    if (buffsize > 0xFFFFFFFFU - 3)
+    {
+        TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+        free(read_buff);
+        return (-1);
+    }
+    /* If we have a buffer, attempt to resize it unconditionally to the required size. */
+    if (read_buff)
+    {
+        unsigned char *resized = (unsigned char *)_TIFFrealloc(read_buff, needed);
+        if (!resized)
+        {
+            TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+            free(read_buff);
+            return (-1);
+        }
+        read_buff = resized;
+    }
+    else
+    {
+        /* If no buffer, allocate one (this path may not be reached because of earlier logic). */
+        read_buff = (unsigned char *)_TIFFmalloc(needed);
+        if (!read_buff)
+        {
+            TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
+            return (-1);
+        }
+    }
+  }
+
   read_buff[buffsize] = 0;
   read_buff[buffsize+1] = 0;
   read_buff[buffsize+2] = 0;
 
+
   prev_readsize = buffsize;
   *read_ptr = read_buff;
 
