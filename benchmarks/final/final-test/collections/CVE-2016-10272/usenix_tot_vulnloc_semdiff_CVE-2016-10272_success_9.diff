diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index b87a77a8..9ee2f239 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -3672,6 +3672,12 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
+        /* Rationale: Prevent out-of-bounds writes by limiting the per-strip read to
+         * the nominal strip size. The original code passed -1 (unbounded) to
+         * TIFFReadEncodedStrip which allowed the library to write past the
+         * destination buffer when computed lengths were wrong. We pass a
+         * conservative maximum (stripsize) and validate the returned byte count
+         * before advancing the destination pointer. */
         uint8* bufp = buf;
         int32  bytes_read = 0;
         uint32 strip, nstrips   = TIFFNumberOfStrips(in);
@@ -3684,25 +3690,37 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 TIFFError("", "TIFF scanline size is zero!");    
                 return 0;
         }
-
+// FIXME: Crash CWE-122: Heap-based Buffer Overflow (CWE-787: Out-of-bounds Write)
+ 
         for (strip = 0; strip < nstrips; strip++) {
-                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
-                rows = bytes_read / scanline_size;
-                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
-
+                /* Limit the read to a single strip's nominal size to avoid
+                 * unbounded writes into bufp. */
+                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, (tsize_t)stripsize);
+                /* Validate the returned byte count before using it. */
                 if (bytes_read < 0 && !ignore) {
+                        rows = (scanline_size > 0) ? (0) : 0; /* rows not meaningful here */
                         TIFFError("", "Error reading strip %lu after %lu rows",
                                   (unsigned long) strip, (unsigned long)rows);
                         return 0;
                 }
+                if ((size_t)bytes_read > (size_t)stripsize) {
+                        TIFFError("", "Strip %d: read %lu bytes which exceeds buffer limit %lu",
+                                  (int)strip + 1, (unsigned long) bytes_read,
+                                  (unsigned long)stripsize);
+                        return 0;
+                }
+                rows = (scanline_size > 0) ? (bytes_read / scanline_size) : 0;
+                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
+                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
+                                  (int)strip + 1, (unsigned long) bytes_read,
+                                  (unsigned long)stripsize);
+
                 bufp += bytes_read;
         }
 
         return 1;
-} /* end readContigStripsIntoBuffer */
+}
+ /* end readContigStripsIntoBuffer */
 
 static int 
 combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
@@ -6117,12 +6135,25 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   /* outside buffer */
   if (!read_buff)
   {
+    /* Rationale: Ensure allocation succeeded and provide explicit zero-initialization of the
+       read buffer. Zeroing reduces risks from uninitialized memory and provides a clear
+       sentinel in the buffer. Also explicitly check the return of _TIFFmalloc to avoid
+       proceeding with a NULL pointer which could lead to later crashes. This is a
+       minimal change limited to allocation handling. */
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
-        return (-1);
+// FIXME: Crash CWE-122: Heap-based Buffer Overflow (CWE-787: Out-of-bounds Write)
+         return (-1);
     }
     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    if (!read_buff)
+    {
+        TIFFError("loadImage", "Out of memory allocating read buffer");
+        return (-1);
+    }
+    /* initialize the buffer to a known state */
+    memset(read_buff, 0, (size_t)(buffsize+3));
   }
   else
     {
@@ -6138,6 +6169,11 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
         {
 	free (read_buff);
         read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+	if (!read_buff)
+	{
+	    TIFFError("loadImage", "Out of memory allocating read buffer");
+	    return (-1);
+	}
         }
       else
         read_buff = new_buff;
