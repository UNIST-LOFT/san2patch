diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit 6b26660a01125acb394e39ac71635c8df4c110c4
+Subproject commit 6b26660a01125acb394e39ac71635c8df4c110c4-dirty
diff --git a/src/split.c b/src/split.c
index f9c99db43..38ee77c08 100644
--- a/src/split.c
+++ b/src/split.c
@@ -982,10 +982,41 @@ bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
   start = (k - 1) * (file_size / n);
   end = (k == n) ? file_size : k * (file_size / n);
 
-  if (initial_read != SIZE_MAX || start < initial_read)
+/* Rationale:
+   The original code computed (initial_read - start) and passed it
+   directly to memmove. Because initial_read is size_t and start is
+   signed (off_t), when start > initial_read the subtraction underflows
+   (or the signed/unsigned conversion yields a very large size_t), and
+   memmove is called with a huge length causing out-of-bounds writes
+   (CWE-681 -> CWE-787).
+
+   Fix: only perform the memmove when we actually have buffered data
+   (initial_read != SIZE_MAX) and the start offset is within the
+   buffered range (start < (off_t) initial_read). Validate that start
+   is non-negative and clamp the copy length to bufsize. Compute the
+   copy length in an unsigned type after those checks so there is no
+   negative-to-unsigned conversion. If there's nothing to copy, skip
+   memmove. This preserves functionality but prevents invalid sizes
+   being passed to memmove.
+*/
+   if (initial_read != SIZE_MAX && start >= 0 && start < (off_t) initial_read)
     {
-      memmove (buf, buf + start, initial_read - start);
-      initial_read -= start;
+      /* Safe: start >= 0 and start < (off_t) initial_read ensures
+         initial_read - (size_t)start does not underflow. Clamp to
+         bufsize to protect destination buffer. */
+      size_t copy_len = initial_read - (size_t) start;
+      if (copy_len > bufsize)
+        copy_len = bufsize;
+      if (copy_len > 0)
+        {
+          memmove (buf, buf + start, copy_len);
+          initial_read = copy_len;
+        }
+      else
+        {
+          /* Nothing to copy. Normalize initial_read. */
+          initial_read = 0;
+        }
     }
   else
     {
