diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit 6b26660a01125acb394e39ac71635c8df4c110c4
+Subproject commit 6b26660a01125acb394e39ac71635c8df4c110c4-dirty
diff --git a/src/split.c b/src/split.c
index f9c99db43..ac67d96ff 100644
--- a/src/split.c
+++ b/src/split.c
@@ -982,10 +982,34 @@ bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
   start = (k - 1) * (file_size / n);
   end = (k == n) ? file_size : k * (file_size / n);
 
-  if (initial_read != SIZE_MAX || start < initial_read)
+  /* Rationale:
+     Avoid implicit signed-to-unsigned conversion by validating indices first.
+     If there is data in buf (initial_read != SIZE_MAX) and start points into that
+     data, compute the positive length safely and clamp to bufsize if necessary.
+     Clamping avoids overflow while preserving as much behavior as possible.
+  */
+  if (initial_read != SIZE_MAX && start >= 0 && (size_t) start < initial_read)
     {
-      memmove (buf, buf + start, initial_read - start);
-      initial_read -= start;
+      ssize_t len = (ssize_t) initial_read - (ssize_t) start;
+      if (len <= 0)
+        {
+          /* nothing to copy */
+          initial_read = 0;
+        }
+      else
+        {
+          /* copy at most bufsize bytes to remain safe */
+          size_t to_copy = (size_t) len;
+          if (to_copy > bufsize)
+            to_copy = bufsize;
+          memmove (buf, buf + start, to_copy);
+          /* Adjust initial_read to reflect bytes remaining in buffer after consuming start. */
+          if ((size_t) len >= to_copy)
+            /* If we clipped to bufsize, keep remaining as clipped value to stay consistent. */
+            initial_read = to_copy;
+          else
+            initial_read = (size_t) len;
+        }
     }
   else
     {
@@ -1018,6 +1042,7 @@ bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
     }
 }
 
+
 typedef struct of_info
 {
   char *of_name;
