diff --git a/gnulib b/gnulib
--- a/gnulib
+++ b/gnulib
@@ -1 +1 @@
-Subproject commit 6b26660a01125acb394e39ac71635c8df4c110c4
+Subproject commit 6b26660a01125acb394e39ac71635c8df4c110c4-dirty
diff --git a/src/split.c b/src/split.c
index f9c99db43..67c5cf5ef 100644
--- a/src/split.c
+++ b/src/split.c
@@ -982,10 +982,39 @@ bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
   start = (k - 1) * (file_size / n);
   end = (k == n) ? file_size : k * (file_size / n);
 
-  if (initial_read != SIZE_MAX || start < initial_read)
+// Rationale: compute differences using signed type and validate before calling memmove.
+// The original code used a condition that could allow a negative-length (after
+// signed-to-unsigned conversion) to be passed to memmove.  Fix: only perform
+// memmove when initial_read is valid and start < initial_read and start is
+// within the buffer capacity.  Compute the copy length in a signed type
+// (ptrdiff_t) and check it's positive before casting to size_t.
+   if (initial_read != SIZE_MAX && start >= 0 && (off_t) initial_read > start)
     {
-      memmove (buf, buf + start, initial_read - start);
-      initial_read -= start;
+      ptrdiff_t diff = (ptrdiff_t) initial_read - (ptrdiff_t) start;
+      if (diff > 0)
+        {
+          size_t to_copy = (size_t) diff;
+          /* Never copy more than the buffer can hold.  */
+          if (to_copy > bufsize)
+            to_copy = bufsize;
+          /* Ensure source pointer is within buf before memmove. */
+          if ((size_t) start < bufsize)
+            memmove (buf, buf + (size_t) start, to_copy);
+          else
+            {
+              /* Source offset is outside the buffer; fall back to seeking. */
+              if (lseek (STDIN_FILENO, start, SEEK_CUR) < 0)
+                die (EXIT_FAILURE, errno, "%s", quotef (infile));
+              initial_read = SIZE_MAX;
+              goto read_loop_start;
+            }
+          initial_read -= (size_t) start;
+        }
+      else
+        {
+          /* No bytes to move; nothing to do. */
+          initial_read = 0;
+        }
     }
   else
     {
@@ -994,6 +1023,7 @@ bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
       initial_read = SIZE_MAX;
     }
 
+read_loop_start:
   while (start < end)
     {
       size_t n_read;
@@ -1015,6 +1045,7 @@ bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
           && ! ignorable (errno))
         die (EXIT_FAILURE, errno, "%s", quotef ("-"));
       start += n_read;
+
     }
 }
 
@@ -1548,7 +1579,8 @@ main (int argc, char **argv)
 
   /* Open the input file.  */
   if (! STREQ (infile, "-")
-      && fd_reopen (STDIN_FILENO, infile, O_RDONLY, 0) < 0)
+// FIXME: Crash CWE-787: Out-of-bounds Write
+       && fd_reopen (STDIN_FILENO, infile, O_RDONLY, 0) < 0)
     die (EXIT_FAILURE, errno, _("cannot open %s for reading"),
          quoteaf (infile));
 
@@ -1569,6 +1601,21 @@ main (int argc, char **argv)
   char *buf = ptr_align (b, page_size);
   size_t initial_read = SIZE_MAX;
 
+  /* Rationale: Ensure that the aligned buffer is within the allocated
+     block and that initial_read has a safe default. Failing fast here
+     avoids later signed/unsigned conversions producing very large
+     lengths passed to memmove and prevents out-of-bounds writes. */
+  if (buf < (char *) b || buf > (char *) b + (in_blk_size + 1 + page_size - 1))
+    die (EXIT_FAILURE, 0, _("buffer alignment failure"));
+
+  if (initial_read == SIZE_MAX)
+    {
+      /* Use zero as a safe default; callers later should set initial_read
+         based on file contents. This avoids negative-length arithmetic
+         becoming large unsigned values. */
+      initial_read = 0;
+    }
+
   if (split_type == type_chunk_bytes || split_type == type_chunk_lines)
     {
       file_size = input_file_size (STDIN_FILENO, &in_stat_buf,
@@ -1581,6 +1628,7 @@ main (int argc, char **argv)
       if (OFF_T_MAX < n_units)
         {
           char buffer[INT_BUFSIZE_BOUND (uintmax_t)];
+
           die (EXIT_FAILURE, EOVERFLOW, "%s: %s",
                _("invalid number of chunks"),
                quote (umaxtostr (n_units, buffer)));
