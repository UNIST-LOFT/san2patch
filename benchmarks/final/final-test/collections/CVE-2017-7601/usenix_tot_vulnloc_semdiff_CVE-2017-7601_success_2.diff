diff --git a/libtiff/tif_jpeg.c b/libtiff/tif_jpeg.c
index 6c17c388..a6153a96 100644
--- a/libtiff/tif_jpeg.c
+++ b/libtiff/tif_jpeg.c
@@ -1624,37 +1624,50 @@ JPEGSetupEncode(TIFF* tif)
 	/* Set per-file parameters */
 	switch (sp->photometric) {
 	case PHOTOMETRIC_YCBCR:
-		sp->h_sampling = td->td_ycbcrsubsampling[0];
-		sp->v_sampling = td->td_ycbcrsubsampling[1];
-                if( sp->h_sampling == 0 || sp->v_sampling == 0 )
-                {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                            "Invalig horizontal/vertical sampling value");
-                    return (0);
-                }
+	sp->h_sampling = td->td_ycbcrsubsampling[0];
+	sp->v_sampling = td->td_ycbcrsubsampling[1];
+	if( sp->h_sampling == 0 || sp->v_sampling == 0 )
+	{
+		TIFFErrorExt(tif->tif_clientdata, module,
+			"Invalig horizontal/vertical sampling value");
+		// FIXME: Crash CWE-190: Integer Overflow or Wraparound
+		 return (0);
+	}
 
-		/*
-		 * A ReferenceBlackWhite field *must* be present since the
-		 * default value is inappropriate for YCbCr.  Fill in the
-		 * proper value if application didn't set it.
-		 */
-		{
-			float *ref;
-			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
-				float refbw[6];
-				long top = 1L << td->td_bitspersample;
-				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
-				refbw[3] = refbw[1];
-				refbw[4] = refbw[2];
-				refbw[5] = refbw[1];
-				TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					     refbw);
+	/*
+	 * A ReferenceBlackWhite field *must* be present since the
+	 * default value is inappropriate for YCbCr.  Fill in the
+	 * proper value if application didn't set it.
+	 */
+	{
+		float *ref;
+		if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
+		      &ref)) {
+			float refbw[6];
+			/* Validate td_bitspersample to avoid undefined behavior from
+			   shifting by an out-of-range amount (CWE-190). Use a
+			   portable constant (8 bits/char) instead of CHAR_BIT to
+			   avoid dependency on CHAR_BIT being defined in this
+			   compilation unit. */
+			if (td->td_bitspersample < 0 ||
+			    td->td_bitspersample >= (int)(sizeof(long) * 8)) {
+				TIFFErrorExt(tif->tif_clientdata, module,
+					"Invalid BitsPerSample value (%d) in TIFF; exceeds supported range",
+					td->td_bitspersample);
+				return (0);
 			}
+			long top = 1L << td->td_bitspersample;
+			refbw[0] = 0;
+			refbw[1] = (float)(top-1L);
+			refbw[2] = (float)(top>>1);
+			refbw[3] = refbw[1];
+			refbw[4] = refbw[2];
+			refbw[5] = refbw[1];
+			TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
+				 refbw);
 		}
-		break;
+	}
+	break;
 	case PHOTOMETRIC_PALETTE:		/* disallowed by Tech Note */
 	case PHOTOMETRIC_MASK:
 		TIFFErrorExt(tif->tif_clientdata, module,
