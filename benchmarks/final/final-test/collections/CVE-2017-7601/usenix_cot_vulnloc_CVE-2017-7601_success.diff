diff --git a/libtiff/tif_jpeg.c b/libtiff/tif_jpeg.c
index 6c17c388..b5138289 100644
--- a/libtiff/tif_jpeg.c
+++ b/libtiff/tif_jpeg.c
@@ -1641,15 +1641,38 @@ JPEGSetupEncode(TIFF* tif)
 		{
 			float *ref;
 			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
+// FIXME: Crash CWE-190: Integer Overflow or Wraparound
+  						  &ref)) {
 				float refbw[6];
-				long top = 1L << td->td_bitspersample;
-				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
-				refbw[3] = refbw[1];
-				refbw[4] = refbw[2];
-				refbw[5] = refbw[1];
+				/*
+				 * Rationale for modification:
+				 * The original code computed "top = 1L << td->td_bitspersample" without
+				 * validating td->td_bitspersample. If td->td_bitspersample is greater
+				 * than or equal to the bit width of 'long' (or negative), the left-shift
+				 * is undefined (CWE-190) and can trigger sanitizer errors or crashes.
+				 *
+				 * Fix: validate the bit count before performing the shift. If the
+				 * value is out-of-range, report an error and fail the setup instead of
+				 * performing an invalid shift. This avoids undefined behavior while
+				 * preserving existing behavior for valid inputs.
+				 */
+				{
+					int bits = td->td_bitspersample;
+					/* Accept only positive bit counts that fit in a 'long' shift */
+					if (bits <= 0 || bits >= (int)(sizeof(long) * 8)) {
+						TIFFErrorExt(tif->tif_clientdata, module,
+							"Invalid BitsPerSample value (%d) for JPEG encoding", bits);
+						return (0);
+					}
+
+					long top = 1L << bits;
+					refbw[0] = 0;
+					refbw[1] = (float)(top-1L);
+					refbw[2] = (float)(top>>1);
+					refbw[3] = refbw[1];
+					refbw[4] = refbw[2];
+					refbw[5] = refbw[1];
+				}
 				TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
 					     refbw);
 			}
@@ -1674,6 +1697,7 @@ JPEGSetupEncode(TIFF* tif)
 	 * This would need work if libtiff ever supports different
 	 * depths for different components, or if libjpeg ever supports
 	 * run-time selection of depth.  Neither is imminent.
+
 	 */
 #ifdef JPEG_LIB_MK1
         /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */
diff --git a/libtiff/tif_write.c b/libtiff/tif_write.c
index 045a79d0..f4974b04 100644
--- a/libtiff/tif_write.c
+++ b/libtiff/tif_write.c
@@ -229,7 +229,29 @@ TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
                 return ((tmsize_t) -1);
         }
 
-	tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;
+// FIXME: Crash CWE-190: Integer Overflow or Wraparound
+/* Rationale:
+   The original computation for tif->tif_row computed (strip % td->td_stripsperimage) *
+   td->td_rowsperstrip using the native integer types. If the multiplication overflows
+   the destination type or later leads to out-of-range values used for bit shifts,
+   undefined behavior (CWE-190) can occur. To prevent this, compute the product in a
+   sufficiently wide unsigned integer (unsigned long long) and clamp the result to a
+   safe bound: it must not exceed the image length (td->td_imagelength). Finally,
+   cast back to tif->tif_row's storage type. This avoids integer overflow/wraparound
+   and ensures subsequent code sees a valid, bounded row value.
+*/
+{
+    unsigned long long rowsper = (unsigned long long)td->td_rowsperstrip;
+    unsigned long long stripidx = (unsigned long long)(strip % td->td_stripsperimage);
+    unsigned long long prod = stripidx * rowsper;
+
+    /* Clamp to image length to avoid producing an out-of-range row value. */
+    if (prod > (unsigned long long)td->td_imagelength)
+        prod = (unsigned long long)td->td_imagelength;
+
+    /* Finally, store into tif->tif_row using the expected type. */
+    tif->tif_row = (tmsize_t)prod;
+}
 	if ((tif->tif_flags & TIFF_CODERSETUP) == 0) {
 		if (!(*tif->tif_setupencode)(tif))
 			return ((tmsize_t) -1);
@@ -262,6 +284,7 @@ TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)
     /* shortcut to avoid an extra memcpy() */
     if( td->td_compression == COMPRESSION_NONE )
     {
+
         /* swab if needed - note that source buffer will be altered */
         tif->tif_postdecode( tif, (uint8*) data, cc );
 
