diff --git a/libtiff/tif_jpeg.c b/libtiff/tif_jpeg.c
index 6c17c388..d6eeb945 100644
--- a/libtiff/tif_jpeg.c
+++ b/libtiff/tif_jpeg.c
@@ -1641,12 +1641,42 @@ JPEGSetupEncode(TIFF* tif)
 		{
 			float *ref;
 			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
+// FIXME: Crash
+  					  &ref)) {
 				float refbw[6];
-				long top = 1L << td->td_bitspersample;
-				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
+				/* Rationale:
+				 * The original code used a left shift on a signed long:
+				 *   long top = 1L << td->td_bitspersample;
+				 * which is undefined behavior when td->td_bitspersample is
+				 * greater than or equal to the number of bits in long. The
+				 * sanitizer reported a shift exponent too large for 64-bit
+				 * type. To avoid UB we validate the bit count and compute
+				 * the reference values without performing an invalid shift.
+				 */
+				int bps = td->td_bitspersample;
+				if (bps <= 0) {
+					TIFFErrorExt(tif->tif_clientdata, module,
+					             "Invalid BitsPerSample value %d", bps);
+					return (0);
+				}
+				if (bps < (int)(sizeof(unsigned long) * 8)) {
+					unsigned long top = 1UL << bps;
+					refbw[0] = 0;
+					refbw[1] = (float)(top-1UL);
+					refbw[2] = (float)(top>>1);
+				} else {
+					/* For very large bit depths compute using floating point
+					 * so we never perform an out-of-range integer shift. The
+					 * resulting reference values are stored as floats anyway.
+					 */
+					double topd = 1.0;
+					int i;
+					for (i = 0; i < bps; i++)
+						topd *= 2.0;
+					refbw[0] = 0;
+					refbw[1] = (float)(topd - 1.0);
+					refbw[2] = (float)(topd / 2.0);
+				}
 				refbw[3] = refbw[1];
 				refbw[4] = refbw[2];
 				refbw[5] = refbw[1];
@@ -1674,6 +1704,7 @@ JPEGSetupEncode(TIFF* tif)
 	 * This would need work if libtiff ever supports different
 	 * depths for different components, or if libjpeg ever supports
 	 * run-time selection of depth.  Neither is imminent.
+
 	 */
 #ifdef JPEG_LIB_MK1
         /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */
