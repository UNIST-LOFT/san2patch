diff --git a/libtiff/tif_jpeg.c b/libtiff/tif_jpeg.c
index 6c17c388..41b8feab 100644
--- a/libtiff/tif_jpeg.c
+++ b/libtiff/tif_jpeg.c
@@ -1630,7 +1630,8 @@ JPEGSetupEncode(TIFF* tif)
                 {
                     TIFFErrorExt(tif->tif_clientdata, module,
                             "Invalig horizontal/vertical sampling value");
-                    return (0);
+// FIXME: Crash CWE-190: Integer Overflow or Wraparound
+                     return (0);
                 }
 
 		/*
@@ -1641,17 +1642,31 @@ JPEGSetupEncode(TIFF* tif)
 		{
 			float *ref;
 			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
+				  &ref)) {
 				float refbw[6];
-				long top = 1L << td->td_bitspersample;
+				/*
+				 * Rationale: Validate td->td_bitspersample before using it
+				 * as a shift count. Shifting by a count >= width of the
+				 * left operand is undefined. We enforce a safe maximum based
+				 * on the width of unsigned long long (typically 64 bits),
+				 * log and fail (return 0) for out-of-range values.
+				 */
+				int bits = td->td_bitspersample;
+				int maxbits = 8 * (int)sizeof(unsigned long long);
+				if (bits < 0 || bits >= maxbits) {
+					TIFFErrorExt(tif->tif_clientdata, module,
+						"Invalid BitsPerSample value (%d)", bits);
+					return (0);
+				}
+				unsigned long long top = 1ULL << bits;
 				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
+				refbw[1] = (float)(top - 1ULL);
+				refbw[2] = (float)(top >> 1);
 				refbw[3] = refbw[1];
 				refbw[4] = refbw[2];
 				refbw[5] = refbw[1];
 				TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					     refbw);
+					 refbw);
 			}
 		}
 		break;
