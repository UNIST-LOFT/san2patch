diff --git a/libtiff/tif_jpeg.c b/libtiff/tif_jpeg.c
index 6c17c388..c1c1ffd8 100644
--- a/libtiff/tif_jpeg.c
+++ b/libtiff/tif_jpeg.c
@@ -1624,37 +1624,47 @@ JPEGSetupEncode(TIFF* tif)
 	/* Set per-file parameters */
 	switch (sp->photometric) {
 	case PHOTOMETRIC_YCBCR:
-		sp->h_sampling = td->td_ycbcrsubsampling[0];
-		sp->v_sampling = td->td_ycbcrsubsampling[1];
-                if( sp->h_sampling == 0 || sp->v_sampling == 0 )
-                {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                            "Invalig horizontal/vertical sampling value");
-                    return (0);
-                }
+	sp->h_sampling = td->td_ycbcrsubsampling[0];
+	sp->v_sampling = td->td_ycbcrsubsampling[1];
+	if (sp->h_sampling == 0 || sp->v_sampling == 0) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+			"Invalig horizontal/vertical sampling value");
+		return (0);
+	}
 
-		/*
-		 * A ReferenceBlackWhite field *must* be present since the
-		 * default value is inappropriate for YCbCr.  Fill in the
-		 * proper value if application didn't set it.
-		 */
-		{
-			float *ref;
-			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
-				float refbw[6];
-				long top = 1L << td->td_bitspersample;
-				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
-				refbw[3] = refbw[1];
-				refbw[4] = refbw[2];
-				refbw[5] = refbw[1];
-				TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					     refbw);
+	/*
+	 * A ReferenceBlackWhite field *must* be present since the
+	 * default value is inappropriate for YCbCr.  Fill in the
+	 * proper value if application didn't set it.
+	 */
+	{
+		float *ref;
+		if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE, &ref)) {
+			float refbw[6];
+			/* Validate bits-per-sample to avoid undefined shifts */
+			int bits = td->td_bitspersample;
+			if (bits <= 0) {
+				TIFFErrorExt(tif->tif_clientdata, module,
+					"invalid BitsPerSample=%d; using default 8", bits);
+				bits = 8;
+			}
+			unsigned int max_shift = (unsigned int)(sizeof(unsigned long) * 8U - 1U);
+			if ((unsigned int)bits > max_shift) {
+				TIFFErrorExt(tif->tif_clientdata, module,
+					"BitsPerSample (%d) too large; clamped to %u", bits, max_shift);
+				bits = (int)max_shift;
 			}
+			unsigned long top = 1UL << (unsigned int)bits;
+			refbw[0] = 0;
+			refbw[1] = (float)(top - 1UL);
+			refbw[2] = (float)(top >> 1);
+			refbw[3] = refbw[1];
+			refbw[4] = refbw[2];
+			refbw[5] = refbw[1];
+			TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refbw);
 		}
-		break;
+	}
+	break;
 	case PHOTOMETRIC_PALETTE:		/* disallowed by Tech Note */
 	case PHOTOMETRIC_MASK:
 		TIFFErrorExt(tif->tif_clientdata, module,
