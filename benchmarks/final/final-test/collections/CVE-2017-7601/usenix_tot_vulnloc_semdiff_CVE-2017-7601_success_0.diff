diff --git a/libtiff/tif_jpeg.c b/libtiff/tif_jpeg.c
index 6c17c388..48894bea 100644
--- a/libtiff/tif_jpeg.c
+++ b/libtiff/tif_jpeg.c
@@ -1624,37 +1624,40 @@ JPEGSetupEncode(TIFF* tif)
 	/* Set per-file parameters */
 	switch (sp->photometric) {
 	case PHOTOMETRIC_YCBCR:
-		sp->h_sampling = td->td_ycbcrsubsampling[0];
-		sp->v_sampling = td->td_ycbcrsubsampling[1];
-                if( sp->h_sampling == 0 || sp->v_sampling == 0 )
-                {
-                    TIFFErrorExt(tif->tif_clientdata, module,
-                            "Invalig horizontal/vertical sampling value");
-                    return (0);
-                }
+	sp->h_sampling = td->td_ycbcrsubsampling[0];
+	sp->v_sampling = td->td_ycbcrsubsampling[1];
+	if (sp->h_sampling == 0 || sp->v_sampling == 0) {
+		TIFFErrorExt(tif->tif_clientdata, module,
+			"Invalid horizontal/vertical sampling value");
+		return (0);
+	}
 
-		/*
-		 * A ReferenceBlackWhite field *must* be present since the
-		 * default value is inappropriate for YCbCr.  Fill in the
-		 * proper value if application didn't set it.
-		 */
-		{
-			float *ref;
-			if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					  &ref)) {
-				float refbw[6];
-				long top = 1L << td->td_bitspersample;
-				refbw[0] = 0;
-				refbw[1] = (float)(top-1L);
-				refbw[2] = (float)(top>>1);
-				refbw[3] = refbw[1];
-				refbw[4] = refbw[2];
-				refbw[5] = refbw[1];
-				TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,
-					     refbw);
+	{
+		float *ref;
+		if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE, &ref)) {
+			float refbw[6];
+			/* Rationale: Validate td_bitspersample before using it as a shift
+			   exponent to avoid undefined behaviour (shift >= width of type).
+			   Prefer to reject malformed metadata rather than perform an
+			   out-of-range shift. */
+			if (td->td_bitspersample <= 0 ||
+			    td->td_bitspersample >= (int)(8 * sizeof(long))) {
+				TIFFErrorExt(tif->tif_clientdata, module,
+					"Corrupt TIFF: BitsPerSample (%d) out of range",
+					td->td_bitspersample);
+				return (0);
 			}
+			unsigned long top = 1UL << td->td_bitspersample;
+			refbw[0] = 0;
+			refbw[1] = (float)(top - 1UL);
+			refbw[2] = (float)(top >> 1);
+			refbw[3] = refbw[1];
+			refbw[4] = refbw[2];
+			refbw[5] = refbw[1];
+			TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refbw);
 		}
-		break;
+	}
+	break;
 	case PHOTOMETRIC_PALETTE:		/* disallowed by Tech Note */
 	case PHOTOMETRIC_MASK:
 		TIFFErrorExt(tif->tif_clientdata, module,
