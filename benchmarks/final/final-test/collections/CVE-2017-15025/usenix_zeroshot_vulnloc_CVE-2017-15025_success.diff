diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 89a3f9b1830..a1762a0604d 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -2419,7 +2419,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 		/* The file and directory tables are 0
 		   based, the references are 1 based.  */
 		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+				      FALSE, line_end);
 		line_ptr += bytes_read;
 		if (filename)
 		  free (filename);
@@ -2428,7 +2428,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	      }
 	    case DW_LNS_set_column:
 	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+				      FALSE, line_end);
 	      line_ptr += bytes_read;
 	      break;
 	    case DW_LNS_negate_stmt:
@@ -2437,17 +2437,36 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	    case DW_LNS_set_basic_block:
 	      break;
 	    case DW_LNS_const_add_pc:
-	      if (lh.maximum_ops_per_insn == 1)
-		address += (lh.minimum_instruction_length
-			    * ((255 - lh.opcode_base) / lh.line_range));
-	      else
-		{
-		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
-		  address += (lh.minimum_instruction_length
-			      * ((op_index + adjust)
-				 / lh.maximum_ops_per_insn));
-		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
-		}
+/* Rationale:
+   Fix a floating-point exception (division by zero) observed in
+   decode_line_info when either lh.line_range == 0 or
+   lh.maximum_ops_per_insn == 0 (or lh.opcode_base >= 255 causing
+   an underflow). Guard the divisions by checking these fields and
+   treating the adjustment as 0 when a division would be unsafe.
+   Preserve the original behavior when values are valid. */
+	      {
+		bfd_vma adjust = 0;
+
+		/* Only compute adjust when it is safe to divide.  This avoids
+		   a potential divide-by-zero (which manifests as an FPE). Also
+		   avoid underflow when opcode_base >= 255. */
+		if (lh.line_range != 0 && lh.opcode_base < 255)
+		  adjust = ((255 - lh.opcode_base) / lh.line_range);
+
+		if (lh.maximum_ops_per_insn <= 1)
+		  {
+		    /* For single-op insns, add the whole adjustment. */
+		    address += (lh.minimum_instruction_length * adjust);
+		    op_index = 0;
+		  }
+		else
+		  {
+		    /* For multi-op insns, distribute the adjustment across ops. */
+		    address += (lh.minimum_instruction_length
+				  * ((op_index + adjust) / lh.maximum_ops_per_insn));
+		    op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
+		  }
+	      }
 	      break;
 	    case DW_LNS_fixed_advance_pc:
 	      address += read_2_bytes (abfd, line_ptr, line_end);
@@ -2459,7 +2478,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
 		{
 		  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-						FALSE, line_end);
+					FALSE, line_end);
 		  line_ptr += bytes_read;
 		}
 	      break;
@@ -2470,6 +2489,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	free (filename);
     }
 
+
   if (sort_line_sequences (table))
     return table;
 
