diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 89a3f9b1830..60e98b7ae0d 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -2419,7 +2419,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 		/* The file and directory tables are 0
 		   based, the references are 1 based.  */
 		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+				      FALSE, line_end);
 		line_ptr += bytes_read;
 		if (filename)
 		  free (filename);
@@ -2428,7 +2428,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	      }
 	    case DW_LNS_set_column:
 	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+				      FALSE, line_end);
 	      line_ptr += bytes_read;
 	      break;
 	    case DW_LNS_negate_stmt:
@@ -2437,16 +2437,46 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	    case DW_LNS_set_basic_block:
 	      break;
 	    case DW_LNS_const_add_pc:
+// FIXME: Crash CWE-369: Divide By Zero
+	      /*
+		Fix rationale:
+		The original code performed divisions and modulo operations using
+		values read from the DWARF line header (lh.line_range and
+		lh.maximum_ops_per_insn) without validating they were non-zero.
+		A zero value leads to divide-by-zero (SIGFPE). To avoid this,
+		validate divisors before using them. If a divisor is zero (which
+		indicates malformed DWARF data), avoid performing the arithmetic
+		and take a safe fallback (no address change and reset op_index)
+		so the parser does not crash and fails gracefully.
+	      */
 	      if (lh.maximum_ops_per_insn == 1)
-		address += (lh.minimum_instruction_length
-			    * ((255 - lh.opcode_base) / lh.line_range));
+		{
+		  if (lh.line_range != 0)
+		    address += (lh.minimum_instruction_length
+				* ((255 - lh.opcode_base) / lh.line_range));
+		  else
+		    {
+		      /* Malformed header: line_range == 0. Skip adjustment to avoid divide-by-zero. */
+		    }
+		}
 	      else
 		{
-		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
-		  address += (lh.minimum_instruction_length
-			      * ((op_index + adjust)
-				 / lh.maximum_ops_per_insn));
-		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
+		  /* Ensure we do not divide or modulo by zero. */
+		  if (lh.line_range == 0 || lh.maximum_ops_per_insn == 0)
+		    {
+		      /* Malformed header: avoid divide/modulo by zero. Use safe no-op behavior. */
+		      bfd_vma adjust = 0;
+		      /* No change to address since adjust is zero. */
+		      op_index = 0;
+		    }
+		  else
+		    {
+		      bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
+		      address += (lh.minimum_instruction_length
+				  * ((op_index + adjust)
+			     / lh.maximum_ops_per_insn));
+		      op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
+		    }
 		}
 	      break;
 	    case DW_LNS_fixed_advance_pc:
@@ -2459,7 +2489,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
 		{
 		  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-						FALSE, line_end);
+					FALSE, line_end);
 		  line_ptr += bytes_read;
 		}
 	      break;
@@ -3607,6 +3637,44 @@ comp_unit_maybe_decode_line_info (struct comp_unit *unit,
 	  return FALSE;
 	}
 
+      /*
+       * Rationale for change:
+       * The DWARF line-program decoder (decode_line_info) parses
+       * data from unit->stmtlist and may perform divisions/modulo
+       * operations using values derived from that input. A malformed
+       * or truncated stmtlist can lead to division by zero inside
+       * decode_line_info. To mitigate this, perform conservative
+       * validation of the stmtlist pointer and available data before
+       * invoking the decoder. If the stmtlist appears malformed or
+       * too small, fail gracefully instead of attempting to decode.
+       *
+       * The checks below are intentionally simple bounds checks that
+       * do not depend on additional structure fields. They ensure
+       * that stmtlist points inside the unit data and that at least
+       * a minimal number of bytes are present before calling the
+       * decoder. This prevents obvious out-of-bounds and zero-length
+       * inputs that are a common cause of divide-by-zero in the
+       * decoder.
+       */
+
+      /* Ensure stmtlist looks like a pointer into the unit's data. */
+      if (unit->stmtlist >= unit->end_ptr)
+	{
+	  unit->error = 1;
+	  return FALSE;
+	}
+
+      /* Require at least one byte of stmtlist data to avoid passing
+         empty/truncated data to the decoder. The decoder expects to
+         be able to read initial header/opcodes; if there's no data,
+         decoding could misinterpret values and cause divide-by-zero.
+      */
+      if (unit->stmtlist + 1 >= unit->end_ptr)
+	{
+	  unit->error = 1;
+	  return FALSE;
+	}
+
       unit->line_table = decode_line_info (unit, stash);
 
       if (! unit->line_table)
