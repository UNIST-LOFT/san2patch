diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 89a3f9b1830..9b36911e9c4 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -2427,16 +2427,25 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 		break;
 	      }
 	    case DW_LNS_set_column:
-	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
-	      line_ptr += bytes_read;
-	      break;
-	    case DW_LNS_negate_stmt:
-	      is_stmt = (!is_stmt);
-	      break;
-	    case DW_LNS_set_basic_block:
-	      break;
-	    case DW_LNS_const_add_pc:
+      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
+                                              FALSE, line_end);
+      line_ptr += bytes_read;
+      break;
+    case DW_LNS_negate_stmt:
+      is_stmt = (!is_stmt);
+      break;
+    case DW_LNS_set_basic_block:
+// FIXME: Crash CWE-369: Divide By Zero
+ 	      break;
+    case DW_LNS_const_add_pc:
+	      /* Rationale: Validate header-derived divisors to avoid division/modulo by zero
+		   when parsing malformed DWARF data. If a divisor is zero, skip this opcode
+		   to fail gracefully rather than performing an unsafe division. */
+	      if (lh.line_range == 0 || lh.maximum_ops_per_insn == 0)
+		{
+		  /* Malformed header: skip to avoid SIGFPE. */
+		  break;
+		}
 	      if (lh.maximum_ops_per_insn == 1)
 		address += (lh.minimum_instruction_length
 			    * ((255 - lh.opcode_base) / lh.line_range));
