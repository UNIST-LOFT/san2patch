diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 89a3f9b1830..68852fdf742 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -2427,27 +2427,46 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 		break;
 	      }
 	    case DW_LNS_set_column:
-	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
-	      line_ptr += bytes_read;
-	      break;
-	    case DW_LNS_negate_stmt:
-	      is_stmt = (!is_stmt);
-	      break;
-	    case DW_LNS_set_basic_block:
-	      break;
-	    case DW_LNS_const_add_pc:
-	      if (lh.maximum_ops_per_insn == 1)
-		address += (lh.minimum_instruction_length
-			    * ((255 - lh.opcode_base) / lh.line_range));
-	      else
-		{
-		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
-		  address += (lh.minimum_instruction_length
-			      * ((op_index + adjust)
-				 / lh.maximum_ops_per_insn));
-		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
-		}
+      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
+                      FALSE, line_end);
+      line_ptr += bytes_read;
+      break;
+    case DW_LNS_negate_stmt:
+      is_stmt = (!is_stmt);
+      break;
+    case DW_LNS_set_basic_block:
+      /* No action required for basic block marker. */
+      break;
+    case DW_LNS_const_add_pc:
+      /* Rationale: Validate header fields that are used as divisors.
+         If lh.maximum_ops_per_insn == 1 we must ensure lh.line_range != 0
+         to avoid a division by zero. If lh.maximum_ops_per_insn == 0 treat
+         the header as malformed and abort decoding of this unit. */
+      if (lh.maximum_ops_per_insn == 1)
+        {
+          if (lh.line_range == 0)
+            {
+              /* Header is malformed: cannot proceed. Return failure to
+                 the caller instead of jumping to a non-existent label. */
+              return FALSE;
+            }
+          address += (lh.minimum_instruction_length
+                      * ((255 - lh.opcode_base) / lh.line_range));
+        }
+      else
+        {
+          if (lh.maximum_ops_per_insn == 0)
+            {
+              /* Header is malformed: cannot proceed. Return failure to
+                 the caller instead of jumping to a non-existent label. */
+              return FALSE;
+            }
+          bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
+          address += (lh.minimum_instruction_length
+                      * ((op_index + adjust)
+                         / lh.maximum_ops_per_insn));
+          op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
+        }
 	      break;
 	    case DW_LNS_fixed_advance_pc:
 	      address += read_2_bytes (abfd, line_ptr, line_end);
