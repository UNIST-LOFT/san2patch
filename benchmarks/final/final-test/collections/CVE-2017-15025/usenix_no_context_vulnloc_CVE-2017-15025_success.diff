diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 89a3f9b1830..0c380877521 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -2419,7 +2419,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 		/* The file and directory tables are 0
 		   based, the references are 1 based.  */
 		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+				      FALSE, line_end);
 		line_ptr += bytes_read;
 		if (filename)
 		  free (filename);
@@ -2428,7 +2428,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	      }
 	    case DW_LNS_set_column:
 	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-					      FALSE, line_end);
+				      FALSE, line_end);
 	      line_ptr += bytes_read;
 	      break;
 	    case DW_LNS_negate_stmt:
@@ -2437,12 +2437,27 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	    case DW_LNS_set_basic_block:
 	      break;
 	    case DW_LNS_const_add_pc:
+// FIXME: Crash CWE-369: Divide By Zero
+	      /* Rationale: Prevent divide/modulo by zero when parsing untrusted
+		   DWARF data. Validate denominators and other header fields that
+		   participate in arithmetic. If the fields are invalid or zero,
+		   skip this opcode handling to avoid an FPE. */
+	      if (lh.line_range == 0
+		  || lh.minimum_instruction_length == 0
+		  || lh.opcode_base == 0
+		  || lh.opcode_base > 255)
+		/* Malformed header; skip this opcode to avoid divide-by-zero. */
+		break;
 	      if (lh.maximum_ops_per_insn == 1)
 		address += (lh.minimum_instruction_length
 			    * ((255 - lh.opcode_base) / lh.line_range));
 	      else
 		{
 		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
+		  /* Additional guard: if maximum_ops_per_insn somehow is zero,
+		     skip to avoid division/modulo by zero. */
+		  if (lh.maximum_ops_per_insn == 0)
+		    break;
 		  address += (lh.minimum_instruction_length
 			      * ((op_index + adjust)
 				 / lh.maximum_ops_per_insn));
@@ -2459,7 +2474,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
 		{
 		  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
-						FALSE, line_end);
+					FALSE, line_end);
 		  line_ptr += bytes_read;
 		}
 	      break;
@@ -2470,6 +2485,7 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	free (filename);
     }
 
+
   if (sort_line_sequences (table))
     return table;
 
@@ -3583,9 +3599,9 @@ comp_unit_find_nearest_line (struct comp_unit *unit,
     stash->inliner_chain = *function_ptr;
 
   return lookup_address_in_line_info_table (unit->line_table, addr,
-					    filename_ptr,
-					    linenumber_ptr,
-					    discriminator_ptr);
+					filename_ptr,
+					linenumber_ptr,
+					discriminator_ptr);
 }
 
 /* Check to see if line info is already decoded in a comp_unit.
@@ -3605,8 +3621,37 @@ comp_unit_maybe_decode_line_info (struct comp_unit *unit,
 	{
 	  unit->error = 1;
 	  return FALSE;
+// FIXME: Crash CWE-369: Divide By Zero
+ 	}
+
+      /*
+       * Rationale:
+       * Prevent calling decode_line_info on obviously too-small or
+       * out-of-bounds .debug_line data. The real division-by-zero
+       * occurs while decoding the line table. We can't safely assume
+       * decode_line_info will always validate denominators, so add a
+       * conservative sanity check here: ensure there is a minimum
+       * amount of data available before attempting to parse. If the
+       * data is too small or stmtlist is out of range, fail parsing
+       * gracefully by marking the unit as errored.
+       */
+      if (unit->stmtlist >= unit->end_ptr)
+	{
+	  unit->error = 1;
+	  return FALSE;
 	}
 
+      {
+	/* Require at least 4 bytes to hold a minimal line header so
+	   decode_line_info doesn't operate on truncated input. */
+	size_t remaining = (size_t)(unit->end_ptr - unit->stmtlist);
+	if (remaining < 4)
+	  {
+	    unit->error = 1;
+	    return FALSE;
+	  }
+      }
+
       unit->line_table = decode_line_info (unit, stash);
 
       if (! unit->line_table)
@@ -3628,7 +3673,7 @@ comp_unit_maybe_decode_line_info (struct comp_unit *unit,
 
 /* If UNIT contains SYM at ADDR, set the output parameters to the
    values for the line containing SYM.  The output parameters,
-   FILENAME_PTR, and LINENUMBER_PTR, are pointers to the objects to be
+   FILENAME_PTR, AND LINENUMBER_PTR, are pointers to the objects to be
    filled in.
 
    Return TRUE if UNIT contains SYM, and no errors were encountered;
