diff --git a/bfd/dwarf2.c b/bfd/dwarf2.c
index 89a3f9b1830..4d880dc06d3 100644
--- a/bfd/dwarf2.c
+++ b/bfd/dwarf2.c
@@ -2429,28 +2429,32 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
 	    case DW_LNS_set_column:
 	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
 					      FALSE, line_end);
-	      line_ptr += bytes_read;
-	      break;
-	    case DW_LNS_negate_stmt:
-	      is_stmt = (!is_stmt);
-	      break;
-	    case DW_LNS_set_basic_block:
-	      break;
-	    case DW_LNS_const_add_pc:
-	      if (lh.maximum_ops_per_insn == 1)
-		address += (lh.minimum_instruction_length
-			    * ((255 - lh.opcode_base) / lh.line_range));
-	      else
-		{
-		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
-		  address += (lh.minimum_instruction_length
-			      * ((op_index + adjust)
-				 / lh.maximum_ops_per_insn));
-		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
-		}
-	      break;
-	    case DW_LNS_fixed_advance_pc:
-	      address += read_2_bytes (abfd, line_ptr, line_end);
+      case DW_LNS_const_add_pc:
+          /* Validate DWARF header fields that may be used as divisors
+             to avoid divide-by-zero (CWE-369). If any critical field is
+             invalid treat the input as malformed and fail-fast by
+             returning NULL. */
+          if (lh.line_range == 0
+              || lh.maximum_ops_per_insn == 0
+              || lh.opcode_base == 0
+              || lh.minimum_instruction_length == 0)
+            {
+              /* Malformed DWARF: reject to avoid arithmetic exception. */
+              return NULL;
+            }
+
+          if (lh.maximum_ops_per_insn == 1)
+            address += (lh.minimum_instruction_length
+                        * ((255 - lh.opcode_base) / lh.line_range));
+          else
+            {
+              bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
+              address += (lh.minimum_instruction_length
+                          * ((op_index + adjust)
+                             / lh.maximum_ops_per_insn));
+              op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
+            }
+          break;	      address += read_2_bytes (abfd, line_ptr, line_end);
 	      op_index = 0;
 	      line_ptr += 2;
 	      break;
@@ -4711,74 +4715,74 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,
       else
 	stash->info_ptr += 4;
 
-      if (length > 0)
-	{
-	  bfd_byte * new_ptr;
-
-	  /* PR 21151  */
-	  if (stash->info_ptr + length > stash->info_ptr_end)
-	    return FALSE;
-
-	  each = parse_comp_unit (stash, length, info_ptr_unit,
-				  offset_size);
-	  if (!each)
-	    /* The dwarf information is damaged, don't trust it any
-	       more.  */
-	    break;
-
-	  new_ptr = stash->info_ptr + length;
-	  /* PR 17512: file: 1500698c.  */
-	  if (new_ptr < stash->info_ptr)
-	    {
-	      /* A corrupt length value - do not trust the info any more.  */
-	      found = FALSE;
-	      break;
-	    }
-	  else
-	    stash->info_ptr = new_ptr;
+          if (length > 0)
+    {
+      bfd_byte * new_ptr;
+
+      /* PR 21151  */
+      if (stash->info_ptr + length > stash->info_ptr_end)
+        return FALSE;
+
+      each = parse_comp_unit (stash, length, info_ptr_unit,
+                              offset_size);
+      if (!each)
+        /* The dwarf information is damaged, don't trust it any
+           more.  */
+        break;
+
+      new_ptr = stash->info_ptr + length;
+      /* PR 17512: file: 1500698c.  */
+      if (new_ptr < stash->info_ptr)
+        {
+          /* A corrupt length value - do not trust the info any more.  */
+          found = FALSE;
+          break;
+        }
+      else
+        stash->info_ptr = new_ptr;
 
-	  if (stash->all_comp_units)
-	    stash->all_comp_units->prev_unit = each;
-	  else
-	    stash->last_comp_unit = each;
-
-	  each->next_unit = stash->all_comp_units;
-	  stash->all_comp_units = each;
-
-	  /* DW_AT_low_pc and DW_AT_high_pc are optional for
-	     compilation units.  If we don't have them (i.e.,
-	     unit->high == 0), we need to consult the line info table
-	     to see if a compilation unit contains the given
-	     address.  */
-	  if (do_line)
-	    found = (((symbol->flags & BSF_FUNCTION) == 0
-		      || each->arange.high == 0
-		      || comp_unit_contains_address (each, addr))
-		     && comp_unit_find_line (each, symbol, addr,
-					     filename_ptr,
-					     linenumber_ptr,
-					     stash));
-	  else
-	    found = ((each->arange.high == 0
-		      || comp_unit_contains_address (each, addr))
-		     && comp_unit_find_nearest_line (each, addr,
-						     filename_ptr,
-						     &function,
-						     linenumber_ptr,
-						     discriminator_ptr,
-						     stash) != 0);
-
-	  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
-	      == stash->sec->size)
-	    {
-	      stash->sec = find_debug_info (stash->bfd_ptr, debug_sections,
-					    stash->sec);
-	      stash->sec_info_ptr = stash->info_ptr;
-	    }
+      if (stash->all_comp_units)
+        stash->all_comp_units->prev_unit = each;
+      else
+        stash->last_comp_unit = each;
+
+      each->next_unit = stash->all_comp_units;
+      stash->all_comp_units = each;
+
+      /* DW_AT_low_pc and DW_AT_high_pc are optional for
+         compilation units.  If we don't have them (i.e.,
+         unit->high == 0), we need to consult the line info table
+         to see if a compilation unit contains the given
+         address.  */
+      if (do_line)
+        found = (((symbol->flags & BSF_FUNCTION) == 0
+                  || each->arange.high == 0
+                  || comp_unit_contains_address (each, addr))
+                 && comp_unit_find_line (each, symbol, addr,
+                                         filename_ptr,
+                                         linenumber_ptr,
+                                         stash));
+      else
+        found = ((each->arange.high == 0
+                  || comp_unit_contains_address (each, addr))
+                 && comp_unit_find_nearest_line (each, addr,
+                                                 filename_ptr,
+                                                 &function,
+                                                 linenumber_ptr,
+                                                 discriminator_ptr,
+                                                 stash) != 0);
+
+      if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)
+          == stash->sec->size)
+        {
+          stash->sec = find_debug_info (stash->bfd_ptr, debug_sections,
+                                        stash->sec);
+          stash->sec_info_ptr = stash->info_ptr;
+        }
 
-	  if (found)
-	    goto done;
-	}
+      if (found)
+        goto done;
+    }
     }
 
  done:
