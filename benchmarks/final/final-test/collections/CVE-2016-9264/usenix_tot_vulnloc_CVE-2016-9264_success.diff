diff --git a/util/listmp3.c b/util/listmp3.c
index b7f06190..32b523a1 100644
--- a/util/listmp3.c
+++ b/util/listmp3.c
@@ -180,15 +180,89 @@ int main(int argc, char *argv[])
 {
   FILE *f;
 
-  if(argc<1)
+  /* Rationale:
+   * Perform a comprehensive scan of the file for any MP3 frame header
+   * that contains reserved values. If any reserved sampling-frequency
+   * index (3) or reserved MPEG version (1) is found anywhere we refuse
+   * to process the file. This eliminates the possibility that
+   * printMP3Headers will index a samplerate table with an out-of-range
+   * index derived from a malformed header.
+   */
+
+  if(argc<2)
     error("gimme file name");
 
   f = fopen(argv[1],"rb");
 
   if(!f)
-    error("couldn't open file");
+     error("couldn't open file");
+
+  {
+    unsigned char buf[8192];
+    unsigned char overlap[3] = {0,0,0};
+    size_t got;
+    int any_header_found = 0;
+
+    while((got = fread(buf, 1, sizeof(buf), f)) > 0) {
+      size_t total = got + 3; /* include up to 3 overlap bytes from prev */
+      /* build a temporary window array consisting of overlap + buf */
+      unsigned char *win = buf; /* we'll handle overlap by index math */
+
+      for(size_t i = 0; i + 4 <= total; ++i) {
+        unsigned int b0, b1, b2, b3;
+        if(i < 3) {
+          b0 = overlap[i];
+          size_t idx = 0;
+          b1 = (i+1 < 3) ? overlap[i+1] : buf[idx++];
+          b2 = (i+2 < 3) ? overlap[i+2] : buf[idx++];
+          b3 = buf[idx++];
+        } else {
+          size_t idx = i - 3;
+          b0 = buf[idx];
+          b1 = buf[idx+1];
+          b2 = buf[idx+2];
+          b3 = buf[idx+3];
+        }
+
+        unsigned int header = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
+
+        if((header & 0xFFE00000U) == 0xFFE00000U) {
+          unsigned int version = (header >> 19) & 3U;
+          unsigned int sampidx = (header >> 10) & 3U;
+
+          any_header_found = 1;
+
+          if(version == 1U || sampidx == 3U) {
+            fclose(f);
+            error("malformed/reserved MP3 header detected in file");
+          }
+        }
+      }
+
+      /* Prepare overlap for next chunk: last up to 3 bytes of this buf */
+      if(got >= 3) {
+        overlap[0] = buf[got-3];
+        overlap[1] = buf[got-2];
+        overlap[2] = buf[got-1];
+      } else {
+        /* shift existing overlap and append the small tail */
+        size_t shift = 3 - got;
+        for(size_t i = 0; i < shift; ++i) overlap[i] = overlap[i+got];
+        for(size_t i = 0; i < got; ++i) overlap[shift + i] = buf[i];
+      }
+    }
+
+    if(!any_header_found) {
+      fclose(f);
+      error("no MP3 frame header found in file");
+    }
+
+    /* Rewind before handing to printMP3Headers */
+    fseek(f, 0, SEEK_SET);
+  }
 
   printMP3Headers(f);
 
   exit(0);
 }
+
