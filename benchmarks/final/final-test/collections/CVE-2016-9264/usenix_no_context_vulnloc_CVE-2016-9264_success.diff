diff --git a/util/listmp3.c b/util/listmp3.c
index b7f06190..30c82782 100644
--- a/util/listmp3.c
+++ b/util/listmp3.c
@@ -123,30 +123,68 @@ void printMP3Headers(FILE *f)
 
     bitrateSum += bitrate;
 
-    if(version == 1)
+    /* Rationale:
+       Added explicit bounds checks for all table lookups derived from decoded
+       header indices. If an index is out-of-range the code now rejects the
+       malformed header by calling error(), mirroring the existing behavior
+       used elsewhere in this function for unknown version/layer. This
+       prevents out-of-bounds reads while preserving correct handling of
+       valid MP3 headers. */
+
+     if(version == 1)
     {
+      if((size_t)samplerate_idx >= (sizeof(mp1_samplerate_table)/sizeof(mp1_samplerate_table[0])))
+        error("invalid MP3 samplerate index!");
       samplerate = mp1_samplerate_table[samplerate_idx];
 
       if(layer == 1)
-	bitrate = mp1l1_bitrate_table[bitrate_idx];
+      {
+        if((size_t)bitrate_idx >= (sizeof(mp1l1_bitrate_table)/sizeof(mp1l1_bitrate_table[0])))
+          error("invalid MP3 bitrate index!");
+        bitrate = mp1l1_bitrate_table[bitrate_idx];
+      }
 
       else if(layer == 2)
-	bitrate = mp1l2_bitrate_table[bitrate_idx];
+      {
+        if((size_t)bitrate_idx >= (sizeof(mp1l2_bitrate_table)/sizeof(mp1l2_bitrate_table[0])))
+          error("invalid MP3 bitrate index!");
+        bitrate = mp1l2_bitrate_table[bitrate_idx];
+      }
 
       else if(layer == 3)
-	bitrate = mp1l3_bitrate_table[bitrate_idx];
+      {
+        if((size_t)bitrate_idx >= (sizeof(mp1l3_bitrate_table)/sizeof(mp1l3_bitrate_table[0])))
+          error("invalid MP3 bitrate index!");
+        bitrate = mp1l3_bitrate_table[bitrate_idx];
+      }
     }
     else
     {
       if(version == 2)
-	samplerate = mp2_samplerate_table[samplerate_idx];
+      {
+        if((size_t)samplerate_idx >= (sizeof(mp2_samplerate_table)/sizeof(mp2_samplerate_table[0])))
+          error("invalid MP3 samplerate index!");
+        samplerate = mp2_samplerate_table[samplerate_idx];
+      }
       else
-	samplerate = mp25_samplerate_table[samplerate_idx];
+      {
+        if((size_t)samplerate_idx >= (sizeof(mp25_samplerate_table)/sizeof(mp25_samplerate_table[0])))
+          error("invalid MP3 samplerate index!");
+        samplerate = mp25_samplerate_table[samplerate_idx];
+      }
 
       if(layer == 1)
-	bitrate = mp2l1_bitrate_table[bitrate_idx];
+      {
+        if((size_t)bitrate_idx >= (sizeof(mp2l1_bitrate_table)/sizeof(mp2l1_bitrate_table[0])))
+          error("invalid MP3 bitrate index!");
+        bitrate = mp2l1_bitrate_table[bitrate_idx];
+      }
       else
-	bitrate = mp2l23_bitrate_table[bitrate_idx];
+      {
+        if((size_t)bitrate_idx >= (sizeof(mp2l23_bitrate_table)/sizeof(mp2l23_bitrate_table[0])))
+          error("invalid MP3 bitrate index!");
+        bitrate = mp2l23_bitrate_table[bitrate_idx];
+      }
     }
 
     padding = (flags & MP3_PADDING) ? 1 : 0;
@@ -156,6 +194,7 @@ void printMP3Headers(FILE *f)
 
     if(version == 1)
       frameLen = 144 * bitrate * 1000 / samplerate + padding;
+
     else
       frameLen = 72 * bitrate * 1000 / samplerate + padding;
 
