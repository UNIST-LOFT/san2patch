diff --git a/src/make-prime-list.c b/src/make-prime-list.c
index 68c972a84..3da09450d 100644
--- a/src/make-prime-list.c
+++ b/src/make-prime-list.c
@@ -193,7 +193,8 @@ main (int argc, char **argv)
   if ( !(limit & 1))
     limit--;
 
-  size = (limit-1)/2;
+// FIXME: Crash CWE-125: Out-of-bounds Read
+   size = (limit-1)/2;
   /* sieve[i] represents 3+2*i */
   sieve = xalloc (size);
   memset (sieve, 1, size);
@@ -201,6 +202,29 @@ main (int argc, char **argv)
   prime_list = xalloc (size * sizeof (*prime_list));
   nprimes = 0;
 
+  /*
+   * Rationale for changes:
+   * The original code used: while (i < size && sieve[++i] == 0) ;
+   * That increments i (via ++i) and then reads sieve[i]. When i == size-1,
+   * ++i becomes size and the access sieve[size] is an out-of-bounds read.
+   * To fix this we must ensure any increment is followed by a bounds check
+   * before indexing sieve. The change below replaces the unsafe pre-increment
+   * form with a do/while loop that increments i first and then checks bounds
+   * (i < size) before reading sieve[i]. In C, the && operator evaluates
+   * left-to-right and short-circuits, so sieve[i] is only accessed when
+   * i < size is true. This preserves the original loop semantics while
+   * preventing the one-byte OOB read (CWE-125).
+   *
+   * Additional safe alternatives (kept disabled as examples):
+   * 1) Allocate an extra sentinel byte for sieve (sieve = xalloc(size + 1))
+   *    and memset it, so reading sieve[size] is valid. This is simple but
+   *    increases memory usage and relies on a sentinel rather than fixing
+   *    the loop logic.
+   * 2) Change the condition to use a guarded pre-increment: while (i < size-1 && sieve[++i] == 0) ;
+   *    which ensures ++i never produces size. This also fixes the OOB but
+   *    is slightly more fragile to reason about.
+   */
+
   for (i = 0; i < size;)
     {
       unsigned p = 3+2*i;
@@ -211,8 +235,21 @@ main (int argc, char **argv)
       for (j = (p*p - 3)/2; j < size; j+= p)
         sieve[j] = 0;
 
-      while (i < size && sieve[++i] == 0)
-        ;
+      /* Safely advance i to the next candidate index without reading past the end */
+      do
+        i++;
+      while (i < size && sieve[i] == 0);
+
+/*
+ alternative 1 - increase allocation (SAFE, but changes memory usage):
+  sieve = xalloc (size + 1);
+  memset (sieve, 1, size + 1);
+  ...
+  while (i < size && sieve[++i] == 0) ;
+
+ alternative 2 - guarded pre-increment (SAFE):
+  while (i < size-1 && sieve[++i] == 0) ;
+*/
     }
 
   output_primes (prime_list, nprimes);
