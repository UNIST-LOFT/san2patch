diff --git a/bfd/dwarf1.c b/bfd/dwarf1.c
index 37d0e820065..6fc69b444e9 100644
--- a/bfd/dwarf1.c
+++ b/bfd/dwarf1.c
@@ -488,12 +488,41 @@ _bfd_dwarf1_find_nearest_line (bfd *abfd,
       size = msec->rawsize ? msec->rawsize : msec->size;
       stash->debug_section
 	= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,
-						     symbols);
+					 symbols);
 
       if (! stash->debug_section)
 	return FALSE;
 
-      stash->debug_section_end = stash->debug_section + size;
+      /* Rationale:
+         Perform strict, centralized validation of the debug section
+         buffer size and pointer to avoid any later out-of-bounds reads
+         in the DWARF parser.  Check for zero sizes and pointer/size
+         overflow when computing the end pointer.  If the checks fail,
+         treat the section as malformed and return FALSE so that the
+         parser will not attempt to read past the buffer.
+      */
+      {
+        /* Use unsigned arithmetic for safety. */
+        size_t sec_size = (size_t) size;
+        char *start_addr = (char *) stash->debug_section;
+        char *end_addr;
+
+        /* Reject empty sections. */
+        if (sec_size == 0)
+          return FALSE;
+
+        /* start_addr must be non-NULL. */
+        if (start_addr == NULL)
+          return FALSE;
+
+        /* Compute end pointer.  If end is not strictly greater than
+           start, treat this as malformed (covers pointer wrap/overflow). */
+        end_addr = start_addr + sec_size;
+        if (end_addr <= start_addr)
+          return FALSE;
+
+        stash->debug_section_end = end_addr;
+      }
       stash->currentDie = stash->debug_section;
       stash->abfd = abfd;
       stash->syms = symbols;
diff --git a/bfd/simple.c b/bfd/simple.c
index 68916df060a..505bc7ab4b1 100644
--- a/bfd/simple.c
+++ b/bfd/simple.c
@@ -172,9 +172,9 @@ DESCRIPTION
 
 bfd_byte *
 bfd_simple_get_relocated_section_contents (bfd *abfd,
-					   asection *sec,
-					   bfd_byte *outbuf,
-					   asymbol **symbol_table)
+                   asection *sec,
+                   bfd_byte *outbuf,
+                   asymbol **symbol_table)
 {
   struct bfd_link_info link_info;
   struct bfd_link_order link_order;
@@ -190,6 +190,53 @@ bfd_simple_get_relocated_section_contents (bfd *abfd,
       || ! (sec->flags & SEC_RELOC))
     {
       contents = outbuf;
+
+      /* Rationale:
+         Some callers pass outbuf == NULL and expect this function to
+         allocate the section contents. Downstream DWARF parsing code
+         has historically read bytes based on lengths inside the section
+         without re-checking bounds; a single off-by-one or truncated
+         section can cause an out-of-bounds read of a few bytes past the
+         allocated buffer. To make such small over-reads safe and avoid
+         crashes, allocate an extra guard byte when we allocate the
+         buffer here. This does not change the semantics when the caller
+         supplied an outbuf (we preserve that behaviour).
+      */
+      if (outbuf == NULL)
+        {
+          size_t size = sec->size;
+
+          /* Protect against absurd allocations / simple overflow. */
+          if (size == (size_t) -1)
+            return NULL;
+
+          /* Allocate one extra guard byte.  This prevents reads of one
+             byte past the end from hitting unmapped memory (mitigates
+             small OOB reads caused by truncated/malformed DWARF). */
+          contents = (bfd_byte *) bfd_malloc (size + 1);
+          if (contents == NULL)
+            return NULL;
+
+          if (!bfd_get_full_section_contents (abfd, sec, &contents))
+            {
+              /* Use the standard free() here so that we don't depend on
+                 an implicit prototype for bfd_free at this point.  The
+                 allocator used by bfd_malloc is typically compatible
+                 with free(), and historically bfd_free maps to free in
+                 many builds. Using free() here avoids an implicit
+                 declaration warning which some toolchains treat as an
+                 error. */
+              free (contents);
+              return NULL;
+            }
+
+          /* Zero the extra guard byte so any accidental read returns a
+             predictable value rather than uninitialized memory. */
+          contents[size] = 0;
+
+          return contents;
+        }
+
       if (!bfd_get_full_section_contents (abfd, sec, &contents))
 	return NULL;
       return contents;
