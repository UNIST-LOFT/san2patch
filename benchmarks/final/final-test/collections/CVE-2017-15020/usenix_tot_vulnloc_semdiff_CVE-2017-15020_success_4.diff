diff --git a/bfd/dwarf1.c b/bfd/dwarf1.c
index 37d0e820065..624a099d867 100644
--- a/bfd/dwarf1.c
+++ b/bfd/dwarf1.c
@@ -217,43 +217,86 @@ parse_die (bfd *             abfd,
       xptr += 2;
 
       switch (FORM_FROM_ATTR (attr))
-	{
-	case FORM_DATA2:
-	  xptr += 2;
-	  break;
-	case FORM_DATA4:
-	case FORM_REF:
-	  if (attr == AT_sibling)
-	    aDieInfo->sibling = bfd_get_32 (abfd, (bfd_byte *) xptr);
-	  else if (attr == AT_stmt_list)
-	    {
-	      aDieInfo->stmt_list_offset = bfd_get_32 (abfd, (bfd_byte *) xptr);
-	      aDieInfo->has_stmt_list = 1;
-	    }
-	  xptr += 4;
-	  break;
-	case FORM_DATA8:
-	  xptr += 8;
-	  break;
-	case FORM_ADDR:
-	  if (attr == AT_low_pc)
-	    aDieInfo->low_pc = bfd_get_32 (abfd, (bfd_byte *) xptr);
-	  else if (attr == AT_high_pc)
-	    aDieInfo->high_pc = bfd_get_32 (abfd, (bfd_byte *) xptr);
-	  xptr += 4;
-	  break;
-	case FORM_BLOCK2:
-	  xptr += 2 + bfd_get_16 (abfd, (bfd_byte *) xptr);
-	  break;
-	case FORM_BLOCK4:
-	  xptr += 4 + bfd_get_32 (abfd, (bfd_byte *) xptr);
-	  break;
-	case FORM_STRING:
-	  if (attr == AT_name)
-	    aDieInfo->name = (char *) xptr;
-	  xptr += strlen ((char *) xptr) + 1;
-	  break;
-	}
+{
+case FORM_DATA2:
+  /* Ensure there are at least 2 bytes available before consuming. */
+  if (xptr + 2 > aDiePtrEnd)
+    return FALSE;
+  xptr += 2;
+  break;
+case FORM_DATA4:
+case FORM_REF:
+  /* Ensure 4 bytes available before reading a 32-bit value. */
+  if (xptr + 4 > aDiePtrEnd)
+    return FALSE;
+  if (attr == AT_sibling)
+    aDieInfo->sibling = bfd_get_32 (abfd, (bfd_byte *) xptr);
+  else if (attr == AT_stmt_list)
+    {
+      aDieInfo->stmt_list_offset = bfd_get_32 (abfd, (bfd_byte *) xptr);
+      aDieInfo->has_stmt_list = 1;
+    }
+  xptr += 4;
+  break;
+case FORM_DATA8:
+  /* Ensure 8 bytes available before consuming. */
+  if (xptr + 8 > aDiePtrEnd)
+    return FALSE;
+  xptr += 8;
+  break;
+case FORM_ADDR:
+  /* Ensure 4 bytes available before reading address fields. */
+  if (xptr + 4 > aDiePtrEnd)
+    return FALSE;
+  if (attr == AT_low_pc)
+    aDieInfo->low_pc = bfd_get_32 (abfd, (bfd_byte *) xptr);
+  else if (attr == AT_high_pc)
+    aDieInfo->high_pc = bfd_get_32 (abfd, (bfd_byte *) xptr);
+  xptr += 4;
+  break;
+case FORM_BLOCK2:
+  {
+    /* Read 2-byte length only if available, then bounds-check payload. */
+    if (xptr + 2 > aDiePtrEnd)
+      return FALSE;
+    unsigned int _len2 = bfd_get_16 (abfd, (bfd_byte *) xptr);
+    if (xptr + 2 + _len2 > aDiePtrEnd)
+      return FALSE;
+    xptr += 2 + _len2;
+  }
+  break;
+case FORM_BLOCK4:
+  {
+    /* Safely handle 4-byte length-prefixed block: ensure length field
+       is readable, then that the claimed length fits within remaining bytes.
+       Prevent integer wrap/overflow by checking against remaining bytes. */
+    if (xptr + 4 > aDiePtrEnd)
+      return FALSE;
+    u_int32_t _len4 = bfd_get_32 (abfd, (bfd_byte *) xptr);
+    if (_len4 > (u_int32_t)(aDiePtrEnd - (xptr + 4)))
+      return FALSE;
+    xptr += 4 + _len4;
+  }
+  break;
+case FORM_STRING:
+  {
+    /* Ensure there is a NUL terminator within the remaining buffer
+       before taking the string or advancing past it. */
+    size_t _rem = (size_t) (aDiePtrEnd - xptr);
+    if (_rem == 0)
+      return FALSE;
+    size_t _i = 0;
+    while (_i < _rem && ((char *) xptr)[_i] != '\0')
+      _i++;
+    if (_i >= _rem)
+      return FALSE; /* no terminator found */
+    if (attr == AT_name)
+      aDieInfo->name = (char *) xptr;
+    xptr += _i + 1;
+  }
+  break;
+}
+
     }
 
   return TRUE;
