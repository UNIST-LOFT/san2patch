diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..338966f6 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,9 +1089,21 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow (triggered by CWE-190)
+ 		vd = &(iso9660->joliet);
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	/*
+	 * RATIONALE: Ensure multiplication does not overflow 32-bit arithmetic.
+	 * Promote operand to int64_t and validate that vd->location is in a
+	 * safe range before multiplying by LOGICAL_BLOCK_SIZE.
+	 */
+	if (vd->location < 0 || (int64_t)vd->location > (INT64_MAX / LOGICAL_BLOCK_SIZE)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Invalid or out-of-range block location when scanning ISO9660");
+		return (ARCHIVE_FATAL);
+	}
+
+	skipsize = (int64_t)vd->location * LOGICAL_BLOCK_SIZE;
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
@@ -1129,7 +1141,13 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	    && iso9660->seenJoliet) {
 		/* Switch reading data from primary to joliet. */
 		vd = &(iso9660->joliet);
-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+		/* Validate again before doing arithmetic with vd->location. */
+		if (vd->location < 0 || (int64_t)vd->location > (INT64_MAX / LOGICAL_BLOCK_SIZE)) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Invalid or out-of-range block location when scanning ISO9660");
+			return (ARCHIVE_FATAL);
+		}
+		skipsize = (int64_t)vd->location * LOGICAL_BLOCK_SIZE;
 		skipsize -= iso9660->current_position;
 		skipsize = __archive_read_consume(a, skipsize);
 		if (skipsize < 0)
@@ -1162,33 +1180,44 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
 {
 	struct iso9660 *iso9660;
 	struct file_info *file;
-	int r, rd_r = ARCHIVE_OK;
+int r, rd_r = ARCHIVE_OK;
 
-	iso9660 = (struct iso9660 *)(a->format->data);
-
-	if (!a->archive.archive_format) {
-		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
-		a->archive.archive_format_name = "ISO9660";
-	}
+iso9660 = (struct iso9660 *)(a->format->data);
 
-	if (iso9660->current_position == 0) {
-		r = choose_volume(a, iso9660);
-		if (r != ARCHIVE_OK)
-			return (r);
-	}
+/* Rationale: Defensive null check. If format->data is NULL, choose_volume
+   may dereference it and later perform unchecked arithmetic on metadata
+   that can cause integer overflow and buffer overflows. Fail early with
+   a clear error instead of continuing. */
+if (iso9660 == NULL) {
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
+	    "ISO9660: corrupt format data");
+	return (ARCHIVE_FATAL);
+}
 
-	file = NULL;/* Eliminate a warning. */
-	/* Get the next entry that appears after the current offset. */
-	r = next_entry_seek(a, iso9660, &file);
+if (!a->archive.archive_format) {
+	a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
+	a->archive.archive_format_name = "ISO9660";
+}
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow (triggered by CWE-190)
+ 
+if (iso9660->current_position == 0) {
+	r = choose_volume(a, iso9660);
 	if (r != ARCHIVE_OK)
 		return (r);
+}
 
+file = NULL;/* Eliminate a warning. */
+/* Get the next entry that appears after the current offset. */
+r = next_entry_seek(a, iso9660, &file);
+if (r != ARCHIVE_OK)
+	return (r);
 	if (iso9660->seenJoliet) {
 		/*
 		 * Convert UTF-16BE of a filename to local locale MBS
