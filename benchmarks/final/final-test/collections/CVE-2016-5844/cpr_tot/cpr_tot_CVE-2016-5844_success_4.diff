diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..7da3155b 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,6 +1089,14 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
+/* Patch: prevent signed integer overflow when computing skipsize.
+   Check vd->location against INT64_MAX/LOGICAL_BLOCK_SIZE before
+   performing the multiplication, and fail gracefully if it would overflow. */
+		if (vd->location < 0 || vd->location > (INT64_MAX / LOGICAL_BLOCK_SIZE)) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ISO9660 block location is invalid or too large");
+			return (ARCHIVE_FATAL);
+		}
 		vd = &(iso9660->joliet);
 
 	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
@@ -1162,6 +1170,7 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
@@ -1176,8 +1185,12 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
 		a->archive.archive_format_name = "ISO9660";
 	}
-
-	if (iso9660->current_position == 0) {
+	/* Prevent calling choose_volume with a NULL iso9660 pointer. This avoids
+	   triggering choose_volume on a bad/NULL context which can lead to
+	   undefined behaviour. */
+	if (iso9660 == NULL)
+		return (ARCHIVE_FATAL);
+ 	if (iso9660->current_position == 0) {
 		r = choose_volume(a, iso9660);
 		if (r != ARCHIVE_OK)
 			return (r);
