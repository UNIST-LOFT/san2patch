diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..e7223ba7 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,6 +1089,12 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow
+	if (vd->location < 0 || vd->location > (INT_MAX / LOGICAL_BLOCK_SIZE)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "iso9660: declared extent location is out of range");
+		return (ARCHIVE_FATAL);
+	}
 		vd = &(iso9660->joliet);
 
 	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
@@ -1162,6 +1168,7 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
@@ -1176,11 +1183,26 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
 		a->archive.archive_format_name = "ISO9660";
 	}
-
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow
+	/*
+	 * Validate parsed volume/extent counts that choose_volume may have set
+	 * to ensure multiplying by the logical block size (2048) cannot overflow
+	 * a size_t/uint64_t value and lead to truncated/negative offsets.
+	 */
 	if (iso9660->current_position == 0) {
 		r = choose_volume(a, iso9660);
 		if (r != ARCHIVE_OK)
 			return (r);
+
+		/* Check for integer overflow: volume_space_size * 2048 must fit in size_t. */
+		if (iso9660->volume_space_size > 0) {
+			uint64_t bytes = (uint64_t)iso9660->volume_space_size * 2048ULL;
+			if (bytes / 2048ULL != (uint64_t)iso9660->volume_space_size || bytes > (uint64_t)SIZE_MAX) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+					"iso9660: declared volume size is too large");
+				return (ARCHIVE_FATAL);
+			}
+		}
 	}
 
 	file = NULL;/* Eliminate a warning. */
@@ -1189,7 +1211,10 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 	if (r != ARCHIVE_OK)
 		return (r);
 
-	if (iso9660->seenJoliet) {
+/* Rationale: This minimal check verifies the parsed block/extent count (volume_space_size)
+   cannot overflow when multiplied by 2048 by promoting to uint64_t and comparing against
+   SIZE_MAX; if the value is out of range, we fail fast with an error instead of using
+   a wrapped/truncated offset. */	if (iso9660->seenJoliet) {
 		/*
 		 * Convert UTF-16BE of a filename to local locale MBS
 		 * and store the result into a filename field.
