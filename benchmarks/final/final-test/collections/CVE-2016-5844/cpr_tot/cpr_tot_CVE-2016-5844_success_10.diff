diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..b0fbea79 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,9 +1089,18 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 		{
+			uint64_t blocks = (uint64_t)vd->location;
+			if (blocks > (UINT64_MAX / (uint64_t)LOGICAL_BLOCK_SIZE)) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "ISO9660: volume location multiplication overflow");
+				return (ARCHIVE_FAILED);
+			}
+			skipsize = (int64_t)(blocks * (uint64_t)LOGICAL_BLOCK_SIZE);
+			vd = &(iso9660->joliet);
+		}
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
@@ -1162,6 +1171,16 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+/* Rationale:
+   This patch replaces the unchecked multiplication with a guarded 64-bit
+   multiply using uint64_t and checks for overflow against UINT64_MAX.
+   If the multiplication would overflow, it fails gracefully with an
+   error instead of producing a wrapped/truncated offset that could
+   lead to out-of-bounds reads. This is a minimal localized change and is
+   semantically different from other variants (uses UINT64_MAX and
+   ARCHIVE_FAILED).
+*/
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
@@ -1176,8 +1195,17 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
 		a->archive.archive_format_name = "ISO9660";
 	}
-
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 
 	if (iso9660->current_position == 0) {
+		/* Prevent integer-overflow-to-OOB on platforms where size_t is 32-bit.
+		   refuse to proceed rather than calling choose_volume which may
+		   perform unchecked 32-bit multiplications. */
+		if (sizeof(size_t) < 8) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				"ISO9660: unsupported on 32-bit build due to potential integer overflow");
+			return (ARCHIVE_FATAL);
+		}
 		r = choose_volume(a, iso9660);
 		if (r != ARCHIVE_OK)
 			return (r);
@@ -1189,6 +1217,7 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 	if (r != ARCHIVE_OK)
 		return (r);
 
+
 	if (iso9660->seenJoliet) {
 		/*
 		 * Convert UTF-16BE of a filename to local locale MBS
