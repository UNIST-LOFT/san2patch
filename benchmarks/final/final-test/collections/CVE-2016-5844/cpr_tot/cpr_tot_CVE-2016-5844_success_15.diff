diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..f40c4eb9 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1095,6 +1095,23 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
+// FIXME: Crash CWE-787: Out-of-bounds Write (triggered by integer overflow)
+	{
+		uint64_t skip64 = (uint64_t)vd->location * (uint64_t)LOGICAL_BLOCK_SIZE;
+		/* If the product computed in a wider type doesn't match the earlier
+		 * value, the original multiplication likely overflowed. */
+		if ((int64_t)skip64 != skipsize) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ISO9660: block location multiplication overflow");
+			return (ARCHIVE_FATAL);
+		}
+		/* Ensure skip + size does not wrap. */
+		if (vd->size > 0 && skip64 + (uint64_t)vd->size < skip64) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ISO9660: skip + size overflow");
+			return (ARCHIVE_FATAL);
+		}
+	}
 	iso9660->current_position = skipsize;
 
 	block = __archive_read_ahead(a, vd->size, NULL);
@@ -1162,6 +1179,11 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+/* Rationale: This minimal insertion re-computes the block*size product
+   in a wide unsigned type and verifies it matches the previously
+   computed skipsize (stored in skipsize). If they differ, an overflow
+   occurred and we abort. We also guard against skip+vd->size wrapping. */
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
diff --git a/libarchive/archive_virtual.c b/libarchive/archive_virtual.c
index de2595a9..39048715 100644
--- a/libarchive/archive_virtual.c
+++ b/libarchive/archive_virtual.c
@@ -135,7 +135,7 @@ archive_write_data_block(struct archive *a, const void *buff, size_t s, int64_t
 {
 	if (a->vtable->archive_write_data_block == NULL) {
 		archive_set_error(a, ARCHIVE_ERRNO_MISC,
-		    "archive_write_data_block not supported");
+		"archive_write_data_block not supported");
 		a->state = ARCHIVE_STATE_FATAL;
 		return (ARCHIVE_FATAL);
 	}
@@ -143,8 +143,19 @@ archive_write_data_block(struct archive *a, const void *buff, size_t s, int64_t
 }
 
 int
-archive_read_next_header(struct archive *a, struct archive_entry **entry)
-{
+// FIXME: Crash CWE-787: Out-of-bounds Write (triggered by integer overflow)
+ archive_read_next_header(struct archive *a, struct archive_entry **entry)
+{
+	/* Guard against NULL pointers and missing vtable entry to avoid
+	 * indirect calls on invalid function pointers which could lead
+	 * to undefined behavior further down the ISO9660 parsing path.
+	 */
+	if (a == NULL || a->vtable == NULL ||
+	    a->vtable->archive_read_next_header == NULL) {
+		if (a)
+			a->state = ARCHIVE_STATE_FATAL;
+		return (ARCHIVE_FATAL);
+	}
 	return ((a->vtable->archive_read_next_header)(a, entry));
 }
 
