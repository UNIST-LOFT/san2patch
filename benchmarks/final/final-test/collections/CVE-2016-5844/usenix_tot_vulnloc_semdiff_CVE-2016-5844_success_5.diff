diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..998b45b0 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1091,7 +1091,22 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 		/* This condition is unlikely; by way of caution. */
 		vd = &(iso9660->joliet);
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	/*
+	 * Rationale: Compute multiplication in an unsigned 64-bit type and
+	 * explicitly check against INT64_MAX to avoid signed integer overflow
+	 * when converting to skipsize (int64_t). If overflow is detected,
+	 * fail safely rather than producing a wrapped value that may lead
+	 * to out-of-bounds reads.
+	 */
+	{
+		uint64_t skip64 = (uint64_t)LOGICAL_BLOCK_SIZE * (uint64_t)vd->location;
+		if (skip64 > (uint64_t)INT64_MAX) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ISO9660: volume offset too large (integer overflow)");
+			return (ARCHIVE_FATAL);
+		}
+		skipsize = (int64_t)skip64;
+	}
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
@@ -1129,7 +1144,21 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	    && iso9660->seenJoliet) {
 		/* Switch reading data from primary to joliet. */
 		vd = &(iso9660->joliet);
-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+		/*
+		 * Rationale: Protect multiplication here as well (same reason as
+		 * above). Compute in 64-bit unsigned and verify no overflow when
+		 * casting to int64_t. This prevents wrapped negative/incorrect
+		 * skipsize values.
+		 */
+		{
+			uint64_t skip64 = (uint64_t)LOGICAL_BLOCK_SIZE * (uint64_t)vd->location;
+			if (skip64 > (uint64_t)INT64_MAX) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+				    "ISO9660: volume offset too large (integer overflow)");
+				return (ARCHIVE_FATAL);
+			}
+			skipsize = (int64_t)skip64;
+		}
 		skipsize -= iso9660->current_position;
 		skipsize = __archive_read_consume(a, skipsize);
 		if (skipsize < 0)
@@ -1162,6 +1191,7 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
