diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..5bd5c55e 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,9 +1089,31 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash CWE-190: Integer Overflow or Wraparound
+ 		vd = &(iso9660->joliet);
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	/*
+	 * Prevent integer overflow when computing the number of bytes to skip.
+	 * The original code performed the multiplication in a (likely) 32-bit
+	 * int which could overflow: LOGICAL_BLOCK_SIZE * vd->location.
+	 *
+	 * Rationale: perform the multiplication in an unsigned 64-bit type and
+	 * explicitly check that the result fits in int64_t before assigning to
+	 * skipsize and passing it to __archive_read_consume. If the computation
+	 * would overflow, return a fatal error to avoid undefined behavior and
+	 * potential memory corruption.
+	 */
+	{
+		uint64_t blk_count = (uint64_t)vd->location;
+		uint64_t byte_count = blk_count * (uint64_t)LOGICAL_BLOCK_SIZE;
+		/* Ensure result fits in signed 64-bit used by skipsize. */
+		if (byte_count > (uint64_t)INT64_MAX) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ISO9660 image too large or malformed (skip size overflow)");
+			return (ARCHIVE_FATAL);
+		}
+		skipsize = (int64_t)byte_count;
+	}
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
