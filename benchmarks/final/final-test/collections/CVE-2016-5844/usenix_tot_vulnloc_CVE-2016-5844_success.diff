diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..9ec7c68d 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1083,15 +1083,34 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	const void *block;
 	char seenJoliet;
 
+	/*
+	 * Rationale:
+	 * Prevent signed 32-bit overflow from LOGICAL_BLOCK_SIZE * vd->location
+	 * by performing the multiplication in a sufficiently wide unsigned type
+	 * and validating the operand first. If vd->location is absurdly large
+	 * (such that the product would exceed INT64_MAX), fail gracefully.
+	 */
+
 	vd = &(iso9660->primary);
 	if (!iso9660->opt_support_joliet)
 		iso9660->seenJoliet = 0;
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow
+ 		vd = &(iso9660->joliet);
+
+	/* Validate vd->location to avoid multiplication overflow. */
+	{
+		uint64_t max_blocks = (uint64_t)INT64_MAX / (uint64_t)LOGICAL_BLOCK_SIZE;
+		if ((uint64_t)vd->location > max_blocks) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "ISO9660: invalid location/count (too large)");
+			return (ARCHIVE_FATAL);
+		}
+	}
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	skipsize = (int64_t)((uint64_t)vd->location * (uint64_t)LOGICAL_BLOCK_SIZE);
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
@@ -1129,7 +1148,18 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	    && iso9660->seenJoliet) {
 		/* Switch reading data from primary to joliet. */
 		vd = &(iso9660->joliet);
-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+
+		/* Validate multiplication to avoid overflow and wraparound. */
+		{
+			uint64_t max_blocks = (uint64_t)INT64_MAX / (uint64_t)LOGICAL_BLOCK_SIZE;
+			if ((uint64_t)vd->location > max_blocks) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "ISO9660: invalid location/count (too large)");
+				return (ARCHIVE_FATAL);
+			}
+		}
+
+		skipsize = (int64_t)((uint64_t)vd->location * (uint64_t)LOGICAL_BLOCK_SIZE);
 		skipsize -= iso9660->current_position;
 		skipsize = __archive_read_consume(a, skipsize);
 		if (skipsize < 0)
@@ -1162,6 +1192,7 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
@@ -1176,11 +1207,40 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
 		a->archive.archive_format_name = "ISO9660";
 	}
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow
 
 	if (iso9660->current_position == 0) {
 		r = choose_volume(a, iso9660);
 		if (r != ARCHIVE_OK)
 			return (r);
+
+		/*
+		 * Rationale:
+		 * Defensive validation after choose_volume: choose_volume parses
+		 * archive metadata that may contain attacker-controlled block/extent
+		 * counts which previously were multiplied by the logical block size
+		 * into a signed 32-bit integer and could overflow/wrap. We validate
+		 * the resulting current_position to ensure it is within sane bounds
+		 * before any seeks/reads/allocations that follow. If the value is
+		 * invalid we fail early with a file-format error.
+		 */
+		if (iso9660->current_position < 0) {
+			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "ISO9660: invalid volume position (negative)");
+			return (ARCHIVE_FATAL);
+		}
+
+		/* Prevent any wrapped or absurdly large 32-bit values from being
+		 * used further down the code path. Using INT32_MAX here is a
+		 * conservative sanity check against 32-bit signed overflow that was
+		 * observed in the sanitizer report. */
+		#if defined(INT32_MAX)
+		if ((int64_t)iso9660->current_position > (int64_t)INT32_MAX) {
+			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "ISO9660: volume position too large");
+			return (ARCHIVE_FATAL);
+		}
+		#endif
 	}
 
 	file = NULL;/* Eliminate a warning. */
@@ -1188,7 +1248,6 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 	r = next_entry_seek(a, iso9660, &file);
 	if (r != ARCHIVE_OK)
 		return (r);
-
 	if (iso9660->seenJoliet) {
 		/*
 		 * Convert UTF-16BE of a filename to local locale MBS
