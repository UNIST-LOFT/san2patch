diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..b12e4698 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,9 +1089,33 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash CWE-680: Integer Overflow to Buffer Overflow (leads to out-of-bounds reads/writes)
+ 		vd = &(iso9660->joliet);
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	/*
+	 * Calculate skip size in a wide unsigned type and validate to avoid
+	 * signed integer overflow/wraparound. If invalid, return an error
+	 * instead of using a truncated/wrapped value.
+	 */
+	{
+		uint64_t block_count;
+		uint64_t mul;
+
+		if (vd->location < 0) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "Invalid ISO9660 location (negative)");
+			return (ARCHIVE_FATAL);
+		}
+		block_count = (uint64_t)vd->location;
+		/* Ensure multiplication won't exceed int64_t range expected by __archive_read_consume */
+		if (block_count > (uint64_t)INT64_MAX / (uint64_t)LOGICAL_BLOCK_SIZE) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			    "ISO9660 location too large (overflow)");
+			return (ARCHIVE_FATAL);
+		}
+		mul = block_count * (uint64_t)LOGICAL_BLOCK_SIZE;
+		skipsize = (int64_t)mul;
+	}
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
@@ -1129,8 +1153,31 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	    && iso9660->seenJoliet) {
 		/* Switch reading data from primary to joliet. */
 		vd = &(iso9660->joliet);
-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
-		skipsize -= iso9660->current_position;
+		/* Validate multiplication as above before computing skip delta. */
+		{
+			uint64_t block_count;
+			uint64_t mul;
+
+			if (vd->location < 0) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+				    "Invalid ISO9660 location (negative)");
+				return (ARCHIVE_FATAL);
+			}
+			block_count = (uint64_t)vd->location;
+			if (block_count > (uint64_t)INT64_MAX / (uint64_t)LOGICAL_BLOCK_SIZE) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+				    "ISO9660 location too large (overflow)");
+				return (ARCHIVE_FATAL);
+			}
+			mul = block_count * (uint64_t)LOGICAL_BLOCK_SIZE;
+			/* Compute the delta; mul is >= 0 and current_position is non-negative here. */
+			if ((int64_t)mul < iso9660->current_position) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+				    "ISO9660 location before current position");
+				return (ARCHIVE_FATAL);
+			}
+			skipsize = (int64_t)mul - iso9660->current_position;
+		}
 		skipsize = __archive_read_consume(a, skipsize);
 		if (skipsize < 0)
 			return ((int)skipsize);
@@ -1162,6 +1209,14 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+/* Rationale:
+ * Replaced direct multiplication of LOGICAL_BLOCK_SIZE * vd->location with
+ * multiplication performed in uint64_t and checked against INT64_MAX to avoid
+ * signed integer overflow/wraparound. Negative locations are rejected.
+ * This prevents producing truncated/skewed skip sizes that lead to out-of-bounds
+ * reads/writes while preserving behavior for valid inputs.
+ */
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
