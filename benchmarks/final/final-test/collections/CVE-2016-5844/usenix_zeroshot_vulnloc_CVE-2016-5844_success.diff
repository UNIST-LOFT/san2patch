diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..f3044c8a 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,9 +1089,35 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash
+ 		vd = &(iso9660->joliet);
+
+	/*
+	 * Calculate the number of bytes to skip to reach the volume descriptor.
+	 *
+	 * Rationale:
+	 * The original code used: skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	 * which performs the multiplication in 'int' (or another narrower signed
+	 * integer type) and can overflow when vd->location is large (reported by
+	 * sanitizer: signed integer overflow). To prevent this, perform the
+	 * multiplication in 64-bit and validate the operands before use.
+	 */
+	/* Validate vd->location to avoid malformed/negative values. */
+	if (vd->location < 0) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "Invalid ISO9660 volume location");
+		return (ARCHIVE_FATAL);
+	}
+
+	/* Prevent overflow by ensuring the multiplication fits in int64_t. */
+	if ((uint64_t)vd->location > (uint64_t)INT64_MAX / (uint64_t)LOGICAL_BLOCK_SIZE) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+		    "ISO9660 volume location is too large");
+		return (ARCHIVE_FATAL);
+	}
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+	/* Perform multiplication in 64-bit to avoid signed overflow. */
+	skipsize = (int64_t)vd->location * (int64_t)LOGICAL_BLOCK_SIZE;
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
