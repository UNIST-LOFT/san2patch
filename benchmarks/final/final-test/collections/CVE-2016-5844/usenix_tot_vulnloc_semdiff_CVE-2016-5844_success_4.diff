diff --git a/libarchive/archive_read_support_format_iso9660.c b/libarchive/archive_read_support_format_iso9660.c
index 6934ceef..061d2257 100644
--- a/libarchive/archive_read_support_format_iso9660.c
+++ b/libarchive/archive_read_support_format_iso9660.c
@@ -1089,9 +1089,36 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	if (iso9660->seenJoliet &&
 		vd->location > iso9660->joliet.location)
 		/* This condition is unlikely; by way of caution. */
-		vd = &(iso9660->joliet);
+// FIXME: Crash CWE-125: Out-of-bounds Read
+ 		vd = &(iso9660->joliet);
+
+	/*
+	 * Compute skip using size_t to ensure multiplication is done in a
+	 * wide unsigned type, then validate against INT64_MAX. This keeps
+	 * changes minimal while preventing overflow/wrap.
+	 */
+	{
+		size_t tmp;
+		if (vd->location < 0) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "ISO9660: invalid extent location");
+			return (ARCHIVE_FATAL);
+		}
+		/* Prevent overflow of size_t multiplication */
+		if ((size_t)vd->location > (SIZE_MAX / (size_t)LOGICAL_BLOCK_SIZE)) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "ISO9660: extent count too large");
+			return (ARCHIVE_FATAL);
+		}
+		tmp = (size_t)vd->location * (size_t)LOGICAL_BLOCK_SIZE;
+		if ((unsigned long long)tmp > (unsigned long long)INT64_MAX) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    "ISO9660: extent byte offset too large");
+			return (ARCHIVE_FATAL);
+		}
+		skipsize = (int64_t)tmp;
+	}
 
-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
@@ -1129,8 +1156,32 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	    && iso9660->seenJoliet) {
 		/* Switch reading data from primary to joliet. */
 		vd = &(iso9660->joliet);
-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
-		skipsize -= iso9660->current_position;
+		/* Compute skip using size_t and validate before subtracting. */
+		{
+			size_t tmp;
+			if (vd->location < 0) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "ISO9660: invalid extent location");
+				return (ARCHIVE_FATAL);
+			}
+			if ((size_t)vd->location > (SIZE_MAX / (size_t)LOGICAL_BLOCK_SIZE)) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "ISO9660: extent count too large");
+				return (ARCHIVE_FATAL);
+			}
+			tmp = (size_t)vd->location * (size_t)LOGICAL_BLOCK_SIZE;
+			if ((unsigned long long)tmp > (unsigned long long)INT64_MAX) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "ISO9660: extent byte offset too large");
+				return (ARCHIVE_FATAL);
+			}
+			if ((uint64_t)tmp < (uint64_t)iso9660->current_position) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "ISO9660: invalid extent location before current position");
+				return (ARCHIVE_FATAL);
+			}
+			skipsize = (int64_t)tmp - iso9660->current_position;
+		}
 		skipsize = __archive_read_consume(a, skipsize);
 		if (skipsize < 0)
 			return ((int)skipsize);
@@ -1162,13 +1213,14 @@ choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	return (ARCHIVE_OK);
 }
 
+
 static int
 archive_read_format_iso9660_read_header(struct archive_read *a,
     struct archive_entry *entry)
 {
 	struct iso9660 *iso9660;
 	struct file_info *file;
-	int r, rd_r = ARCHIVE_OK;
+int r, rd_r = ARCHIVE_OK;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
 
@@ -1176,8 +1228,22 @@ archive_read_format_iso9660_read_header(struct archive_read *a,
 		a->archive.archive_format = ARCHIVE_FORMAT_ISO9660;
 		a->archive.archive_format_name = "ISO9660";
 	}
-
+// FIXME: Crash CWE-125: Out-of-bounds Read
+	/* Rationale: If current_position is zero, choose_volume() will parse
+	   volume descriptors and may populate fields used later for computing
+	   byte offsets. As an additional safety measure, refuse to proceed
+	   when current_position itself indicates an implausibly large value
+	   that could lead to overflow when used as a multiplier/offset. */
 	if (iso9660->current_position == 0) {
+		/* Treat current_position as an extent-like count for this check.
+		   Use a conservative cap so multiplies by 2048 cannot overflow
+		   a signed 32-bit int used elsewhere. */
+		if ((unsigned long long)iso9660->current_position > (((unsigned long long)2147483647) / 2048ULL)) {
+			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
+				"ISO9660: current position too large (possible malformed header)");
+			return (ARCHIVE_FATAL);
+		}
+
 		r = choose_volume(a, iso9660);
 		if (r != ARCHIVE_OK)
 			return (r);
