<Goal>You are responsible for patching a vulnerability found in an open source package, and you need to create a patch file that fixes the vulnerability based on a bunch of information.</Goal>

<Package_Info>
    <Package_Name>{{package_name}}</Package_Name>
    <Package_Language>{{package_language}}</Package_Language>
</Package_Info>

{{vuln_info_final | to_xml("Vulnerability_Info")}}

<How-To-Fix>
    <Guideline>{{fix_strategy.guideline}}</Guideline>
    <Description>{{fix_strategy.description}}</Description>
</How-To-Fix>

{% if func_def|length > 0 %}
<Fix_Target_Function_Info>
    <Function_Signature>{{func_def}}</Function_Signature>
    <Function_Return_Statements>{{func_ret}}</Function_Return_Statements>
</Fix_Target_Function_Info>
{% endif %}

<Fix_Target_Code>
{{original_function}}
</Fix_Target_Code>

<Instruction>
Using the information above, generate candidates for modified code that fixes the vulnerability.
Generate code that is modified in as many different ways as possible. Each candidate should be different from the others.
Each patches should contain minimal changes, like adding a single line of checks (null checks, boundary checks).
You should only fix the Fix_Target_Code unconditionally. Don't respond the code in Fix_Target_Function_Info.
Generate the actual fixed code, not just a patch file that modifies the code. Preserve all whitespaces (tabs and spaces) in Fix_Target_Code to ensure that only intentional changes appear in the final diff.

IMPORTANT: This file's Fix_Target_Code includes a unique marker token "<PATCH>" that indicates the exact location you must change.
- You MUST NOT modify any line except by replacing the "<PATCH>" token's content.
- Replace only the token "<PATCH>" with the minimal patch (for example, a single guard/check line or small expression).
- Output the full Fix_Target_Code block with "<PATCH>" replaced (do not output diffs or separate patch files).
- Keep the rest of the code exactly as-is (start and end of Fix_Target_Code must match the provided Fix_Target_Code).

On avoiding duplicates:
- If the input contains <Previous_Successful_Patches>, you are provided with previously accepted patches in `prev_correct_patches`.
- Your generated patched code must NOT be identical (byte-for-byte) to any of the provided previous patches.
- If your first minimal change would produce a patch identical to a previous one, produce a semantically different patch. It doesn't have to be a correct patch. Just make a patch that passes the test. Keep the change small and conservative.
- If you can't produce a different minimal patch, explain briefly why within the rationale field, then produce the best non-identical minimal variant.

On patch size and style:
- MINIMIZE CHANGES: Make the smallest possible modification to fix the vulnerability. Change only the necessary lines and preserve as much of the original code structure as possible.
- PREFER SIMPLE FIXES: Use simple checks (null checks, boundary checks) rather than restructuring code.

Output format:
- For each candidate, output the full patched Fix_Target_Code (the full original function/block text with "<PATCH>" replaced), and also provide a short rationale explaining why this small change fixes the issue and confirming it is different from previous patches.
- Do not modify other files or functions. The result must be safe and compileable (if obvious compile issues arise, explain them).
</Instruction>

{% if prev_correct_patches %}
<Previous_Successful_Patches>
    <Note>
        The inputs below list previously accepted (successful) patches for this vulnerability.
        Important: DO NOT produce a patch that is identical or semantically equivalent to any of these patches.
        Produce a semantically different fix. You may use a different minimal-check style (different guard, check order, or small logic change),
        but keep the patch small. If you cannot produce a different minimal patch, explain why.
    </Note>

    {# To limit tokens, we show only a truncated preview (first 4k chars) of each previous patch.
       If a patch is longer, the preview will be followed by "(truncated)". #}
    {% for p in prev_correct_patches %}
    <Patch index="{{ loop.index }}">
<![CDATA[
{{ p[:00] }}
{% if p|length > 4096 %}... (truncated){% endif %}
]]>
    </Patch>
    {% endfor %}
</Previous_Successful_Patches>
{% endif %}


<Important_Note>
- Only the source code provided by Fix_Target_Code is checked and modified line by line, and no additional functions are modified.
- Do not modify using ambiguous source code.
- The source code should be modified as simply as possible, without complex modifications.
- **MINIMIZE CHANGES: Make the smallest possible modification to fix the vulnerability. Change only the necessary lines and preserve as much of the original code structure as possible.** 
- **PREFER SIMPLE FIXES: Use simple checks (null checks, boundary checks) rather than restructuring code.** 
- Source code patch must only patch the vulnerability within the Fix_Target_Code.
- You must patch the vulnerability and output safe Fix_Target_Code code without any vulnerabilities.
- The patched code must have the same start and end as the Fix_Target_Code we provided.
- Tabs and spaces used in Fix_Target_Code are preserved in the generated patched.
- Keep all parentheses used in Fix_Target_Code unchanged.
- The functionality of the existing Fix_Target_Code must not be changed.
- When you modify the source code, the rationale for modifying the source code must also be output.
</Important_Note>
